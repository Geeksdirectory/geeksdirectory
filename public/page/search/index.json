[{"content":"\nVNet Peering With azure Bastion Architecture\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/az-104/azure-bastion/","title":"AZ-104 Azure Bastion"},{"content":"\nused to distribute the incoming network traffic across a set of backend servers\nAzure load balancer You can have an application hosted on a set of machines. You want user traffic to be distributed equally across the machines. For this we can make use of the Azure Load Balancer service, Here the Azure Load Balancer can distribute traffic across the private IP addresses of the backend machines. Load Balancer SKU\u0026rsquo;s - The Basic SKU is going to retire on September 30, 2025 In azure we have standard load balancer which have SLA (Service Level Agreement) of 99.99%\nloadbalancer healthy or not (health probe )\nTo use loadbalancer it is necessary to make a machines (vms) in availability set or scale set\nDeployment of basic load balancer in azure failed to setup load-balancer bcoz my vms are not on availability set it is on availability zones plz rectify this :( {lab 116} [!NOTE] like basic LB we dont need vms in availability set or scale set for standard load balancer\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/az-104/azure-loadbalancer/","title":"AZ-104 Azure loadbalancer"},{"content":"\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/az-104/hands-on/","title":"AZ-104 hands-on"},{"content":"Connection troubleshoot tool Azure Network Watcher is a monitoring and diagnostic service that provides tools to troubleshoot and gain insights into your Azure network resources. It helps ensure your Azure virtual networks operate efficiently by identifying connectivity issues, diagnosing performance problems, and monitoring network traffic.\nKey Features of Azure Network Watcher Network Diagnostics:\nConnection Troubleshooting: Checks connectivity between a virtual machine and an endpoint (e.g., another VM, an on-premises server, or a public endpoint). Network Security Group (NSG) Flow Logs: Captures network traffic through NSGs for analysis. IP Flow Verify: Validates whether traffic is allowed or denied to/from a specific IP address by NSG rules. Monitoring and Insights:\nPacket Capture: Captures network traffic packets for detailed analysis. Network Performance Monitor: Provides insights into the performance of connections between resources. Topology Viewer: Visualizes your network architecture and dependencies. Metrics and Logs:\nCollects and analyzes metrics/logs related to network health and usage (e.g., traffic volume, latency). Connection Monitor:\nContinuously monitors the connectivity of Azure resources to external endpoints or within Azure. Diagnostic Tools:\nNext Hop Analysis: Identifies the next hop in the network route for traffic. VPN Diagnostics: Troubleshoots VPN gateway and connections. When to Use Azure Network Watcher Troubleshooting connectivity issues in Azure VNets. Monitoring and analyzing network traffic for performance or security concerns. Visualizing network topologies for better architecture understanding. Diagnosing issues with NSG rules or VPN configurations. Capturing packets for in-depth problem analysis during outages. Network Watcher is an essential tool for maintaining healthy and secure Azure networks.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/az-104/network-watcher-service/","title":"AZ-104 Network watcher service"},{"content":"PAn Azure Storage Account is a fundamental service in Azure that provides cloud-based storage solutions for data. It supports a variety of storage types, including blobs, files, queues, tables, and disks. Below is an explanation of Azure Storage Accounts, their types, and how to use them.\nKey Features of Azure Storage Accounts Highly Available: Data is stored redundantly for durability, ensuring high availability. Scalable: Automatically scales based on your storage needs. Secure: Offers encryption, shared access signatures, and identity-based access. Cost-effective: Offers pricing tiers based on usage and redundancy options. Accessible: Supports REST APIs, SDKs, and CLI for integration. Types of Azure Storage Services Blob Storage: Used to store unstructured data like text, images, videos, backups, etc. Types of blobs: Block Blob: For large objects like images and videos. Append Blob: For append-only operations, like logging. Page Blob: For random access, used in Virtual Machine disks. File Storage (Azure Files): Provides fully managed, cloud-based file shares accessible via SMB or NFS protocols. Use cases: File sharing across VMs, on-premises, or cloud. Queue Storage:\nA messaging solution for communication between applications. Useful for decoupling components and processing tasks asynchronously. Table Storage:\nA NoSQL key-value store for semi-structured data. Use cases: Storing logs, metadata, and structured data. Disk Storage: Persistent, high-performance block storage for Azure VMs. Types: Managed Disks, Unmanaged Disks. Types of Azure Storage Accounts General-purpose v2 (GPv2): Supports all storage types: blobs, files, queues, and tables. Best for most scenarios. Includes advanced features like lifecycle management and hot/cool/archive access tiers. General-purpose v1 (GPv1): Supports all storage types but lacks advanced features. Lower cost, but less efficient. Blob Storage Account: Optimized for blob storage. Supports hot, cool, and archive access tiers. Premium Storage Accounts: For scenarios requiring low latency and high throughput. Mainly for VM disks and high-performance applications. Redundancy Options in Azure Storage Azure Storage provides redundancy options to ensure durability and high availability of data:\nLocally Redundant Storage (LRS): Stores three copies of data in the same data center. Cheapest option. Zone-Redundant Storage (ZRS): Stores data in multiple availability zones within the same region. Geo-Redundant Storage (GRS): Stores three copies in the primary region and replicates to a secondary region. Read-Access Geo-Redundant Storage (RA-GRS): Provides read access to the secondary region in addition to GRS. Access Tiers for Blob Storage Hot: Optimized for data accessed frequently. Higher storage cost but lower access cost. Cool: Optimized for data accessed infrequently (e.g., once a month). Lower storage cost but higher access cost. Archive: For long-term storage of data rarely accessed. Lowest storage cost but requires rehydration to access. How to Create an Azure Storage Account (Using Azure Portal and CLI) 1. Using Azure Portal Navigate to Storage Accounts: Go to the Azure Portal and search for \u0026ldquo;Storage Accounts.\u0026rdquo; Click \u0026ldquo;Create\u0026rdquo;: Click \u0026ldquo;Create\u0026rdquo; to create a new storage account. Configure Basics: Select a Resource Group or create a new one. Specify the Storage Account Name (must be unique globally). Choose Region and Performance (Standard or Premium). Select Redundancy (LRS, GRS, etc.). Review and Create: Configure additional options like Networking and Advanced settings (if needed). Review and click Create. 2. Using Azure CLI az storage account create \\ --name mystorageaccount \\ --resource-group MyResourceGroup \\ --location eastus \\ --sku Standard_LRS \\ --kind StorageV2 How to Use Azure Storage Services Blob Storage Example Upload a Blob:\naz storage blob upload \\ --account-name mystorageaccount \\ --container-name mycontainer \\ --name myfile.txt \\ --file /path/to/localfile.txt Download a Blob:\naz storage blob download \\ --account-name mystorageaccount \\ --container-name mycontainer \\ --name myfile.txt \\ --file /path/to/downloadedfile.txt File Storage Example Create a File Share:\naz storage share create \\ --account-name mystorageaccount \\ --name myshare Mount Azure File Share to a VM:\nUse SMB or NFS protocols for mounting. Best Practices for Using Azure Storage Accounts Choose the Right Storage Type:\nUse Blob for unstructured data, Table for NoSQL, File for shared access, etc. Use Access Tiers Efficiently:\nUse Hot for frequently accessed data and Archive for long-term backups. Secure Your Data:\nUse Shared Access Signatures (SAS) for limited access. Enable Azure AD authentication where possible. Monitor and Optimize Costs:\nEnable Azure Monitor for storage metrics. Use lifecycle management policies to move data to cheaper tiers automatically. Enable Redundancy Based on Needs:\nUse LRS for cost efficiency or GRS for disaster recovery. Azure Storage Accounts are versatile and cater to a wide variety of scenarios, making them a cornerstone of cloud-based applications. Let me know if you\u0026rsquo;d like to dive deeper into any specific storage type or feature!\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/az-104/storage-account/","title":"AZ-104 Storage Account"},{"content":"In Microsoft Azure, a User-Defined Route (UDR) ==allows users to customize how network traffic is routed within their virtual networks.== Azure automatically creates default system routes for traffic, but in some scenarios, you may need more control over the traffic flow. A UDR gives you this control.\nKey Concepts of User-Defined Routing: Default System Routes:\n==Azure sets up system routes to manage traffic between subnets, virtual networks (VNets), and the internet automatically.== Examples of default routes: Route traffic between subnets within the same VNet. Route traffic from a VNet to the internet via the default gateway. Route traffic to on-premises networks through a connected VPN or ExpressRoute gateway. Why Use UDR?\nTo override the default routes. To direct traffic through specific network virtual appliances (NVAs) Azure Network Virtual Appliance like firewalls. To implement network security policies or segment the network logically. ==To block certain types of traffic.== How UDR Works:\nRoute Table: A UDR ==consists of a custom route table==, which is associated with a subnet. Routes: Each route in the route table defines: Address Prefix: The destination CIDR block. Next Hop Type: Where the traffic for the given address prefix should go. Next Hop Types:\nVirtual Appliance: Directs traffic to a specific IP address of an NVA like a firewall. Virtual Network Gateway: Directs traffic to a VPN or ExpressRoute gateway. Internet: Directs traffic to Azure\u0026rsquo;s default internet gateway. Virtual Network: Routes traffic to another subnet within the VNet. None: Drops the traffic. Scenarios for UDR:\nCustom Traffic Inspection: Forcing traffic to pass through an NVA for logging or monitoring. Specific Routing: Directing traffic to specific on-premises networks via a particular VPN gateway. Blocking Traffic: Preventing traffic from accessing certain IP ranges by setting the next hop as \u0026ldquo;None.\u0026rdquo; Steps to Create a User-Defined Route: Create a Route Table:\nGo to the Azure portal. Navigate to the Route Tables service. Click + Create, and define the name, region, and resource group. Add Routes to the Route Table:\nOpen the route table you just created. Add routes specifying the destination address prefix and next hop type. Associate the Route Table with Subnets:\nOpen the subnet settings in your virtual network. Link the route table to the desired subnet. Example: Imagine you have a VNet with three subnets:\nFrontend Backend GatewaySubnet You want all traffic from the Frontend subnet to be inspected by a firewall hosted in the Backend subnet (with IP 10.0.2.4). To achieve this:\nCreate a UDR for the Frontend subnet. Add a route: Address Prefix: 0.0.0.0/0 (all traffic) Next Hop Type: Virtual Appliance Next Hop IP Address: 10.0.2.4 Associate the route table with the Frontend subnet. Limitations: UDRs cannot directly route traffic between peered VNets unless explicitly configured. Azure services with forced tunneling may not fully respect UDRs. System routes (e.g., for Azure platform traffic) cannot be overridden in certain cases. User-defined routes provide flexibility to control network traffic flows and implement sophisticated architectures for security, performance, and compliance.\nwhy to use UDR User-Defined Routes (UDRs) in Azure are used when you need custom control over network traffic flow within a virtual network (VNet). By default, Azure creates system routes to manage traffic, but UDRs allow you to override these defaults to implement specific requirements. Below are the scenarios where UDRs are beneficial and the reasons for using them.\nWhen to Use User-Defined Routes Custom Traffic Control:\nWhen you want to direct traffic to pass through specific network virtual appliances (NVAs), such as firewalls or proxies. Example: Directing outbound traffic from a subnet to an NVA for inspection or monitoring. Traffic Blocking:\nWhen you need to block access to specific IP addresses or networks. Example: Dropping traffic to certain destinations by setting the Next Hop Type to \u0026ldquo;None.\u0026rdquo; Force-Tunneling Traffic:\nWhen you need to force all traffic, including internet-bound traffic, through a specific on-premises gateway or firewall. Example: Routing outbound internet traffic to an on-premises proxy server for compliance or monitoring. Custom On-Premises Routing:\nWhen you have multiple on-premises networks connected to Azure via VPN or ExpressRoute, and you need specific routing between these networks. Example: Routing traffic for specific on-premises subnets via specific gateways. Segmenting Traffic Within VNets:\nWhen you want to control how traffic flows between subnets within a virtual network. Example: Allowing one subnet to communicate only with specific destinations in another subnet. Overcoming Azure System Route Limitations:\nWhen Azure\u0026rsquo;s default routes are insufficient or restrictive for your architecture. Example: Ensuring that traffic between two peered VNets flows through a central NVA for auditing. Enabling Traffic Inspection and Monitoring:\nWhen you want to inspect traffic using third-party solutions for security or logging. Example: Sending all east-west traffic between subnets to a third-party firewall. Why Use User-Defined Routes Enhanced Security:\nUDRs help enforce security policies by directing traffic to firewalls, proxies, or other security appliances. Blocking access to unauthorized or harmful IP addresses improves the overall security posture. Improved Network Control:\nCustom routes give you granular control over how traffic flows between resources, subnets, and external networks. Compliance and Monitoring:\nMany organizations require traffic to be monitored or filtered to comply with regulatory requirements. UDRs help enforce such policies. Optimize Costs and Performance:\nBy directing traffic through specific routes, you can optimize bandwidth usage and avoid unnecessary latency. Support for Complex Architectures:\nIn advanced scenarios, such as hub-and-spoke architectures, UDRs are critical to managing traffic between multiple VNets and external networks. Flexibility:\nUDRs allow you to override Azure\u0026rsquo;s system routes, providing the flexibility to meet unique business or technical requirements. Common Scenarios Traffic Filtering:\nScenario: All outbound internet traffic should be filtered by a firewall hosted in a specific subnet. Solution: Use a UDR with the Next Hop Type set to \u0026ldquo;Virtual Appliance\u0026rdquo; pointing to the firewall. Hub-and-Spoke Network:\nScenario: In a hub-and-spoke network, all spoke VNets should route traffic through the hub for inspection or to access shared services. Solution: Apply UDRs to the spoke subnets to direct traffic to the hub\u0026rsquo;s NVA or gateway. Internet Traffic Control:\nScenario: All internet-bound traffic from Azure must pass through on-premises infrastructure. Solution: Configure a UDR to route traffic to the on-premises VPN or ExpressRoute gateway. Cross-Premises Routing:\nScenario: Traffic from Azure to different on-premises networks must take different paths. Solution: Add UDRs with different next hops for specific on-premises destination CIDRs. Benefits Granular Control: Tailor traffic routing to meet specific security, performance, or operational requirements. Enhanced Security Posture: Ensures traffic flows through secure and controlled paths. Scalable Architectures: Simplifies the implementation of complex network topologies. Improved Visibility: Enables routing for inspection, logging, and compliance checks. By using UDRs, organizations can effectively implement network policies, secure their environments, and support diverse architectures.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/az-104/user-defined-routes/","title":"AZ-104 User defined routes"},{"content":" 1. Best Case Definition: Jab algorithm apne kaam ko sabse efficient tareeke se kare, i.e., ==minimum time lage.== Example: ==Linear Search: Agar element list ke pehle hi index pe mil jaye==. int linearSearch(int[] arr, int target) { for (int i = 0; i \u0026lt; arr.length; i++) { if (arr[i] == target) return i; // Found at first position } return -1; } Best Case Complexity: O(1) (First element match ho gaya). 2. Average Case Definition: Jab algorithm ka performance typical input ke liye analyze kare. Example: Linear Search: Jab target element random position pe ho. Agar list ke har position pe element hone ke equal chances hain, toh on average tumhe array ka aadha iterate karna padega. Average Case Complexity: O(n/2) ≈ O(n). 3. Worst Case Definition: Jab algorithm apne kaam ko sabse inefficient tareeke se kare, i.e., maximum time lage. Example: Linear Search: Jab element list ke last index pe ho ya na ho. int linearSearch(int[] arr, int target) { for (int i = 0; i \u0026lt; arr.length; i++) { if (arr[i] == target) return i; // Last element match or no match } return -1; } Worst Case Complexity: O(n) (Pura array traverse karna padega). Case-wise Complexity for Different Algorithms Algorithm Best Case Average Case Worst Case Linear Search O(1) O(n) O(n) Binary Search O(1) O(log n) O(log n) Bubble Sort O(n) O(n²) O(n²) Quick Sort O(n log n) O(n log n) O(n²) Merge Sort O(n log n) O(n log n) O(n log n) Hash Table Search O(1) O(1) O(n) Example: Binary Search Best Case: Jab element middle pe hi mil jaye. Complexity: O(1). Average Case: Jab element mid ke around somewhere ho. Complexity: O(log n). Worst Case: Jab element exist na kare ya end tak dhoondhna pade. Complexity: O(log n). int binarySearch(int[] arr, int target) { int low = 0, high = arr.length - 1; while (low \u0026lt;= high) { int mid = low + (high - low) / 2; if (arr[mid] == target) return mid; // Best Case else if (arr[mid] \u0026lt; target) low = mid + 1; else high = mid - 1; } return -1; // Worst Case (not found) } Key Insights Best Case: Ideal situation. Rarely defines real-world performance. Average Case: Most realistic measure of an algorithm’s efficiency. Worst Case: Safest measure. Defines the upper bound on runtime. ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/best-average-worst-cases/","title":"Best average and worstcases time complexity"},{"content":"\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/big-data-analysis/1.-syllabus/","title":"Big Data Analysis 1  syllabus"},{"content":"\nArchitecture of Ethereum: Detailed Explanation in Pointwise Format Ethereum\u0026rsquo;s architecture is a sophisticated framework that enables it to function as a decentralized platform for smart contracts and dApps. It consists of several interconnected layers and components, each playing a crucial role in the system\u0026rsquo;s functionality.\n1. Ethereum Virtual Machine (EVM) Definition: The heart of Ethereum\u0026rsquo;s architecture, the EVM is a decentralized, global computer that executes smart contracts. Key Features: Executes Ethereum\u0026rsquo;s smart contract code in a deterministic way. Turing-complete, meaning it can perform any computation given enough resources. Ensures isolation: Code execution in the EVM does not affect the host machine. Role: Processes the state transitions caused by transactions. 2. Smart Contracts Definition: Self-executing contracts with logic written in code, stored, and executed on the Ethereum blockchain. Key Features: Written in high-level languages like Solidity or Vyper. Deployed on the blockchain for public access and immutability. Role: Automates processes, enabling trustless agreements between parties. 3. Ethereum Blockchain Definition: A distributed ledger that records all transactions and smart contract executions. Components: Blocks: Contain transaction data, previous block hash, and metadata. Blockchain State: Represents account balances and smart contract data. Role: Maintains a secure and immutable record of all activities on the network. 4. Ethereum Nodes Definition: Computers running the Ethereum software to maintain the network. Types of Nodes: Full Nodes: Store the entire blockchain and validate all transactions. Light Nodes: Store only the header of blocks for faster operation. Role: Ensure the blockchain\u0026rsquo;s decentralization and consensus. 5. Ethereum Consensus Mechanism Definition: Ensures all nodes in the network agree on the blockchain\u0026rsquo;s current state. Mechanisms: Proof of Stake (PoS) (Ethereum 2.0): Validators stake ETH to propose and validate blocks. More energy-efficient than Proof of Work (PoW). Proof of Work (PoW) (Legacy Ethereum 1.0): Miners solved complex mathematical problems to add blocks. Role: Provides security and prevents double-spending or malicious behavior. 6. Accounts Definition: Entities that can hold ETH or interact with the Ethereum network. Types of Accounts: Externally Owned Accounts (EOA): Controlled by private keys. Can send transactions and hold ETH. Contract Accounts: Managed by smart contract code. Can interact with other contracts or EOAs. Role: Facilitates user interaction with the blockchain. 7. Transactions Definition: Instructions sent by EOAs to transfer ETH or interact with smart contracts. Key Features: Includes sender, recipient, value (ETH), and optional data (for contract execution). Must include a fee (gas) to compensate miners/validators. Role: Trigger state changes on the blockchain. 8. Gas and Gas Mechanism Definition: A fee system used to allocate computational resources on the Ethereum network. Key Features: Paid in ETH by users to miners/validators. Calculated based on the complexity of the transaction and network demand. Gas Limit: Maximum amount of gas the user is willing to spend. Base Fee: Minimum fee required (introduced in Ethereum\u0026rsquo;s London Upgrade). Role: Prevents abuse of the network by ensuring fair usage. 9. Ethereum State Definition: Represents the current snapshot of all account balances and smart contract data. Components: Global State: The overall condition of the Ethereum blockchain. State Transition: Changes caused by the execution of transactions. Role: Tracks the evolving data as the network processes transactions. 10. High-Level Programming Languages Definition: Programming languages used to write smart contracts. Examples: Solidity: Most popular language for Ethereum contracts. Vyper: Designed for simplicity and security. Role: Enables developers to create smart contracts for decentralized applications. 11. Storage Layers Definition: Ethereum stores data on-chain in the form of: World State: Includes account balances and contract storage. Logs: Events emitted by smart contracts for external applications. Role: Provides data persistence and accessibility across the network. 12. Ethereum Network Layers Definition: Layers that facilitate communication and interaction in Ethereum. Peer-to-Peer Network: Ensures all nodes can communicate to propagate transactions and blocks. Application Layer: dApps interact with Ethereum via APIs like Web3.js. Role: Ensures seamless interaction between users, dApps, and the Ethereum network. 13. Decentralized Applications (dApps) Definition: Applications built on Ethereum that run on smart contracts. Key Features: Transparent and tamper-proof. Frontend interfaces connected to Ethereum via APIs like Web3.js or Ethers.js. Role: Provides real-world use cases like DeFi, gaming, and supply chain. 14. Upgrades and Forks Definition: Changes or improvements in Ethereum’s architecture to enhance performance or add features. Examples: Ethereum 2.0 (Merge): Transitioned to PoS for better scalability. London Hard Fork: Introduced the gas fee system. Role: Adapts the network to new challenges and technological advancements. 15. Security Features Definition: Mechanisms to protect the network from attacks. Key Features: Cryptographic hashing ensures data integrity. Validators/miners ensure consensus. Secure smart contract coding practices prevent vulnerabilities. Role: Maintains trust in the decentralized system. Diagram Structure Suggestion for Ethereum Architecture: Core Components: EVM at the center, surrounded by Smart Contracts, Accounts, and Gas Mechanism. Blockchain Layer: Represented by Blocks, State, and Transactions. Consensus Layer: Show PoS validators and their role in finalizing blocks. Applications: Include dApps and APIs at the user interaction layer. Let me know if you\u0026rsquo;d like a visual breakdown or help with creating the actual diagram!\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/architecture-of-ethereum/","title":"Blockchain technology Architecture of Ethereum"},{"content":"\nBlockchain Architecture and Main Components Blockchain architecture is the foundational design that ==enables the functioning of a decentralized and secure system for data storage and transactions==. It is a ==combination of multiple layers and components that work together to achieve transparency, security, and immutability.==\n1. Core Architecture Layers Blockchain architecture typically consists of these layers:\nApplication Layer: The interface for users and developers. Hosts ==decentralized applications (dApps) and smart contracts.== Example: Wallets, payment systems, DeFi platforms, or supply chain solutions. Consensus Layer: ==Ensures all nodes in the network agree on the state of the blockchain==. Uses ==consensus mechanisms like Proof of Work (PoW), Proof of Stake (PoS), or Delegated Proof of Stake (DPoS).== ==Prevents double-spending and maintains the integrity of the chain==. Network Layer (P2P Layer): Handles communication between nodes. Nodes share, propagate, and validate transactions and blocks across the decentralized network. Implements protocols for networking (e.g., TCP/IP, Gossip protocol). Data Layer: The foundation where data is stored as a chain of blocks. Each block contains a cryptographic hash, timestamp, and list of transactions. Ensures immutability through cryptographic linking. Infrastructure Layer: Includes hardware, physical nodes, and cloud systems where the blockchain is hosted. 2. Main Components of Blockchain The blockchain system has several key components that ensure its functionality:\na. Blocks Structure: Header: Hash: ==A cryptographic hash of the previous block\u0026rsquo;s header, linking blocks together.== Nonce: ==A random number used in Proof of Work to solve the cryptographic puzzle.== Timestamp: The exact time the block was created. Merkle Root: A hash that represents the combined data of all transactions in the block. Body: A list of validated transactions. b. Transactions Represents data (e.g., payments, smart contract execution). Includes: ==Sender and recipient addresses.== Digital signatures for authenticity. Transaction fees. c. Nodes Full Nodes: Store the complete blockchain and validate new blocks. Light Nodes: Only store block headers, not the entire chain. Miner Nodes: Validate transactions and propose new blocks through mining (PoW) or staking (PoS). Validator Nodes: Responsible for validating and reaching consensus in PoS or DPoS systems. d. Cryptography Hashing: ==Converts input data into fixed-length strings==. ==Example: SHA-256 in Bitcoin.== Digital Signatures: ==Ensures authenticity and integrity of transactions.== ==Uses public-private key cryptography.== e. Consensus Mechanisms ==Rules for validating transactions and adding blocks==. Popular types: Proof of Work (PoW): Solving computational puzzles (e.g., Bitcoin). Proof of Stake (PoS): Validators are chosen based on staked tokens (e.g., Ethereum 2.0). f. Smart Contracts Self-executing contracts with predefined rules encoded in code. Automatically enforce agreements when conditions are met. Example: Ethereum smart contracts for DeFi or NFTs. g. Ledger ==A tamper-proof, decentralized database where all transaction data is recorded.== Distributed across all nodes. h. Blockchain Protocol Defines how the blockchain operates, including transaction validation, block creation, and communication rules. Example: Bitcoin Protocol, Ethereum Protocol. 3. Key Processes in Blockchain Block Creation: Transactions are grouped into a block by miners or validators. Validation: Blocks are validated through consensus mechanisms. Propagation: Valid blocks are shared across the network. Immutability: Once a block is added, altering it would break the chain. Summary The architecture of blockchain ensures decentralization, transparency, and security. It relies on components like blocks, transactions, nodes, cryptography, and smart contracts, all integrated through a layered structure. This design underpins its versatility across industries like finance, healthcare, and supply chains.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/blockchain/","title":"Blockchain technology Blockchain"},{"content":"\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/blockchain-solution-actors/","title":"Blockchain technology Blockchain solution actors"},{"content":"Consensus mechanisms are protocols that ==ensure all participants (or nodes) in a distributed blockchain network agree on the validity of transactions and the state of the ledger.== They ensure trust and prevent issues like double spending or malicious actions without a central authority.\nHere are the three most common consensus mechanisms explained in detail:\n1. Proof of Work (PoW) Used by: Bitcoin, Ethereum (before Ethereum 2.0), Litecoin\nHow It Works Nodes (==miners) compete to solve a complex mathematical puzzle==. The puzzle involves finding a ==specific number (nonce==) that, when combined with the block\u0026rsquo;s data, produces a cryptographic hash with certain properties (e.g., starting with a specific number of zeros). ==The first miner to solve the puzzle broadcasts their solution to the network==. ==Other nodes verify the solution. If valid, the miner gets rewarded (e.g., Bitcoin) and the block is added to the blockchain. == Key Features Computational Effort: Requires ==high computational power to solve puzzles==. Security: It\u0026rsquo;s computationally expensive to manipulate data because an attacker would need to redo the PoW for all subsequent blocks. Advantages High security due to the computational effort required. Proven and reliable, as demonstrated by Bitcoin. Disadvantages ==Energy-intensive, leading to high electricity costs and environmental concerns==. ==Limited scalability== due to the time and resources required for mining. 2. Proof of Stake (PoS) Used by: Ethereum 2.0, Cardano, Polkadot, Solana\nHow It Works Instead of miners, the network has validators. ==Validators are chosen to propose and validate blocks based on the amount of cryptocurrency they \u0026ldquo;stake\u0026rdquo; (lock in the network).== The ==more cryptocurrency a validator stakes, the higher their chance of being selected to propose a new block.== If ==the proposed block is valid, the validator earns rewards (like transaction fees).== Validators are penalized (via \u0026ldquo;slashing\u0026rdquo; their stake) for malicious activities, such as validating fraudulent transactions. Key Features Economic Incentive: Validators have financial skin in the game since they risk losing their staked funds. ==Energy Efficiency==: Does not require high computational power. Advantages Much more ==energy-efficient than PoW.== ==Faster block creation and validation==. ==Encourages participation through staking rewards.== Disadvantages Wealth concentration: Validators with larger stakes have higher chances of being selected, potentially leading to centralization. \u0026ldquo;Nothing at Stake\u0026rdquo; problem: Validators might validate multiple chains simultaneously, increasing risks of chain splits. Modern PoS systems address this issue through penalties like slashing. ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/consensus-mechanisms/","title":"Blockchain technology Consensus mechanisms"},{"content":"https://www.investopedia.com/terms/d/distributed-ledger-technology-dlt.asp\nDistributed Ledger Technology (DLT) is a ==decentralized system for recording, sharing, and synchronizing data across multiple locations (or nodes) in a network.== In the context of blockchain, DLT refers to a specific implementation of this concept where ==data is organized into blocks that are cryptographically linked to form a chain.==\nHere’s a breakdown of DLT in blockchain:\n1. What is a Distributed Ledger? A distributed ledger is a ==digital database shared and synchronized across multiple sites, institutions, or geographies==. ==Each participant (or node) in the network maintains a copy of the ledger==. Unlike traditional centralized databases, ==distributed ledgers don’t rely on a central authority to process, validate, or store data.==\n2. How Blockchain Implements DLT Blockchain is one type of distributed ledger. It organizes the data into blocks of transactions, which are then:\nLinked together cryptographically: Each block contains a unique cryptographic hash of the previous block, ensuring data integrity and immutability. Validated by ==consensus mechanisms==: Nodes in the network reach an agreement on the validity of transactions using algorithms like Proof of Work (PoW), Proof of Stake (PoS), or others. Distributed across the network: All participating nodes have a synchronized and identical copy of the ledger. 3. Core Features of DLT in Blockchain Decentralization: No single entity has control; all nodes participate equally in validating and maintaining the ledger. Immutability: Once data is added, it cannot be altered or deleted without consensus, ensuring security and trust. Transparency: All nodes have access to the same data, fostering accountability. Consensus Mechanisms: Algorithms ensure agreement among nodes about the validity of transactions. 4. Advantages of DLT in Blockchain Enhanced Security: Data is cryptographically secured and tamper-proof. Trustlessness: Participants don\u0026rsquo;t need to trust each other; they trust the network\u0026rsquo;s rules and mechanisms. Efficiency: Eliminates intermediaries and allows for faster, automated processes. Traceability: All transactions are logged and can be traced back to their origin. 5. Applications of DLT in Blockchain Cryptocurrencies: Bitcoin, Ethereum, and other digital currencies rely on blockchain to manage and validate transactions. Supply Chain Management: Tracks goods as they move through the supply chain, ensuring authenticity and transparency. Financial Services: Facilitates faster and more secure cross-border payments, loans, and settlements. Healthcare: Ensures secure sharing of patient records. ** Systems**: Provides secure and transparent digital voting. 6. Difference Between Blockchain and Other DLTs While blockchain is the most well-known form of DLT, not all distributed ledgers use blockchains. Some other DLTs, like Hedera Hashgraph or Corda, use different architectures and data structures but still share the core principles of decentralization, transparency, and security.\nIn summary, DLT is the umbrella term for decentralized ledger systems, and blockchain is a specific type of DLT that organizes data into linked blocks.\nDecentralized: No single central authority controls the system; decision-making is spread across multiple participants. Example: Blockchain consensus.\nDistributed: Data or systems are spread across multiple locations/nodes, but not necessarily without central control. Example: Cloud databases.\nSo, decentralized focuses on control, and distributed focuses on data spread. Blockchain is both!\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/distributed-ledger-technology/","title":"Blockchain technology Distributed ledger technology"},{"content":"[[Hinglish Double spending]] ==Double-spending is the fraudulent act of spending the same digital currency more than once==. In a decentralized blockchain network, such as Bitcoin, where there is no central authority to validate transactions, the Proof of Work (PoW) consensus mechanism plays a crucial role in preventing double-spending. Here’s how it works:\n1. Overview of the Problem In traditional digital systems, a central authority (like a bank) ensures that the same money isn\u0026rsquo;t spent twice. In blockchain, without a central authority, anyone could try to:\nBroadcast the same transaction to multiple nodes. Attempt to spend the same funds in multiple transactions. Without a solution, this would destroy trust in the system.\n2. Proof of Work Mechanism PoW ==addresses the issue of double-spending by enforcing strict rules for adding transactions to the blockchain and making it computationally expensive to cheat==. The steps below illustrate how PoW prevents double-spending:\nStep 1: Transaction Broadcast Users broadcast their transactions to the network. These transactions include details like sender, receiver, amount, and a digital signature to prove ownership of the funds. Step 2: Transaction Validation Nodes (computers in the network) verify the transactions by checking: The sender’s account balance is sufficient. The digital signature is valid. Step 3: Block Creation Miners collect valid transactions into a block. To add this block to the blockchain, miners must solve a complex cryptographic puzzle (the PoW process). This involves finding a hash value (output of a hash function) that meets specific conditions (e.g., starts with a certain number of zeros). Step 4: Block Addition to the Blockchain The first miner to solve the puzzle broadcasts the solution to the network. Other nodes verify: The block’s validity. The accuracy of the miner’s solution. Once verified, the block is added to the blockchain. Step 5: Irreversibility As more blocks are added on top of the newly mined block, it becomes increasingly difficult to alter the block due to the computational effort required to \u0026ldquo;re-mine\u0026rdquo; the chain. How PoW Prevents Double-Spending Timestamped Transactions\nTransactions are added to blocks in a chronological order. Once a transaction is included in a block, it becomes part of the immutable blockchain history. Consensus Mechanism\nOnly one valid version of the blockchain can exist, as miners compete to solve the PoW puzzle. The chain with the most computational work (i.e., the longest chain) is considered the valid one. Any attempt to double-spend requires creating an alternative chain, which is computationally infeasible. High Cost of Fraud\nTo successfully double-spend, an attacker would need to: Control at least 51% of the network’s total mining power (known as a 51% attack). Re-mine the altered block and all subsequent blocks faster than the rest of the network. The cost of acquiring this much computational power and energy makes double-spending impractical. Network Validation\nIf a malicious actor tries to double-spend by submitting two conflicting transactions: Only one of them will be included in a block. The other transaction will be invalidated as it conflicts with the already confirmed transaction. Immutability\nOnce a block containing a transaction is added to the blockchain and several more blocks are built on top of it, reversing the transaction becomes nearly impossible. The deeper a block is in the chain, the more secure it is against tampering. Example of Double-Spending Prevention in PoW Scenario: A user (Attacker A) has 1 Bitcoin (BTC) and tries to spend it twice: Transaction 1: A sends 1 BTC to Vendor X. Transaction 2: A sends 1 BTC to Vendor Y (double-spending attempt). What Happens: Both transactions are broadcast to the network. Miners verify the transactions and include only one (e.g., the first one) in the next block. The block containing Transaction 1 is added to the blockchain after a miner solves the PoW puzzle. The network accepts Transaction 1 as valid, while Transaction 2 is rejected because: The funds were already spent in Transaction 1. The blockchain reflects that A no longer has the 1 BTC after Transaction 1. Key Strengths of PoW Against Double-Spending Deterministic Resolution: PoW ensures that only one version of the blockchain is valid at any given time, resolving conflicts automatically. Economic Incentives: Miners are rewarded with cryptocurrency for solving PoW puzzles honestly, giving them no incentive to process fraudulent transactions. Security Through Computational Difficulty: The immense computational power required to overwrite blocks makes fraudulent attempts highly expensive and unlikely to succeed. Limitations of PoW in Preventing Double-Spending 51% Attack: If an attacker controls the majority of mining power, they could potentially reorganize the blockchain and execute double-spending attacks. Latency: Transactions may take time to be confirmed (e.g., Bitcoin typically requires 6 confirmations), during which users might worry about double-spending. Conclusion Proof of Work solves the double-spending problem by making it computationally infeasible to alter the blockchain’s history. Its reliance on economic incentives, decentralization, and cryptographic security ensures that malicious actors cannot easily manipulate the system. This feature is a cornerstone of blockchain’s trustless and secure nature.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/how-proof-of-work-solves--the-problem-of-double-spending/","title":"Blockchain technology how proof of work solves  the problem of double spending"},{"content":"\nHyperledger Fabric is a blockchain framework within the Hyperledger ecosystem designed for enterprise applications. It is modular, scalable, and supports permissioned networks, making it ideal for use cases requiring privacy, security, and performance.\nKey Features of Hyperledger Fabric Permissioned Blockchain: Only authorized participants can join and interact in the network, ensuring privacy and security. Modular Architecture: Components like consensus, membership, and ledger storage are modular and pluggable, allowing customization for specific business needs. Channels for Privacy: Fabric supports channels, enabling private communication and transactions between specific subsets of participants. Smart Contracts (Chaincode): Fabric uses \u0026ldquo;Chaincode\u0026rdquo; to implement business logic. Chaincode can be written in various programming languages like Go, Java, and Node.js. Pluggable Consensus: Consensus mechanisms are pluggable, supporting algorithms like Raft or Kafka for fault-tolerant orderers. No Native Cryptocurrency: Unlike public blockchains like Ethereum, Fabric doesn’t have a native cryptocurrency. This makes it more focused on business processes rather than token economics. Components of Hyperledger Fabric Ledger: The ledger is composed of two parts: World State: A database representing the latest state of the system. Transaction Log: A record of all transactions for auditability. Peer Nodes: Endorsing Peers: Validate and endorse transactions based on smart contract logic. Committing Peers: Commit validated transactions to the ledger. Anchor Peers: Act as a bridge for communication between organizations in a consortium. Orderer (Ordering Service): Responsible for ordering transactions into blocks and broadcasting them to peers. Supports consensus algorithms like Raft, Kafka, or other pluggable options. Membership Service Provider (MSP): Manages identities and access control in the network using a Public Key Infrastructure (PKI). Client Application: Applications interact with the Fabric network via an SDK to submit transactions and query the ledger. Channels: Fabric allows participants to create channels, which are private sub-networks within the larger blockchain. Only members of a channel can view and transact on its ledger. Smart Contracts (Chaincode): Business rules and transaction logic are implemented using Chaincode. How Hyperledger Fabric Works 1. Transaction Flow A client application initiates a transaction proposal. Endorsing peers execute the transaction logic (Chaincode) and generate an endorsement. The transaction is sent to the ordering service, which batches transactions into blocks. The block is sent to committing peers, which validate and append it to the ledger. 2. Endorsement Policy Defines the criteria for approving a transaction (e.g., \u0026ldquo;A majority of Organization A\u0026rsquo;s peers must endorse this transaction\u0026rdquo;). 3. Consensus Process Transactions are ordered using a consensus protocol, ensuring that all peers process them in the same sequence. Consensus in Hyperledger Fabric Fabric uses a modular consensus approach, where consensus is split into three stages:\nEndorsement Phase: Peers simulate and sign transactions based on Chaincode logic. Ordering Phase: The ordering service batches transactions into blocks and determines the sequence. Validation Phase: Peers validate transactions against the endorsement policy and commit them to the ledger. Features that Differentiate Hyperledger Fabric Privacy and Confidentiality: Supports private transactions and data sharing using channels or private data collections. No Cryptocurrency Dependency: Businesses don\u0026rsquo;t need to worry about managing cryptocurrencies or tokens, making Fabric suitable for enterprise use. Multi-Language Smart Contracts: Developers can use familiar programming languages like Java, Go, and Node.js. High Scalability: Modular architecture and pluggable consensus support scaling to large networks. Use Cases of Hyperledger Fabric Supply Chain Management: Track the provenance of goods and manage supplier relationships. Healthcare: Securely share patient records and ensure data privacy. Financial Services: Enable real-time settlement of payments and cross-border transactions. Government: Manage land registries, voting systems, and public services transparently. Retail and Manufacturing: Manage product recalls, quality assurance, and inventory tracking. Advantages of Hyperledger Fabric Enterprise-Grade Security: Built with privacy and security features for regulated industries. Customizability: Modular components enable businesses to tailor the network to their needs. Privacy: Channels and private data collections allow for confidential transactions. Scalability: Efficient transaction flow and modular design ensure scalability. Active Community and Support: Backed by the Linux Foundation and a global developer community. Challenges of Hyperledger Fabric Complex Setup: Initial setup and configuration require expertise and can be time-intensive. High Maintenance Cost: Operating a permissioned network requires dedicated resources. Not Ideal for Decentralized Applications: Its permissioned nature makes it unsuitable for fully decentralized systems like public blockchains. Limited Ecosystem Compared to Public Blockchains: Lacks the large-scale developer and application ecosystem of public blockchains like Ethereum. Hyperledger Fabric Architecture |--------------------------| | Application Layer | |--------------------------| | Membership Service (MSP)| |--------------------------| | Orderer Nodes | |--------------------------| | Peer Nodes | |--------------------------| | Ledger (World State + Log)| |--------------------------| Application Layer: Interfaces with the network via SDKs. Membership Service: Manages identities and authentication. Orderer Nodes: Handle consensus and block creation. Peer Nodes: Store the ledger and execute Chaincode. Comparison with Public Blockchains Feature Hyperledger Fabric Public Blockchains (e.g., Ethereum) Access Permissioned Permissionless Privacy High Low Consensus Mechanism Pluggable (e.g., Raft, Kafka) Proof of Work / Proof of Stake Native Cryptocurrency None Ether, Bitcoin, etc. Performance High Moderate to Low Use Case Enterprise Applications Decentralized Applications Conclusion Hyperledger Fabric is a powerful blockchain framework designed for enterprises. Its focus on privacy, modularity, and scalability makes it ideal for industries like supply chain, healthcare, and finance. While it differs significantly from public blockchains like Ethereum, its flexibility and enterprise-friendly features provide a robust foundation for permissioned blockchain applications.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/hyperledger-fabric/","title":"Blockchain technology Hyperledger Fabric"},{"content":"https://www.geeksforgeeks.org/introduction-to-merkle-tree/\n==hash tree , data structure== used in blockchain and other cryptographic systems to efficiently and securely verify large amounts of data.\norganizes data into a tree-like structure, where each leaf node contains a cryptographic hash of data, and each non-leaf node is a hash of its child nodes. The root of the tree, called the Merkle Root, summarizes all the data in the tree.\nWhy Use a Merkle Tree in Blockchain? Efficient Verification: Allows quick verification of whether a specific piece of data (like a transaction) belongs to a block, without requiring the entire dataset. Data Integrity: Any change in data at any level propagates to the root, ensuring tamper-proof data. Reduced Storage: Only the root hash needs to be stored or verified instead of the entire dataset. Merkle Tree Structure A Merkle Tree is built by repeatedly hashing pairs of data until a single hash remains, which is the Merkle Root.\nLeaf Nodes: The bottom-most layer. Each leaf node represents the cryptographic hash of a piece of data (e.g., a transaction in a blockchain). Intermediate Nodes: Above the leaf nodes. Each node is a hash of its two child nodes. Merkle Root: The top-most node in the tree. Represents the combined hash of all the data in the tree. Advantages of Merkle Trees Data Integrity: If any data (transaction) is tampered with, it alters the Merkle Root, making it easy to detect. Efficient Verification: Verifying a transaction requires only a few hashes (logarithmic in size), even if the dataset is huge. Scalability: Works well with large datasets, as only the Merkle Root is stored or transmitted. Bandwidth Saving: Reduces the need to send all transactions for verification, just the proof path. Applications of Merkle Trees in Blockchain Bitcoin: Bitcoin uses Merkle Trees to store transactions in a block. The Merkle Root is stored in the block header and serves as a compact representation of all transactions in the block. Ethereum: Ethereum uses a more advanced structure called Merkle Patricia Trie to manage state data (e.g., account balances, smart contracts). Efficient Light Nodes: Simplified Payment Verification (SPV) wallets use Merkle Trees to verify transactions without downloading the entire blockchain. Proofs and Audits: Used in applications like supply chain auditing or secure data sharing. Summary A Merkle Tree is a cryptographic data structure that organizes data into a hierarchical tree, allowing efficient and secure verification of data integrity. It is foundational to blockchain because it enables fast verification, scalability, and tamper detection, making it ideal for handling large amounts of transaction data.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/merkle-tree/","title":"Blockchain technology Merkle Tree"},{"content":"Paxos is a consensus algorithm primarily used in distributed systems to ensure that a group of nodes (or machines) agree on a single value, even in the presence of failures. While Paxos itself is not inherently a part of blockchain systems, its principles inspire some blockchain consensus mechanisms. Let\u0026rsquo;s break it down and relate it to blockchain:\nWhat is Paxos? Paxos is a protocol designed to solve the problem of distributed consensus. Imagine a network of unreliable nodes trying to agree on a single decision, such as the next value in a ledger. Paxos ensures that:\nAgreement: All functioning nodes agree on the same value. Safety: No two nodes agree on conflicting values. Liveness: The system eventually makes progress, despite node failures. It achieves this by electing a leader (proposer) and following a structured process to propose and accept values.\nKey Components of Paxos Proposers: Suggest values to be agreed upon. Acceptors: Receive proposals and decide whether to accept them. Learners: Learn the final agreed-upon value. Paxos has two main phases:\nPrepare Phase: The proposer sends a \u0026ldquo;prepare\u0026rdquo; request to acceptors, asking if they are willing to accept a new proposal. Accept Phase: If a majority of acceptors agree, the proposer sends the actual proposal to finalize it. How Paxos Relates to Blockchain Distributed Consensus: Blockchain also solves the problem of distributed consensus, where all nodes must agree on the next block to add to the chain. Paxos provides a framework for achieving this agreement in a reliable way. Leader-Based Consensus: Paxos often relies on a leader to propose values, similar to some blockchain systems like Proof of Authority (PoA) or Raft-based private blockchains, where a central authority or leader coordinates consensus. Fault Tolerance: Paxos can tolerate failures of some nodes (Byzantine or otherwise), aligning with blockchain\u0026rsquo;s goal of resilience against failures or attacks. Why Paxos is Not Commonly Used in Public Blockchains Paxos has some limitations that make it less ideal for public, decentralized blockchains like Bitcoin or Ethereum:\nTrust Assumptions: Paxos assumes a more controlled environment where nodes are mostly honest. Public blockchains need to handle Byzantine faults (malicious actors), which Paxos doesn’t fully address. Scalability Issues: Paxos is not optimized for large-scale networks with thousands of nodes, whereas blockchains are designed to work in such environments. Performance Bottlenecks: Paxos requires multiple rounds of communication among nodes, which can introduce latency and slow performance in a global, distributed system. Where Paxos Might Be Used in Blockchain Paxos-like algorithms are more suited for private or permissioned blockchains, where:\nNodes are known and trusted (e.g., consortium blockchains). The environment is more controlled (fewer nodes, less chance of malicious actors). Examples include:\nHyperledger Fabric: Uses similar consensus methods in specific scenarios. Permissioned Blockchains: Implement consensus with leader-based approaches inspired by Paxos or Raft. Comparison: Paxos vs. Blockchain Consensus (Proof of Work) Feature Paxos Blockchain (e.g., Bitcoin) Fault Tolerance Handles crash failures Handles Byzantine failures Scalability Limited to small networks Scalable to thousands of nodes Leader Dependency Requires a leader No central leader in PoW/PoS Communication Rounds Multiple rounds for consensus Single round mining/validation Conclusion While Paxos isn’t directly used in blockchains, it provides foundational ideas for distributed consensus. Blockchains like Bitcoin and Ethereum require more robust solutions (e.g., Proof of Work, Proof of Stake) to handle adversarial environments and scale to global networks. However, Paxos-inspired methods are relevant in permissioned blockchains and other distributed ledger technologies where nodes are trusted.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/paxos/","title":"Blockchain technology PAXOS"},{"content":"Here’s a detailed explanation of different consensus mechanisms in blockchain technology, including PoA, PoET, PoW, PoS, LPoS, PBFT, and PoB:\n1. Proof of Authority (PoA) What is PoA? Proof of Authority relies on a small group of pre-approved validators (or authorities) who are responsible for verifying transactions and adding them to the blockchain.\nHow It Works:\nValidators are chosen based on their identity and reputation. A block is validated by one of these trusted authorities and added to the blockchain. Features:\nFast and energy-efficient. Used in permissioned blockchains. Advantages:\nHigh transaction throughput. Low energy consumption. Disadvantages:\nCentralized, as it relies on a fixed set of trusted validators. Use Cases:\nVeChain, Ethereum testnets. key components validators block creation validation process consensus block finality 2. Proof of Elapsed Time (PoET) What is PoET? Proof of Elapsed Time is a consensus mechanism where validators are randomly selected to propose blocks after waiting for a specific amount of time.\nHow It Works:\nEach validator waits for a randomly assigned time period. The first validator to finish the wait proposes the next block. The random waiting is enforced by using a secure hardware component, such as Intel’s SGX (Software Guard Extensions). Features:\nFairly distributes the right to validate a block. Advantages:\nEnergy-efficient (no need for mining). Randomness ensures fairness. Disadvantages:\nRequires specialized hardware (centralized dependence on Intel SGX). Use Cases:\nHyperledger Sawtooth. 3. Proof of Work (PoW) What is PoW? Proof of Work is the oldest and most widely used consensus mechanism, requiring miners to solve complex cryptographic puzzles to validate transactions and add blocks to the blockchain.\nHow It Works:\nMiners compete to solve a computational puzzle. The first miner to solve the puzzle proposes the next block. The network verifies the block and adds it to the blockchain. Features:\nHighly secure due to computational difficulty. Advantages:\nDecentralized and resistant to attacks. Disadvantages:\nEnergy-intensive. Slow transaction speeds. Use Cases:\nBitcoin, Litecoin. 4. Proof of Stake (PoS) What is PoS? Proof of Stake selects validators based on the number of coins they hold (their “stake”) and are willing to lock up.\nHow It Works:\nValidators lock up a certain amount of cryptocurrency as a stake. Validators are selected randomly, with the chance of being selected proportional to their stake. Selected validators validate blocks and earn rewards. Features:\nEnergy-efficient. Advantages:\nNo need for expensive mining equipment. Faster and more scalable than PoW. Disadvantages:\nWealthy validators have more control over the network. Use Cases:\nEthereum 2.0, Cardano, Polkadot. 5. Leased Proof of Stake (LPoS) What is LPoS? Leased Proof of Stake is a variation of PoS where token holders can “lease” their stake to another validator to increase the validator’s chances of being selected.\nHow It Works:\nToken holders lease their coins to validators. Validators use the leased tokens to secure block creation rights. Both the validator and the leaser share the block rewards. Features:\nEncourages collaboration between users and validators. Advantages:\nUsers without technical expertise can participate by leasing tokens. Disadvantages:\nValidators still have more control, leading to potential centralization. Use Cases:\nWaves blockchain. Key components token ownership validator selection block production token leasing and rewards security and consensus 6. Practical Byzantine Fault Tolerance (PBFT) What is PBFT? PBFT is a consensus mechanism designed to handle Byzantine faults, where nodes in the network may act maliciously or fail.\nHow It Works:\nNodes exchange messages to reach consensus on the validity of a transaction. At least two-thirds of the nodes must agree on a decision for consensus to be reached. Features:\nEnsures network reliability even in the presence of malicious nodes. Advantages:\nHighly fault-tolerant. Efficient in small, permissioned blockchains. Disadvantages:\nNot scalable for large networks. Use Cases:\nHyperledger Fabric, Zilliqa. 7. Proof of Burn (PoB) What is PoB? Proof of Burn requires participants to “burn” (destroy) cryptocurrency by sending it to an irrecoverable wallet address to earn the right to mine or validate transactions.\nHow It Works:\nParticipants burn coins by sending them to an address from which they can never be recovered. The more coins a participant burns, the higher their chances of mining or validating blocks. Features:\nIntroduces scarcity, incentivizing participants to burn coins. Advantages:\nEnergy-efficient compared to PoW. Incentivizes long-term commitment. Disadvantages:\nRequires users to sacrifice their assets, which may discourage participation. Use Cases:\nSlimcoin. Comparison of Consensus Mechanisms Mechanism Energy Use Decentralization Scalability Security Use Cases Proof of Work (PoW) High High Low Very High Bitcoin, Litecoin Proof of Stake (PoS) Low Moderate Moderate High Ethereum 2.0, Cardano Leased PoS (LPoS) Low Moderate Moderate High Waves Proof of Authority Very Low Low (Centralized) High Moderate VeChain, Ethereum Testnets Proof of Elapsed Time Very Low Moderate High Moderate Hyperledger Sawtooth PBFT Moderate Low (Permissioned) High Moderate Hyperledger Fabric Proof of Burn (PoB) Low Moderate Moderate Moderate Slimcoin Summary Each consensus mechanism is tailored for different blockchain use cases:\nPoW: Security-focused, used in public blockchains like Bitcoin. PoS: Energy-efficient, scalable, popular in modern blockchains. LPoS: Allows token holders to participate without running nodes. PoA: Fast and suitable for permissioned blockchains. PoET: Energy-efficient with fairness for permissioned networks. PBFT: Ideal for private and enterprise blockchains. PoB: Encourages long-term commitment and is more experimental. If you need further clarity on any of these, feel free to ask! 😊\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/poapospowlpospbftpobpoet/","title":"Blockchain technology poa,pos,pow,lpos,pbft,pob,poet"},{"content":"\nPrivate Blockchain System A Private Blockchain is a type of blockchain where access to the network is ==restricted and controlled==. Unlike public blockchains like Bitcoin or Ethereum, which are open for anyone to join and participate, private blockchains operate in a closed ecosystem, typically managed by a single organization or a consortium.\nKey Characteristics of a Private Blockchain Permissioned Access:\nOnly authorized participants can join and interact with the network. Nodes are carefully selected and verified. Centralized Control:\nA central authority or consortium governs the network, deciding who has access and what rights each participant holds. Customizable Consensus Mechanisms:\nUnlike proof-of-work (used in public blockchains), private blockchains often use faster, more efficient consensus algorithms like Raft, PBFT (Practical Byzantine Fault Tolerance), or Proof of Authority (PoA). High Performance:\nSince the number of participants is limited, transactions are processed faster, with higher throughput and lower latency. Privacy:\nTransactions and data are visible only to authorized participants, ensuring confidentiality. Lower Energy Consumption:\nPrivate blockchains do not rely on energy-intensive mining processes like proof-of-work. How Private Blockchains Work Network Setup: The organization or consortium establishes a network and defines rules for participation. Permissioning: Only authorized participants (nodes) are allowed to join. These nodes often represent trusted entities, such as partner organizations. Consensus Mechanism: Nodes validate transactions using a lightweight consensus mechanism suitable for a small, trusted network. Data Sharing: Data is shared and updated across the network, but access is restricted to authorized participants. Use Cases of Private Blockchains Supply Chain Management: Track goods and ensure transparency among authorized participants. Example: IBM Food Trust for tracking food safety. Financial Services: Facilitate faster and more secure interbank transactions. Example: Quorum (used by JPMorgan Chase). Healthcare: Securely store and share medical records among approved entities. Example: MedicalChain. Enterprise Data Management: Manage sensitive internal data securely across departments or subsidiaries. Identity Management: Store and verify user identities within a trusted network. Government and Voting: Enable transparent but secure voting and record management. Advantages of Private Blockchains Controlled Environment: Access is limited to trusted participants, reducing risks associated with malicious users. Enhanced Privacy: Sensitive information is only visible to authorized entities. Faster Transactions: Limited participants and lightweight consensus lead to quicker processing times. Regulatory Compliance: Easier to adhere to regulations as the network is controlled. Customizability: Can be tailored to meet the specific needs of an organization or industry. Challenges of Private Blockchains Centralization: Limited decentralization may reduce trust compared to public blockchains. Reduced Transparency: Since access is restricted, it lacks the transparency of public blockchains. Single Point of Failure: A central authority could become a bottleneck or a target for attacks. Limited Use Cases: Not suitable for applications requiring high decentralization or public trust. Onboarding Costs: Requires initial investment to onboard and maintain participants and infrastructure. Comparison: Public vs Private Blockchains Aspect Public Blockchain Private Blockchain Access Open to anyone. Restricted to authorized participants. Governance Decentralized (managed by the community). Centralized (managed by an organization). Consensus Energy-intensive (e.g., PoW, PoS). Lightweight (e.g., PBFT, PoA). Performance Slower due to global participation. Faster due to limited participants. Transparency Fully transparent and public. Partially transparent, limited to members. Security High security via decentralization. Relatively secure but depends on governance. Energy Usage High (e.g., mining in PoW). Low (efficient consensus mechanisms). Examples of Private Blockchain Platforms Hyperledger Fabric: A modular blockchain framework designed for enterprise use cases. Supports permissioned access and private transactions. Quorum: Ethereum-based private blockchain developed by JPMorgan Chase. Designed for financial services and enterprise applications. Corda: A blockchain platform focused on enterprise transactions, particularly in the finance sector. Ripple: Primarily used for real-time cross-border payments. Multichain: Provides a private blockchain platform for enterprise-grade applications. When to Use a Private Blockchain Sensitive data or processes that need confidentiality. Applications where participants are known and trusted. Situations requiring regulatory compliance. Use cases demanding high transaction speed and efficiency. Conclusion Private blockchains provide a secure, efficient, and customizable solution for organizations looking to implement blockchain technology in controlled environments. While they trade off some transparency and decentralization, they excel in privacy, performance, and compliance, making them ideal for enterprise use cases.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/private-blockchain-system/","title":"Blockchain technology Private Blockchain System"},{"content":"Raft is a consensus algorithm designed for managing a replicated log in a distributed system. It is simpler to understand and implement compared to Paxos while achieving similar goals. Raft is widely used in distributed systems to ensure that multiple nodes agree on a single consistent state, even in the presence of failures.\nLet\u0026rsquo;s dive into the details of Raft:\nOverview of Raft Raft ensures that all nodes in a distributed system maintain a consistent log of events or commands. This is crucial for applications like distributed databases, where every node must agree on the same sequence of operations.\nRaft has three primary goals:\nSafety: Nodes never apply conflicting changes. Liveness: The system continues making progress despite failures of some nodes. Understandability: Raft is designed to be easy to implement and reason about. Key Components of Raft Nodes (Servers): Leader: Responsible for managing the log and coordinating actions. Followers: Passive participants that respond to requests from the leader. Candidate: A node that seeks election to become the leader. Log Entries: A sequence of commands or data that the nodes must replicate consistently. Terms: Logical time periods used to organize elections and ensure correctness. How Raft Works Raft operates in three main stages:\n1. Leader Election When a system starts, or the leader fails, Raft initiates an election. A node becomes a candidate and sends RequestVote messages to other nodes. Nodes vote for a candidate if: They haven\u0026rsquo;t already voted in the current term. The candidate\u0026rsquo;s log is as up-to-date as their own. If a candidate receives a majority of votes, it becomes the leader for that term. 2. Log Replication The leader receives client requests and appends them as new log entries. The leader sends AppendEntries messages to followers to replicate the log. Followers acknowledge these messages, and once a majority acknowledge, the leader commits the entry. The leader informs followers of the committed entries, which they then apply to their state machines. 3. Commitment A log entry is considered committed when the leader and a majority of followers have it stored. Committed entries are applied to the state machine to update the system\u0026rsquo;s state. Raft’s Guarantees Leader Completeness: A leader has all committed entries from previous terms in its log. Log Matching: If two nodes have the same log entry at the same index, they have the same preceding entries. Election Safety: At most, one leader can be elected in a given term. Failure Handling in Raft Leader Failure: If the leader fails, followers wait for a timeout and start a new election. The node with the most up-to-date log is likely to win the election. Network Partition: Raft ensures consistency by allowing progress only in the majority partition. Node Recovery: When a failed node comes back online, it synchronizes its log with the current leader. Advantages of Raft Simplicity: Raft is designed to be easier to implement and understand compared to Paxos. Safety and Consistency: Raft guarantees a consistent log across all nodes. Fault Tolerance: Raft can tolerate failures of up to half the nodes (e.g., 2 out of 5 nodes). Use Cases of Raft Distributed Databases: Raft is commonly used in systems like Etcd and Consul, which manage distributed key-value stores. Log Replication: Ensures high availability and fault tolerance for logs in distributed systems. Cluster Management: Often used for leader election and configuration management in distributed clusters. Comparison: Raft vs Paxos Feature Raft Paxos Understandability Simpler, modular design Complex and hard to understand Leader Role Explicit leader role Leader role less defined Performance Efficient with fewer message exchanges Requires more communication Implementation Easier to implement Difficult to implement Challenges in Raft Network Delays: Can slow down leader elections or log replication. Scalability: Works best for smaller clusters (e.g., 5–7 nodes); scalability can be an issue for very large systems. Election Overhead: Frequent leader elections in unstable networks can impact performance. Conclusion Raft is an effective and widely-used consensus algorithm for ensuring consistency and fault tolerance in distributed systems. Its focus on understandability makes it an excellent choice for developers implementing distributed applications like databases or cluster managers. While not a perfect fit for large-scale decentralized systems like public blockchains, Raft is invaluable in private or permissioned blockchains and other distributed systems with controlled environments.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/raft/","title":"Blockchain technology RAFT"},{"content":"\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/transactions-in-bitcoin-network/","title":"Blockchain technology Transactions in bitcoin network"},{"content":"AlexNet is a pioneering convolutional neural network (CNN) architecture in deep learning, known for its groundbreaking success in computer vision. Developed by Alex Krizhevsky, Ilya Sutskever, and Geoffrey Hinton, AlexNet won the ImageNet Large Scale Visual Recognition Challenge (ILSVRC) in 2012 with a significant improvement in accuracy over previous models. Here’s a breakdown of AlexNet’s components, architecture, and impact on deep learning:\n1. Introduction to AlexNet AlexNet was designed to classify high-resolution images from the ImageNet dataset, which includes over 1.2 million images across 1,000 classes. It was one of the first CNNs to demonstrate the potential of deep learning in computer vision, marking a major leap in image classification accuracy. 2. Architecture of AlexNet Layered Structure: AlexNet is an 8-layer CNN, consisting of five convolutional layers followed by three fully connected layers.\nSummary of Layers:\nConvolutional Layers (5 layers): The first five layers perform feature extraction through convolutional operations. Pooling Layers: Max pooling is used after some convolutional layers to reduce spatial dimensions and retain important features. Fully Connected Layers (3 layers): The last three layers are fully connected and work as classifiers, with the final layer producing probabilities for each class. Detailed Structure:\nInput Layer: Takes a 224x224x3 (RGB) image as input. First Convolutional Layer: Applies 96 filters of size 11x11 with a stride of 4, followed by max pooling. Second Convolutional Layer: Applies 256 filters of size 5x5, followed by another max-pooling layer. Third, Fourth, and Fifth Convolutional Layers: These layers use smaller 3x3 filters. The third layer has 384 filters, while the fourth and fifth have 256 filters. Fully Connected Layers: Three fully connected layers, where the final layer is a softmax output with 1,000 nodes, each representing a class in ImageNet. 3. Key Innovations in AlexNet Rectified Linear Unit (ReLU) Activation:\nAlexNet used the ReLU activation function (instead of traditional sigmoid or tanh), which helped reduce training time by addressing the vanishing gradient problem and enabling faster convergence. Dropout Regularization:\nDropout was introduced to combat overfitting, which involves randomly disabling neurons during training. This made AlexNet robust and helped prevent it from memorizing specific patterns in the data. Data Augmentation:\nAlexNet used data augmentation techniques, such as image translations, horizontal reflections, and color perturbations, to artificially increase the dataset size and improve model generalization. GPU Utilization:\nAlexNet was one of the first models to use GPUs to speed up training, splitting the model across two GPUs to handle the large number of computations, which made training on large datasets like ImageNet feasible. Local Response Normalization (LRN):\nUsed to normalize the activity across neurons, LRN helped enhance feature detection by making the activations more sensitive to high-frequency details. 4. Impact of AlexNet on Deep Learning Breakthrough in Computer Vision: AlexNet achieved a top-5 error rate of 15.3%, much lower than the previous best of 26.2%. This significant improvement highlighted the potential of deep CNNs and accelerated interest in deep learning research and applications. Influence on Architecture Design: AlexNet’s structure and techniques—such as ReLU, dropout, data augmentation, and GPU usage—became foundational principles in modern deep learning. Inspiration for Subsequent Models: AlexNet inspired deeper and more complex models like VGG, GoogLeNet, and ResNet, which built on its architecture and ideas to achieve even better performance. 5. Advantages and Limitations of AlexNet Advantages:\nDemonstrated the effectiveness of deep learning on large-scale image classification tasks. Provided a blueprint for designing deep networks, especially in computer vision. Introduced crucial techniques like ReLU and dropout, which are still widely used. Limitations:\nComputationally expensive and requires powerful hardware, especially GPUs, for efficient training. Shallow by modern standards, with only eight layers, limiting its capability to learn complex representations compared to newer models. The model parameters are large, which can lead to longer training times and more memory consumption. 6. Applications of AlexNet Image Classification: AlexNet’s success in the ImageNet competition made it a standard model for image classification tasks. Feature Extraction: Pre-trained AlexNet models are commonly used to extract features for downstream tasks like object detection, image segmentation, and more. Transfer Learning: AlexNet pre-trained weights on ImageNet are often fine-tuned on other datasets to adapt to different computer vision tasks. Summary for Exam Answer Define AlexNet as a pioneering CNN that won the 2012 ImageNet competition and marked a major milestone in deep learning. Explain its architecture: 8 layers with 5 convolutional and 3 fully connected layers. Highlight innovations: ReLU activation, dropout, data augmentation, and GPU utilization. Describe impact on deep learning: popularized CNNs and influenced subsequent models. List applications in image classification, feature extraction, and transfer learning. This detailed explanation provides a comprehensive view of AlexNet, covering key points for a deep learning exam question.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/deep-learning/alexnet/","title":"Deep Learning AlexNet"},{"content":"GRU, or ==Gated Recurrent Unit==, is a type of Recurrent Neural Network (RNN) architecture similar to Long Short-Term Memory (LSTM) networks but simpler in structure. It was introduced by Kyunghyun Cho et al. in 2014 as a way to address some of the same issues with standard RNNs (like vanishing gradients) but with a more streamlined design. Here’s a detailed, pointwise breakdown of GRUs:\n1. Introduction to GRU Definition: GRU is an RNN variant designed to handle long-term dependencies in sequential data by using gating mechanisms, similar to LSTMs, but with fewer parameters. Motivation: GRUs were created to simplify the LSTM structure while retaining the ability to learn long-range dependencies, which standard RNNs struggle with. 2. Structure of GRU Unlike LSTM, which has three gates (forget, input, and output), GRU uses only two gates: update gate and reset gate. This makes the GRU more computationally efficient and less complex than LSTM. 3. Components of GRU Update Gate: Controls how much of the previous hidden state’s information is retained and how much of the new input is added. It determines the extent to which the unit updates its content. $$ z_t = \\sigma(W_z \\cdot [h_{t-1}, x_t] + b_z)$$\nReset Gate: Controls how much of the previous hidden state should be \u0026ldquo;forgotten\u0026rdquo; for computing the new hidden state. When reset is low, it ignores much of the previous hidden state. $r_t = \\sigma(W_r \\cdot [h_{t-1}, x_t] + b_r)$\n4. Hidden State Update in GRU Candidate Hidden State: After applying the reset gate, GRU generates a candidate hidden state ( \\tilde{h}_t ), which incorporates the new input and controlled parts of the previous hidden state.\n$\\tilde{h}t = \\tanh(W_h \\cdot [r_t * h{t-1}, x_t] + b_h)$\nFinal Hidden State: The final hidden state ( h_t ) is then calculated as a combination of the previous hidden state and the candidate hidden state, using the update gate to decide how much of each should contribute. $$ h_t = (1 - z_t) * h_{t-1} + z_t * \\tilde{h}_t$$\nHere, ( z_t ) (update gate) decides how much of the candidate hidden state ( \\tilde{h}t ) should contribute to the final output, and ( (1 - z_t) ) controls how much of the previous hidden state ( h{t-1} ) should be retained.\n5. Advantages of GRU Simpler Architecture: GRU is less complex than LSTM due to fewer gates and parameters, making it faster to train. Memory Efficiency: With fewer gates and parameters, GRUs are computationally less expensive, often making them preferable in situations with limited resources. Comparable Performance: In many tasks, GRUs perform as well as or even better than LSTMs, especially when long-term dependencies are less critical. 6. Applications of GRU Natural Language Processing: Used in text generation, machine translation, and sentiment analysis. Speech Recognition: GRUs are applied to model audio sequences in tasks like speech-to-text conversion. Time Series Forecasting: Often used in financial and weather prediction models, where past values influence future predictions. Video Analysis: GRUs can be used in processing sequences of video frames for action recognition and video captioning. 7. Comparison with LSTM Gating Mechanism: GRU uses two gates (update and reset) compared to LSTM’s three (forget, input, and output). Efficiency: GRU has fewer parameters and is often faster to train. Memory Retention: In certain cases, LSTMs are better at capturing long-term dependencies, though GRUs are often sufficient for medium-length dependencies. 8. Challenges of GRU Less Control Over Memory: While simpler, GRUs have slightly less flexibility in controlling memory compared to LSTMs due to fewer gates. Not Always Optimal for Very Long Sequences: In cases where very long dependencies are needed, LSTMs might outperform GRUs. 9. Variants of GRU Bidirectional GRU: Processes sequences in both forward and backward directions to capture more context. Stacked GRU: Multiple GRU layers are stacked to learn more complex temporal patterns. 10. Conclusion GRUs provide a streamlined and efficient solution for handling sequential data with medium to long dependencies. Their simpler structure and faster training make them a popular choice for a wide range of sequence-based tasks, and they are particularly useful when computational resources are limited. Summary Points for Exam Answer Define GRU and its purpose in sequence modeling. Explain update and reset gates and how they control information flow. List advantages of GRUs over LSTMs. Outline applications in NLP, time series, and video processing. Conclude with its benefits in terms of simplicity and training efficiency. This format covers the essential points of GRUs for a 10-mark answer.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/deep-learning/gru/","title":"Deep Learning GRU"},{"content":"LeNet is one of the earliest convolutional neural network (CNN) architectures, developed by Yann LeCun and his collaborators in the late 1980s. Initially designed for character recognition, such as reading handwritten digits in postal codes, it became a foundational architecture that inspired many modern CNNs. Here’s a detailed look at LeNet:\n1. Overview of LeNet Architecture Name: LeNet-5, commonly referred to simply as LeNet, is the most well-known version. Purpose: Originally designed for handwritten digit classification, particularly on the MNIST dataset of 28x28 grayscale images. Significance: LeNet introduced many of the core concepts that are fundamental to CNNs today, including convolutional layers, pooling layers, and fully connected layers. 2. LeNet-5 Architecture Details Input: Accepts a 32x32 grayscale image (though commonly resized from 28x28 in MNIST for compatibility). Layers: Convolutional Layer (C1): 6 filters of size 5x5, resulting in a 28x28 output feature map. Activation function: Sigmoid or Tanh (common in earlier networks; ReLU is used more in modern architectures). Subsampling Layer (S2) (Pooling Layer): Uses average pooling with a 2x2 filter and a stride of 2, resulting in a 14x14 output. Convolutional Layer (C3): 16 filters of size 5x5, resulting in a 10x10 output feature map. Each feature map in this layer is connected to a subset of the maps in the previous layer, introducing weight sharing to reduce the number of parameters. Subsampling Layer (S4): Similar to S2, it applies average pooling with a 2x2 filter, resulting in a 5x5 output. Fully Connected Layers (C5 and F6): C5: A fully connected layer with 120 units, where each unit is connected to all 5x5 input neurons from the previous layer. F6: A fully connected layer with 84 units. Output Layer: Uses softmax activation to output probabilities for each class (10 classes for digits 0-9 in MNIST). 3. Key Concepts Introduced by LeNet Convolutional Layers: Extract local features by using small filters (kernels) that slide over the input image, enabling the network to detect patterns like edges or textures. Pooling (Subsampling): Reduces spatial dimensions, making the network more computationally efficient and less sensitive to small distortions or translations in the input. Weight Sharing: By sharing weights in convolutional layers, LeNet significantly reduces the number of parameters, making it more efficient. Fully Connected Layers: Combine features learned from previous layers to make final classification decisions. 4. Applications of LeNet Primarily used for digit recognition tasks (like the MNIST dataset), where it achieves high accuracy. Also applied in early OCR (optical character recognition) systems and basic image classification tasks. 5. Limitations of LeNet Small Scale: The architecture is relatively shallow and was designed for small, simple images. It doesn’t perform well on large, complex images compared to modern deep CNNs. Activation Function Choice: Uses Tanh or Sigmoid activations, which can suffer from vanishing gradient issues. Modern networks often use ReLU to overcome this problem. Lack of Regularization: LeNet doesn’t incorporate regularization techniques like dropout, which are common in modern networks to prevent overfitting. 6. Impact and Legacy of LeNet LeNet laid the groundwork for deep learning research in image processing and computer vision, inspiring architectures like AlexNet, VGG, and ResNet. By introducing core principles like convolution, pooling, and weight sharing, LeNet showed that neural networks could effectively process images without extensive preprocessing. Summary for Exam Answer LeNet is an early CNN architecture designed for handwritten digit recognition. Introduced convolutional layers, pooling layers, and fully connected layers. Consists of 7 layers: alternating convolutional and pooling layers, followed by fully connected layers. Limitations include suitability mainly for simple tasks and small images. Legacy: Foundation for modern CNNs, influencing architectures like AlexNet, VGG, and ResNet. ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/deep-learning/lenet/","title":"Deep Learning LeNet"},{"content":"LSTM, or ==Long Short-Term Memory==, is a ==type of Recurrent Neural Network== (RNN) architecture ==designed to address the limitations of traditional RNNs==, ==particularly with long-term dependencies and the vanishing gradient problem==. LSTMs were introduced by Sepp Hochreiter and Jürgen Schmidhuber in ==1997== and have since become widely used in ==sequence-based tasks== like language modeling, machine translation, and time series analysis. Here’s a detailed breakdown of how LSTMs work and their components:\n1. Why LSTM? Challenge in Standard RNNs: Basic RNNs ==struggle to remember information over long sequences due to issues with vanishing and exploding gradients,== which occur during backpropagation. Solution: LSTMs ==overcome== this by ==introducing a structure of gates== and ==memory cells that allow the network to maintain and update information over longer time periods==. 2. Structure of LSTM LSTMs have a special structure made up of multiple ==\u0026ldquo;gates\u0026rdquo; and a cell state== that helps regulate the flow of information: Cell State: Acts as the memory of the LSTM, allowing information to flow unchanged, unless modified by gates. It enables LSTMs to remember information across time steps. Hidden State: Represents the output of the LSTM cell at each time step, combining with the cell state to maintain memory over time. 3. LSTM Gates The gates control what information is added to, removed from, or retained in the cell state. These are: Forget Gate: Decides which information from the previous cell state should be discarded. It takes in the previous hidden state and the current input and applies a sigmoid function to decide what fraction of each value to retain.\nInput Gate: Decides what new information will be added to the cell state. It consists of two parts:\nInput Gate Layer: Determines which values will be updated. Candidate Layer: Generates new candidate values that could be added to the cell state. Output Gate: Controls what part of the cell state will be passed to the next hidden state as output. This helps to selectively pass only relevant information to the next time step.\n4. Updating the Cell and Hidden States Cell State Update: The cell state is updated using the forget gate and input gate, which either retain part of the old cell state or add new information.\nHidden State Update: The hidden state is updated based on the cell state and the output gate.\n5. Advantages of LSTMs Long-Term Memory: LSTMs can remember information over long sequences, making them highly effective for tasks where context matters. Reduced Vanishing Gradient: The design of the gates allows gradients to flow more smoothly during backpropagation, mitigating the vanishing gradient problem. Flexibility: LSTMs can decide what information to keep or forget, offering a high degree of control over memory and state. 6. Applications of LSTMs Natural Language Processing: Used in tasks such as language translation, text generation, and sentiment analysis. Speech Recognition: For processing audio sequences and converting them into text. Time Series Prediction: Used for forecasting in areas like stock prices, weather, and other sequential data. Video Analysis: Applied to tasks such as action recognition in videos, where sequences of frames need to be analyzed over time. 7. Variants of LSTM Bidirectional LSTM: Processes data in both forward and backward directions, capturing more context. Stacked LSTM: Consists of multiple layers of LSTMs to learn higher-level features. Attention Mechanisms with LSTMs: Often combined to allow the model to focus on important parts of the sequence, especially in tasks like machine translation. 8. Conclusion LSTMs are powerful neural network architectures for handling sequential data and long-term dependencies, addressing key limitations of traditional RNNs. They have become essential in fields requiring temporal data processing, thanks to their gated structure and ability to retain memory effectively. Summary Points for Exam Answer Define LSTM as an advanced RNN with memory capabilities. Explain the cell state and hidden state. Describe the forget, input, and output gates. List applications and advantages over standard RNNs. Mention popular variants like Bidirectional and Stacked LSTMs. This structure should comprehensively cover LSTMs for a 10-mark question.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/deep-learning/lstm/","title":"Deep Learning LSTM"},{"content":"1. Introduction to RNNs Definition: RNNs (Recurrent Neural Networks) are a class of neural networks ==designed to process sequential data== by ==maintaining a memory of previous inputs.== Purpose: They are primarily used in tasks where data has ==temporal dependencies==, such as ==language modeling, time series analysis, and video processing.== 2. Structure of an RNN Recurrent Layers: Unlike feedforward neural networks, RNNs have ==loops within their layers that allow information to be passed from one time step to the next.== Hidden State: At each time step, the RNN has a hidden state that acts as a memory, storing information about previous inputs. 3. Working Mechanism of RNNs Input Sequence: RNNs take sequential data as input (e.g., a series of words or time steps). Time Steps: For each time step ( t ), the RNN receives the current input ( x_t ) and updates its hidden state ( h_t ) based on both ( x_t ) and the previous hidden state ( h_{t-1} ). 4. Types of RNNs Vanilla RNN: Basic form where each output depends on the current input and previous hidden state. LSTM (Long Short-Term Memory): An advanced RNN that handles long-term dependencies by using gates to control information flow. GRU (Gated Recurrent Unit): A simpler version of LSTM, which also controls information flow but has fewer parameters. Bidirectional RNNs: These process the sequence both forwards and backwards, capturing more context. 5. Applications of RNNs Natural Language Processing (NLP): Used in language modeling, text generation, machine translation, and sentiment analysis. Speech Recognition: RNNs can model temporal dependencies in speech, aiding in recognition and transcription. Time Series Prediction: RNNs are applied in financial forecasting, stock price prediction, and weather forecasting. Video Analysis: Used for action recognition, video captioning, and frame prediction. 6. Strengths of RNNs Sequential Processing: RNNs can process sequences of varying lengths, making them well-suited for time-dependent data. Memory Retention: By maintaining a hidden state across time steps, RNNs retain information from previous steps, which is essential for understanding context in sequences. 7. Challenges of RNNs Vanishing and Exploding Gradient Problems: During backpropagation, gradients can become very small or very large, making training difficult. This limits the RNN’s ability to remember information from long sequences. Difficulty with Long-Term Dependencies: Basic RNNs struggle to maintain information over many time steps, making them less effective for tasks requiring long-term memory. Computationally Intensive: Due to their sequential nature, RNNs take longer to train compared to feedforward networks. 8. Solutions to RNN Challenges LSTM and GRU: These architectures use gates to control the information flow and retain long-term dependencies, mitigating the vanishing gradient problem. Gradient Clipping: A technique to limit the size of gradients, which helps control the exploding gradient problem. Attention Mechanism: Often combined with RNNs to selectively focus on specific parts of the input sequence, improving performance on complex tasks like translation. 9. Training an RNN Backpropagation Through Time (BPTT): RNNs are trained using a modified version of backpropagation that unrolls the network across time steps, allowing the computation of gradients for each time step. Loss Function: RNNs typically use cross-entropy loss for classification tasks and mean squared error for regression. 10. Conclusion RNNs are foundational for sequence modeling and have enabled advancements in NLP, speech recognition, and time series forecasting. Although they have limitations, innovations like LSTMs, GRUs, and attention mechanisms continue to enhance their capabilities, making them relevant in deep learning research and applications. Tips for Exam Answer Define RNNs and highlight key features like hidden state and time-step processing. Explain the challenges and solutions with a focus on LSTMs and GRUs. List applications and examples for clarity. Include concise equations where necessary to clarify the hidden state updates. End with a conclusion on their importance in sequence modeling. This should provide a comprehensive answer for a 10-mark question on RNNs.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/deep-learning/rnn/","title":"Deep Learning RNN"},{"content":"\nThe vanishing gradient and exploding gradient problems are issues encountered in training deep neural networks, especially Recurrent Neural Networks (RNNs), that involve long sequences. These problems can make it difficult for RNNs to learn long-term dependencies and effectively propagate information through time steps. Here’s a detailed explanation of each:\n1. Vanishing Gradient Problem Definition: The vanishing gradient problem occurs when the gradients of the loss function become very small as they are backpropagated through each time step in the RNN. This results in gradients shrinking exponentially, which prevents weights from being updated effectively.\nCause:\nRNNs update their weights based on gradients calculated at each time step. During backpropagation through time (BPTT), these gradients are multiplied at each layer (or time step), which can lead to them becoming very small due to repeated multiplication of numbers less than one (common when activation functions like sigmoid or tanh are used). As a result, the information from earlier time steps has minimal impact on later time steps, making it challenging for RNNs to capture long-term dependencies. Effect:\nThe model \u0026ldquo;forgets\u0026rdquo; important earlier information in the sequence, making it ineffective at learning long-range dependencies. Training becomes slow and ineffective, as weights do not change significantly, especially for layers or time steps far from the final output. Example: In natural language processing, the vanishing gradient problem might prevent an RNN from understanding the context of words or phrases that appeared much earlier in a sentence.\n2. Exploding Gradient Problem Definition: The exploding gradient problem occurs when the gradients grow exponentially during backpropagation, causing excessively large weight updates and making the model unstable.\nCause:\nWhen the gradient is repeatedly multiplied across many time steps, and if weights are large or activations lead to values greater than one, the gradients can become very large. This causes the parameters to change drastically with each update, leading to unstable training and potentially causing the model to diverge. Effect:\nThe exploding gradient problem causes extremely large weight updates, which can result in numerical instability (e.g., NaN values) and make the model unusable. The model\u0026rsquo;s loss may oscillate wildly or increase dramatically, preventing convergence. 3. Solutions to Vanishing and Exploding Gradients Gradient Clipping:\nA technique to handle exploding gradients by setting a threshold value. If gradients exceed this threshold, they are scaled down to a manageable size. This prevents gradients from becoming excessively large, stabilizing the training process. Advanced Architectures:\nLSTM (Long Short-Term Memory) and GRU (Gated Recurrent Unit) are RNN variants specifically designed to handle the vanishing gradient problem. These architectures use gates to control information flow, making it easier to retain long-term dependencies. Better Initialization Techniques:\nUsing proper initialization methods, like Xavier or He initialization, can help prevent weights from starting at values that cause gradients to explode or vanish. Alternative Activation Functions:\nThe choice of activation function can impact gradient flow. ReLU (Rectified Linear Unit) and its variants (e.g., Leaky ReLU) are sometimes used in RNNs to mitigate vanishing gradients, though they are less common in RNNs than in other types of neural networks. 4. Why Vanishing and Exploding Gradients are More Common in RNNs Sequential Multiplications: RNNs compute gradients across each time step, leading to repetitive multiplication, which can exacerbate gradient issues. Long Sequences: RNNs, especially when applied to long sequences, require information to flow over many time steps, making it more likely for gradients to either shrink or grow uncontrollably. 5. Conclusion The vanishing and exploding gradient problems are fundamental issues in training RNNs on long sequences. Addressing these problems is essential for successful training of RNNs, particularly in applications involving long-term dependencies. Solutions like LSTMs, GRUs, gradient clipping, and better initialization techniques have made it possible to train deep RNNs effectively. Summary for Exam Answer Define vanishing and exploding gradients. Explain their causes and effects. Mention solutions like gradient clipping, advanced architectures (LSTM/GRU), and better initialization. Describe why these problems are especially relevant to RNNs. This provides a structured answer on vanishing and exploding gradients, covering key points for an exam response.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/deep-learning/vanishing-and-exploding-gradient/","title":"Deep Learning vanishing and exploding gradient"},{"content":"if - then condition public class Main { Public static void main(String[] args) { if (boolean expression T or F) { //body } else { // do this } } }\nElse If loops for loop /* Syntax of for loop for ( initialization; condition; increment /decrement){ //body } */\nWhile Loops /* Syntax: while (condition) { //body } */\nWhen to use which loop use while loop when we don\u0026rsquo;t know how many time loop run and use for loop when we know how many time does loop run\ndo while loop do {\n} while (condition);\ndo while loop executes atleast ones and after that it will check condition\nQ1 Check if the char is at lowercase or uppercase\nQ2. Fibonacci no.\nQ3 count repeated numbers\nQ4. reverse a number\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/2.-conditions-and-loops/","title":"DSA 2  Conditions and loops"},{"content":"Here’s a short and clear tabular comparison of ArrayList and LinkedList in English:\nFeature ArrayList LinkedList Storage Mechanism Uses a dynamic array internally. Uses a doubly linked list internally. Access Time Fast for random access (O(1) for get). Slow for random access (O(n) for get). Insertion Slow for inserting in the middle (O(n)). Fast for inserting anywhere (O(1)). Deletion Slow for deleting in the middle (O(n)). Fast for deleting anywhere (O(1)). Memory Usage Less memory as it stores only data. More memory as it stores node pointers too. Iterating Faster with for loop. Slower, requires traversal of nodes. Use Case Best for read-heavy operations. Best for insert/delete-heavy operations. Resizable Automatically resizes when full. Dynamically grows with new nodes. Code for arraylist: code for linkedlist ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/array-list-vs-linked-list/","title":"DSA Array list vs linked list"},{"content":"1. Find the largest and smallest element in an array import java.util.Arrays; class Main { public static void main(String[] args) { int [] arr = {3,2,1,3,4,5,4}; Arrays.sort(arr); int smallest = arr[0]; int largest = arr[arr.length-1]; System.out.println(smallest); System.out.println(largest); } } more approach: class Main { public static void main(String[] args) { int arr[] = {3,2,1,3,4,5,4}; int max = arr[0]; for (int i = 1; i \u0026lt; arr.length; i++) { if(arr[i]\u0026gt;max){ max = arr[i]; } } System.out.println(max); int min = arr[0]; for (int i = 1; i \u0026lt; arr.length; i++) { if(arr[i]\u0026lt;min){ min = arr[i]; } } System.out.println(min); } } 2. Reverse an array int[] arr = {1,2,3,4,5} output = 5,4,3,2,1\npublic class Main{ public static void main(String[] args){ int[] arr = {3,2,1,3,4,5}; int start = 0, end = arr.length - 1; while (start \u0026lt; end) { int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; start ++; end --; } System.out.println(\u0026#34;reversed array\u0026#34;+ java.util.Arrays.toString(arr)); } } 3. Check if an Array is Sorted class Main { public static void main(String[] args) { int[] arr = {1,2,3,4,5,6,7}; boolean isSorted = true; for(int i = 1 ; i \u0026lt; arr.length ; i++ ){ if (arr[i] \u0026lt; arr[i - 1]){ isSorted = false; } } System.out.println(\u0026#34;sorted array \u0026#34; + isSorted); } } 4. Move all zero to the end input:array = {0,0,0,23,134,2} output = {23,134,2,0,0,0}\npublic class Main { public static void main(String[] args) { int insertPosition = 0; int[] nums = {0,0,0,0,1,3,4}; for( int i = 0; i \u0026lt; nums.length; i++) { if(nums[i] != 0) { nums[insertPosition] = nums[i]; insertPosition++; } } while (insertPosition \u0026lt; nums.length) { nums[insertPosition++] = 0; } System.out.println(java.util.Arrays.toString(nums)); } } 5. Find the Second Largest Element 6. Find the Intersection of Two Arrays brute force method\noptimal solution\npublic class Main { public static ArrayList\u0026lt;Integer\u0026gt; intersectionOfArrays(int[] A, int[] B){ ArrayList\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int i = 0; j = 0; while (i\u0026lt; A.length \u0026amp;\u0026amp; j \u0026lt; B.length) { if(A[i] \u0026lt; B[j]) { i++; } else if (B[j]\u0026lt; A[i]) { j++; } else { ans.add(A[i]); i++; j++; } } return ans; } public static void main(String args[]) { int A[] = {1,2,3,3,4,5,6,7}; int B[] = {3,3,4,4,5,8}; ArrayList\u0026lt;Integer\u0026gt; ans = intersectionOfArrays(A,B); for( int i = 0; i \u0026lt;ans.size(); i++) { System.out.print(ans.get(i)+\u0026#34; \u0026#34;); } } } 7. Rotate an Array final formula = arr[(i + k) % n ] = arr [ i ]\nclass Solution { public void rotate(int[] nums, int k) { // Step 1: Create a temporary array int[] temp = new int[nums.length]; // Step 2: Place rotated elements into the temporary array for (int i = 0; i \u0026lt; nums.length; i++) { temp[(i + k) % nums.length] = nums[i]; } // Step 3: Copy temp array back into the original nums array for (int i = 0; i \u0026lt; nums.length; i++) { nums[i] = temp[i]; } } } ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/array-questions/","title":"DSA Array Questions"},{"content":"why we need arrays\narray is collection of datatypes Arrays are a type of static data structure because their size is predefined and unchangeable. Array indices start from 0. Arrays ==store elements of the same data type==, e.g., all integers, all strings, etc. Advantages in Java:\nSimple to use for storing fixed-size collections of data. Provides a direct way to manage memory. syntax datatype[] variable_name = ==new== datatype[size];\nhere ==new== is a keyword used to create an object\ned : int[] numbers = new int[5];\nint[] rnos = new int[5]; or int[] rnos2 = {12,23,21,34,43};\nhere new is a keyword used to create an object\nIn java their is no concept of pointers\narray objects are in heap\nall objects in java is stored in heap\nheap object are not continous (memory are one by one allocated)\narray objects in java may not be continuous (it depends on jvm)\npassing through function strings are immutable and arrays are mutable in java (here mutable means we can change object)\nMultidimensional array multidimensional arrays are array of arrays\narr[] \u0026mdash;\u0026ndash;\u0026gt; [4,5,6]\nindividual size of an array can vary as well , bcoz each array itself is a different object\ninput of multidimensional array\ninput and output of multidimensional array\nimport java.util.Scanner; public class MultiDimensionalArray { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // Input dimensions of the array System.out.print(\u0026#34;Enter number of rows: \u0026#34;); int rows = scanner.nextInt(); System.out.print(\u0026#34;Enter number of columns: \u0026#34;); int cols = scanner.nextInt(); // Declare a 2D array int[][] array = new int[rows][cols]; // Input elements into the array System.out.println(\u0026#34;Enter the elements of the array:\u0026#34;); for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; cols; j++) { System.out.print(\u0026#34;Element [\u0026#34; + i + \u0026#34;][\u0026#34; + j + \u0026#34;]: \u0026#34;); array[i][j] = scanner.nextInt(); } } // Output the 2D array System.out.println(\u0026#34;\\nThe entered 2D array is:\u0026#34;); for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; cols; j++) { System.out.print(array[i][j] + \u0026#34; \u0026#34;); } System.out.println(); // Move to the next line for each row } scanner.close(); } } Array list when we don\u0026rsquo;t know how much size of the array we want\n// syntax\nArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); An ArrayList in Java is a part of the java.util package and provides a resizable array implementation. Unlike arrays, the size of an ArrayList can grow or shrink dynamically.\nAutomatically resizes when elements are added or removed. No need to define a fixed size at initialization. internal working of arraylist\nQ1 swap 2 index in an array\nQ2. find max value of array\nQ3. reverse of array\nnull\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/arrays/","title":"DSA Arrays"},{"content":" [!NOTE] we use binary search in sorted arrays. if we get problem statement with sorted array try binary search first.\nQ.1 ceiling of a given number ceiling of no is smallest ele in arr greater ot == target arr = [2,3,4,5,9,14,16,18], target = 14 if target = 14 then ceiling = 14 ceiling(arr,target=15) = 16\nQ.2 Floor of a number Code Q.3 Find Smallest letter greater than target [ leetcode : 744 ] Exact same approach for cieling of the number ignore the target = what are looking for. wrapping of later eg: arr = [\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026lsquo;f\u0026rsquo;,\u0026lsquo;j\u0026rsquo;] , target = \u0026lsquo;j\u0026rsquo; output = c we will use modulo (%) condition violeted : start = end + 1 ==\u0026gt; length of array = N 4. Find First and Last Position of Element in Sorted Array Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]\nExample 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]\nExample 3: Input: nums = [], target = 0 Output: [-1,-1]\n5. Find position of an element in a sorted array of infiniate numbers. (amazon interview question) try not to use array.length in infinite array\nhttps://youtu.be/W9QJ8HaRvJQ?list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ\u0026t=6656\ntraverse through chunks Doubling the size of chuck\n6. leetcode 852 peak index in a mountain Array also known as biotonic arrray = {1,2,3,4,3,2,1}\nfind peak in mountain array try to solve this question with linear search\nbut here i am using binary search to solve this it is the sorted array it is sorted in 3 halfs (first asending 2nd decenting)\n7. leetcode 1095 find in mountain array Search in mountain code for this will try later\n8. Search in a Rotated Sorted Array (LeetCode 33) distinct value (no dublicates)\n2 approaches\ncase 1: remember pivot is the largest number\nfind pivot search in first half (simple binary search) [o,pivot] otherwise, search in second half [pivot + 1, end ] case 2: if mid ele \u0026lt; (mid - 1) ele , so my ans is (mid - 1)\ncase 3: start ele \u0026gt; mid - element\ncase 4 Code : (duplicate value rotation code is also included) Q.9 rotation count ans = pivot +1\ncode : https://github.com/kunal-kushwaha/DSA-Bootcamp-Java/blob/main/lectures/10-binary%20search/code/src/com/kunal/RotationCount.java\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/binary-search-algo-questions/","title":"DSA Binary Search Algo Questions"},{"content":"https://youtu.be/f6UU7V3szVw?si=26WxPdb9UAUEqpAx\nUsed for sorted arrays in ascending or descending order It works by repeatedly dividing the search interval in half and comparing the target with the middle element. Algo find the middle element target ele \u0026gt; mid ele =\u0026gt; search in right else search in left if mid ele == target ele =\u0026gt; ans Loops used in binary search while if else if else\nTime Complexity: Best Case: O(1) (target found at the middle). Worst Case: O(log⁡n) (array size halved each step). Space Complexity: O(1) (iterative approach, no extra memory used). while coding code for binary search [[hinglish explaination of code]] Order agnostic binary search ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/binary-search-algorithm/","title":"DSA Binary search Algorithm"},{"content":"Searching in matrices (2d arrays)\nwe use nested for loop\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/binary-search-in-2d-arrays/","title":"DSA Binary search in 2d arrays"},{"content":"each element is stored right after the previous element\nThe image below shows how an array of integers myArray = [3,5,13,2] is stored in memory. We use a simple kind of memory here with two bytes for each integer, like in the previous example, just to get the idea. image below shows how elements are shifted when an array element is removed. ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/contiguous-memory-locations/","title":"DSA contiguous memory locations"},{"content":"linked list not continous mem alloc tray to break boxes into seperate boxes (array reference)\nfor every block we put it in random mem\nthey are connected with arrows pointer\npointer is reference variable\nhow linked list works internally\nnode\nsingle linked list eveery item knows about other item\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/dump/","title":"DSA dump"},{"content":" File Input: File se data read karna. File Output: File mein data write karna. File handling ke liye java.io aur java.nio packages use hote hain. Important Classes for File I/O File: File ya directory ka representation. FileReader: Characters read karne ke liye. BufferedReader: Efficient character reading ke liye (large data). FileWriter: Characters write karne ke liye. BufferedWriter: Efficient writing ke liye. PrintWriter: Text data write karne ke liye, with better formatting. FileInputStream/FileOutputStream: Bytes read/write karne ke liye. create a file Write in a file Read a file Delete a file ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/file-io-operations/","title":"DSA File io operations"},{"content":" Feature HashMap TreeMap Implementation Uses a hash table internally. Uses a red-black tree internally. Ordering No specific order, elements are stored randomly. Sorted order (natural or custom comparator). Duplicates Allows only one null key and multiple null values. Allows only one null key (null values are allowed). Performance Faster for most operations (O(1) average for get(), put(), remove()). Slower (O(log n)) for get(), put(), remove() due to tree traversal. Use Case When order of elements is not important, and you need fast access. When you need elements to be sorted (ascending or custom order). Iteration Order No guaranteed order during iteration. Iterates in sorted order. Memory Usage Less memory overhead due to hash table. More memory due to the tree structure. Methods Doesn\u0026rsquo;t provide methods for range queries. Provides methods like subMap(), headMap(), tailMap() for range queries. HashMap: No order guaranteed. Faster (O(1) average for get(), put(), remove()). Allows one null key and multiple null values. TreeMap: Always sorted (ascending or custom order). Slower (O(log n) for get(), put(), remove()). Allows one null key but only non-null values. When to Use Which? Use HashMap when you don’t care about the order of elements, and you want fast access to values by keys. Use TreeMap when you need elements sorted in ascending order (or custom order using a comparator), and you are okay with slightly slower performance. ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/hashmap-vs-treemap/","title":"DSA Hashmap vs Treemap"},{"content":" Feature HashSet TreeSet Implementation Internally uses a hash table. Internally uses a red-black tree. Ordering No order; elements are stored randomly. Maintains ascending order of elements. Duplicates Does not allow duplicate elements. Does not allow duplicate elements. Performance Faster for basic operations like add(), remove(), and contains() (O(1) on average). Slower for basic operations (O(log n)) due to tree traversal. Null Elements Allows one null element. Allows one null element (but in case of a comparator, it might throw exception). Use Case When you need fast lookup and no specific order. When you need elements in sorted order. Iteration Order Iteration order is not predictable. Iterates in natural order (ascending). Methods Doesn\u0026rsquo;t have methods to handle sorting. Provides methods for range queries, like headSet(), tailSet(). Memory Usage Less memory overhead as it uses a hash table. More memory overhead due to the tree structure. HashSet:\nNo order of elements. Faster for most operations. Allows null element. TreeSet:\nMaintains elements in ascending order. Slightly slower due to sorting. No null if a custom comparator is used. leetcode samajhdaar wala approach mandabuddhi wala approach ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/hashset-vs-treeset/","title":"DSA Hashset vs Treeset"},{"content":"mandabuddhi approach Samajhdar Approach ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/leetcode/","title":"DSA Leetcode"},{"content":"https://youtu.be/_HRA37X8N_Q?list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ\nA simple algorithm that checks each element in the array until the target element is found or the end of the array is reached.\nstart searching from the first element till the element which we are finding\nwe use for loop in linear searching\ntime complexity :\nBest Case: O(1) // constant Worst Case: O(n) // here n is the size of the array linear time complexity (above image)\nbest case time complexity (above image)\nO(n) (upper bound time complexity) means it will never go worst then linear, it is always better than linear\nspace complexity means are you taking extra space (extra space taken)\npublic class Search { // Class name should start with an uppercase letter for convention public static void main(String[] args) { // Define an array of integers to search from int[] nums = {1, 2, 3, 4, 2, 1, 3, 5, 6}; // The target value we want to find in the array int target = 5; // Call the linearSearch method to search for the target in the array int ans = linearSearch(nums, target); // Print the result: If found, it will print the index; otherwise, -1 System.out.println(ans); } /** * Perform a linear search in the array. * @param arr The array to search in * @param target The value to search for * @return The index of the target if found, otherwise -1 */ static int linearSearch(int[] arr, int target) { // If the array is empty, return -1 as there is nothing to search if (arr.length == 0) { return -1; } // Iterate through each element in the array for (int index = 0; index \u0026lt; arr.length; index++) { // Get the current element at the index int element = arr[index]; // Check if the current element matches the target if (element == target) { return index; // Return the index of the target if found } } // If the loop completes and the target is not found, return -1 return -1; } } Q. Is a char present in the string Q. Search in Range Q. find minimum element in the ARRAY Q. Searching in 2d arrays Q. Search and print maximum value in 2D array https://youtu.be/vwa9vgYz5ZE?t=35\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/linear-search-algorithm/","title":"DSA Linear Search Algorithm"},{"content":"single linked list every item knows about other item head is reference variable which points to next node , and tail is last one\nlast element is connected to null\nCode ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/single-linked-list/","title":"DSA Single linked list"},{"content":"[[String revision in HINGLISH]] any thing which start with capital letter is a class String pool : separate memory structure inside a heap make a program more optimise\nStrings are immutable we cannot change it we cannot change object\ncomparison of string Create diff objects of Same value pretty printing in java output: 453.16f\n\u0026lsquo;%\u0026rsquo; is called placeholder\nSystem.out.printf(\u0026#34;pie: %.3f\u0026#34;, Math.PI); output: 3.142\nHere’s a tabular representation of the commonly used format specifiers in Java. These are used with methods like System.out.printf() or String.format() for formatted output:\nSpecifier Description Example Output %d Integer (decimal) System.out.printf(\u0026quot;%d\u0026quot;, 42); 42 %f Floating-point number System.out.printf(\u0026quot;%.2f\u0026quot;, 3.14); 3.14 %e Scientific notation (lowercase) System.out.printf(\u0026quot;%e\u0026quot;, 12345.678); 1.234568e+04 %E Scientific notation (uppercase) System.out.printf(\u0026quot;%E\u0026quot;, 12345.678); 1.234568E+04 %c Character System.out.printf(\u0026quot;%c\u0026quot;, 'A'); A %s String System.out.printf(\u0026quot;%s\u0026quot;, \u0026quot;Java\u0026quot;); Java %b Boolean System.out.printf(\u0026quot;%b\u0026quot;, true); true %% Literal % symbol System.out.printf(\u0026quot;%%\u0026quot;); % %o Octal integer System.out.printf(\u0026quot;%o\u0026quot;, 10); 12 (octal) %x Hexadecimal integer (lowercase) System.out.printf(\u0026quot;%x\u0026quot;, 255); ff (hex) %X Hexadecimal integer (uppercase) System.out.printf(\u0026quot;%X\u0026quot;, 255); FF (hex) %t Date/Time specifier (see below) %n Newline character System.out.printf(\u0026quot;Hello%nWorld\u0026quot;); Multi-line Additional Date/Time Specifiers (with %t) Specifier Description Example Output %tH Hour (24-hour format) System.out.printf(\u0026quot;%tH\u0026quot;, new Date()); 14 (e.g., 2 PM) %tI Hour (12-hour format) System.out.printf(\u0026quot;%tI\u0026quot;, new Date()); 02 %tM Minute System.out.printf(\u0026quot;%tM\u0026quot;, new Date()); 30 %tS Second System.out.printf(\u0026quot;%tS\u0026quot;, new Date()); 45 %tp AM/PM marker (lowercase) System.out.printf(\u0026quot;%tp\u0026quot;, new Date()); pm %tB Full month name System.out.printf(\u0026quot;%tB\u0026quot;, new Date()); December %tb Abbreviated month name System.out.printf(\u0026quot;%tb\u0026quot;, new Date()); Dec %tA Full day name System.out.printf(\u0026quot;%tA\u0026quot;, new Date()); Friday %ta Abbreviated day name System.out.printf(\u0026quot;%ta\u0026quot;, new Date()); Fri %tY Year (4-digit) System.out.printf(\u0026quot;%tY\u0026quot;, new Date()); 2024 %ty Year (last 2 digits) System.out.printf(\u0026quot;%ty\u0026quot;, new Date()); 24 Formatting Options You can combine format specifiers with flags for more control:\nFlag Description Example Output - Left-align System.out.printf(\u0026quot;%-10d\u0026quot;, 123); 123 + Print sign for numbers System.out.printf(\u0026quot;%+d\u0026quot;, 123); +123 0 Pad with zeroes System.out.printf(\u0026quot;%05d\u0026quot;, 123); 00123 , Use grouping separator System.out.printf(\u0026quot;%,d\u0026quot;, 1234567); 1,234,567 . Precision for floating-point System.out.printf(\u0026quot;%.2f\u0026quot;, 3.14159); 3.14 Example Program import java.util.Date; public class FormatSpecifierDemo { public static void main(String[] args) { System.out.printf(\u0026#34;Integer: %d%n\u0026#34;, 42); System.out.printf(\u0026#34;Float: %.2f%n\u0026#34;, 3.14159); System.out.printf(\u0026#34;Character: %c%n\u0026#34;, \u0026#39;A\u0026#39;); System.out.printf(\u0026#34;String: %s%n\u0026#34;, \u0026#34;Hello\u0026#34;); System.out.printf(\u0026#34;Hexadecimal: %x%n\u0026#34;, 255); System.out.printf(\u0026#34;Current Time: %tT%n\u0026#34;, new Date()); } } operators String builder (only one obj is made and the changes is done in that obj only)\\ we can\u0026rsquo;t name class as StringBuilder as it is already a class Reverse a string use string builder reverse (\u0026ldquo;builder.reverse\u0026rdquo;)\nString Methods Palindrome of a string algorithm:\nif str == null || str.length() == 0 return true i = 0; i = \u0026lt;= str.length()/2 ; i++ ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/strings-and-stringbuilder-in-java/","title":"DSA Strings and StringBuilder in java"},{"content":"old switch case formate\nEnhanced switch Nested switch case\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/dsa/switch-cases-and-statements-in-java/","title":"DSA Switch Cases and Statements in java"},{"content":"HTML ==(HyperText Markup Language)== is the standard language used to create web pages. It structures the content on the web, such as headings, paragraphs, images, links, and more.\\\nBasic HTML Syntax \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;My First Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first HTML page.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Key Components:\n\u0026lt;!DOCTYPE html\u0026gt;: Declares the document type. \u0026lt;html\u0026gt;: The root of the HTML document. \u0026lt;head\u0026gt;: Contains metadata like the title of the page. \u0026lt;body\u0026gt;: Contains all the visible content of the page. The anchor element Image element \u0026lt;img src = \u0026#34;url\u0026#34; /\u0026gt; List of majority tags used in html website Here’s a table with HTML tags and their explanations for easy reference:\nTag Description \u0026lt;!DOCTYPE html\u0026gt; Declares the document type (HTML5). \u0026lt;html\u0026gt; Root element of the HTML document. \u0026lt;head\u0026gt; Contains metadata, styles, and scripts. \u0026lt;title\u0026gt; Sets the title of the page (visible in the browser tab). \u0026lt;meta\u0026gt; Defines metadata like character encoding, description, and keywords. \u0026lt;link\u0026gt; Links external resources like stylesheets. \u0026lt;style\u0026gt; Embeds CSS styles directly in the document. \u0026lt;script\u0026gt; Embeds or links JavaScript. \u0026lt;body\u0026gt; Contains the visible content of the page. \u0026lt;h1\u0026gt; - \u0026lt;h6\u0026gt; Headings from largest (\u0026lt;h1\u0026gt;) to smallest (\u0026lt;h6\u0026gt;). \u0026lt;p\u0026gt; Defines a paragraph. \u0026lt;br\u0026gt; Inserts a line break. \u0026lt;hr\u0026gt; Inserts a horizontal rule (divider line). \u0026lt;strong\u0026gt; Makes text bold with semantic emphasis. \u0026lt;b\u0026gt; Makes text bold without semantic meaning. \u0026lt;em\u0026gt; Makes text italic with semantic emphasis. \u0026lt;i\u0026gt; Makes text italic without semantic meaning. \u0026lt;u\u0026gt; Underlines text. \u0026lt;mark\u0026gt; Highlights text. \u0026lt;small\u0026gt; Reduces font size. \u0026lt;del\u0026gt; Represents deleted (strikethrough) text. \u0026lt;ins\u0026gt; Represents inserted (underlined) text. \u0026lt;sup\u0026gt; Displays text as superscript. \u0026lt;sub\u0026gt; Displays text as subscript. \u0026lt;a\u0026gt; Creates a hyperlink. \u0026lt;img\u0026gt; Embeds an image. \u0026lt;audio\u0026gt; Embeds audio content. \u0026lt;video\u0026gt; Embeds video content. \u0026lt;source\u0026gt; Specifies multiple media sources for \u0026lt;audio\u0026gt; or \u0026lt;video\u0026gt;. \u0026lt;track\u0026gt; Adds subtitles or captions to \u0026lt;video\u0026gt; or \u0026lt;audio\u0026gt;. \u0026lt;ul\u0026gt; Creates an unordered (bulleted) list. \u0026lt;ol\u0026gt; Creates an ordered (numbered) list. \u0026lt;li\u0026gt; Represents a list item. \u0026lt;dl\u0026gt; Creates a definition list. \u0026lt;dt\u0026gt; Represents a term in a definition list. \u0026lt;dd\u0026gt; Represents the description/definition of a term. \u0026lt;table\u0026gt; Creates a table. \u0026lt;tr\u0026gt; Defines a table row. \u0026lt;td\u0026gt; Defines a table cell. \u0026lt;th\u0026gt; Defines a table header cell. \u0026lt;caption\u0026gt; Adds a caption to a table. \u0026lt;col\u0026gt; Specifies column properties in a table. \u0026lt;colgroup\u0026gt; Groups multiple \u0026lt;col\u0026gt; elements. \u0026lt;form\u0026gt; Defines a form for collecting user input. \u0026lt;input\u0026gt; Accepts user input (text, radio, checkbox, etc.). \u0026lt;textarea\u0026gt; Creates a multi-line text input field. \u0026lt;button\u0026gt; Creates a clickable button. \u0026lt;label\u0026gt; Labels a form element for accessibility. \u0026lt;fieldset\u0026gt; Groups related elements in a form. \u0026lt;legend\u0026gt; Provides a title for a \u0026lt;fieldset\u0026gt;. \u0026lt;select\u0026gt; Creates a dropdown menu. \u0026lt;option\u0026gt; Represents an item in a dropdown list. \u0026lt;datalist\u0026gt; Defines a list of predefined options for an input field. \u0026lt;optgroup\u0026gt; Groups related options in a dropdown list. \u0026lt;header\u0026gt; Defines the header of a page or section. \u0026lt;footer\u0026gt; Defines the footer of a page or section. \u0026lt;section\u0026gt; Defines a section of content. \u0026lt;article\u0026gt; Defines independent, self-contained content. \u0026lt;nav\u0026gt; Defines navigation links. \u0026lt;aside\u0026gt; Defines content related to the main content (e.g., a sidebar). \u0026lt;main\u0026gt; Specifies the main content of a document. \u0026lt;div\u0026gt; Creates a block-level container for grouping elements. \u0026lt;span\u0026gt; Creates an inline container for styling or grouping text. \u0026lt;iframe\u0026gt; Embeds another webpage within the current page. \u0026lt;canvas\u0026gt; Used for drawing graphics via JavaScript. \u0026lt;svg\u0026gt; Embeds scalable vector graphics (SVG). \u0026lt;map\u0026gt; \u0026amp; \u0026lt;area\u0026gt; Define clickable regions in an image (image map). \u0026lt;progress\u0026gt; Displays progress of a task (e.g., a loading bar). \u0026lt;meter\u0026gt; Represents a value within a specific range (e.g., temperature, scores). \u0026lt;template\u0026gt; Defines reusable HTML fragments. \u0026lt;details\u0026gt; Creates a collapsible section of content. \u0026lt;summary\u0026gt; Provides a summary for a collapsible \u0026lt;details\u0026gt; element. \u0026lt;noscript\u0026gt; Displays alternative content if JavaScript is disabled. code for html site where we used majority of tags \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;HTML Tags Demo\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;HTML Tags Demonstration\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Learn the major HTML tags with examples and usage\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h2\u0026gt;1. Basic Document Structure\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;The basic structure of an HTML document includes the following tags:\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;example\u0026#34;\u0026gt; \u0026lt;pre\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Document Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- Page Content Goes Here --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;2. Headings\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Headings are used to structure the content. There are six levels from \u0026lt;code\u0026gt;\u0026amp;lt;h1\u0026amp;gt;\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;\u0026amp;lt;h6\u0026amp;gt;\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;example\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Heading 1\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;Heading 2\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;Heading 3\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;Heading 4\u0026lt;/h4\u0026gt; \u0026lt;h5\u0026gt;Heading 5\u0026lt;/h5\u0026gt; \u0026lt;h6\u0026gt;Heading 6\u0026lt;/h6\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;3. Paragraphs and Line Breaks\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;\u0026amp;lt;p\u0026amp;gt;\u0026lt;/code\u0026gt; tag defines a paragraph. Use \u0026lt;code\u0026gt;\u0026amp;lt;br\u0026amp;gt;\u0026lt;/code\u0026gt; for line breaks:\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;example\u0026#34;\u0026gt; \u0026lt;p\u0026gt;This is a paragraph. It has some text to demonstrate how it looks.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;This is another paragraph with a \u0026lt;br\u0026gt; line break in it.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;4. Links\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;\u0026amp;lt;a\u0026amp;gt;\u0026lt;/code\u0026gt; tag creates hyperlinks:\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;example\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://www.google.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;Visit Google\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;5. Images\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;\u0026amp;lt;img\u0026amp;gt;\u0026lt;/code\u0026gt; tag embeds an image:\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;example\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://via.placeholder.com/150\u0026#34; alt=\u0026#34;Placeholder Image\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;6. Lists\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;HTML supports ordered (\u0026lt;code\u0026gt;\u0026amp;lt;ol\u0026amp;gt;\u0026lt;/code\u0026gt;) and unordered (\u0026lt;code\u0026gt;\u0026amp;lt;ul\u0026amp;gt;\u0026lt;/code\u0026gt;) lists:\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;example\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Unordered List\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h3\u0026gt;Ordered List\u0026lt;/h3\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;First Item\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Second Item\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Third Item\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;7. Tables\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;\u0026amp;lt;table\u0026amp;gt;\u0026lt;/code\u0026gt; tag creates a table. Use \u0026lt;code\u0026gt;\u0026amp;lt;tr\u0026amp;gt;\u0026lt;/code\u0026gt; for rows, \u0026lt;code\u0026gt;\u0026amp;lt;td\u0026amp;gt;\u0026lt;/code\u0026gt; for cells, and \u0026lt;code\u0026gt;\u0026amp;lt;th\u0026amp;gt;\u0026lt;/code\u0026gt; for headers:\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;example\u0026#34;\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;City\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;John\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;25\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;New York\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Jane\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;30\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;London\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;8. Forms\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;\u0026amp;lt;form\u0026amp;gt;\u0026lt;/code\u0026gt; tag collects user input:\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;example\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;Name:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34;\u0026gt;Email:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;9. Semantic Tags\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Semantic tags like \u0026lt;code\u0026gt;\u0026amp;lt;header\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;lt;footer\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;lt;article\u0026amp;gt;\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;\u0026amp;lt;section\u0026amp;gt;\u0026lt;/code\u0026gt; make content meaningful:\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;example\u0026#34;\u0026gt; \u0026lt;header\u0026gt;Header Section\u0026lt;/header\u0026gt; \u0026lt;article\u0026gt; \u0026lt;h3\u0026gt;Article Title\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;This is an article.\u0026lt;/p\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;footer\u0026gt;Footer Section\u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;p\u0026gt;HTML Tags Demo Website | Created for Learning\u0026lt;/p\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; code for styles.css body { font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 0; } header { background: #007BFF; color: white; padding: 10px 20px; text-align: center; } section { margin: 20px auto; max-width: 900px; } .example { background: #f4f4f4; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 5px; } .example pre { background: #ddd; padding: 10px; overflow: auto; border-radius: 5px; } footer { background: #333; color: white; text-align: center; padding: 10px 0; position: relative; bottom: 0; width: 100%; } ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/interview/htmlcssjs/1.-html/","title":"HTML,CSS,JS 1  HTML"},{"content":"Cascading Style Sheet code to add external css \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./style.css\u0026#34;/\u0026gt; CSS Selector element selector\nids are unique only one per element\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/interview/htmlcssjs/2.-css/","title":"HTML,CSS,JS 2  CSS"},{"content":"ECMAScript\nalert(\u0026#34;HEllo\u0026#34;) Principles of Writing Consistent, Idiomatic JavaScript : https://github.com/rwaldron/idiomatic.js/\ndatatypes in java script JavaScript has the following data types:\nPrimitive:\nString (\u0026quot;hello\u0026quot;) Number (42) Boolean (true, false) Null (null) Undefined (undefined) Symbol (Symbol(\u0026quot;id\u0026quot;)) BigInt (123n) Non-Primitive:\nObject ({}, arrays, functions, etc.) Primitive vs Non Primitive Primitive:\nImmutable, stored by value.\nExamples: String, Number, Boolean, Null, Undefined, Symbol, BigInt.\nExample:\nlet a = 10; let b = a; // Copies value b = 20; // Does not affect `a` Non-Primitive:\nMutable, stored by reference. Examples: Object, Array, Function. Example: let obj1 = { name: \u0026#34;John\u0026#34; }; let obj2 = obj1; // Shares reference obj2.name = \u0026#34;Doe\u0026#34;; // Changes affect `obj1` Variables prompt keyword\nIn JavaScript, variables are used to store data values. You can declare them using:\nAlways name variables by camel casing\n1. var (Old way): Function-scoped.\nCan be redeclared and updated.\nHoisted but not block-scoped.\nExample:\nvar x = 10; var x = 20; // Redeclaration allowed 2. let (Modern way): Block-scoped.\nCan be updated but not redeclared in the same scope.\nExample:\nlet y = 10; y = 20; // Allowed let y = 30; // Error 3. const (For constants): Block-scoped.\nCannot be updated or redeclared.\nExample:\nconst z = 10; z = 20; // Error Summary: Use let for variables that change. Use const for fixed values. Avoid var unless needed for older code. Rules for variables Here are the basic rules for variables in JavaScript:\nVariable Names:\nMust start with a letter (a-z, A-Z), underscore (_), or dollar sign ($).\nExample: _name, $value, age. Cannot start with a number. Case-Sensitive:\nname and Name are different. No Reserved Keywords:\nAvoid using keywords like let, const, if, etc.\nExample: let let = 5; // ❌ Error Meaningful Names:\nUse descriptive names (e.g., userAge, not x). Avoid Special Characters:\nNo spaces or symbols except _ and $.\nExample: user-name // ❌ Invalid Declaration Before Use:\nAlways declare variables before using them. Strings in Java word.length\nvar name = \u0026#34;yash\u0026#34;; name.length; output = 4\nExercise tweet count: String slicing Exericse 2 : slice the tweet alternative\nvar name = \u0026#34;yash\u0026#34;; name = name.toUpperCase(); name = name.toLowerCase(); 1. How to Create Strings Use single quotes ('), double quotes (\u0026quot;), or template literals (`).\nlet single = \u0026#39;Hello\u0026#39;; let double = \u0026#34;World\u0026#34;; let template = `Hello, ${double}`; // Template literal 2. Common String Methods length: Get string length. let str = \u0026#34;Hello\u0026#34;; console.log(str.length); // 5 toUpperCase() / toLowerCase(): Change case. console.log(str.toUpperCase()); // \u0026#34;HELLO\u0026#34; console.log(str.toLowerCase()); // \u0026#34;hello\u0026#34; includes(): Check if a substring exists. console.log(str.includes(\u0026#34;ell\u0026#34;)); // true slice(start, end): Extract a substring. console.log(str.slice(1, 4)); // \u0026#34;ell\u0026#34; replace(): Replace part of a string. console.log(str.replace(\u0026#34;l\u0026#34;, \u0026#34;z\u0026#34;)); // \u0026#34;Hezlo\u0026#34; 3. Template Literals Use backticks (`) to embed variables and expressions.\nlet name = \u0026#34;John\u0026#34;; console.log(`Hello, ${name}!`); // \u0026#34;Hello, John!\u0026#34; 4. Escape Characters Use \\ to escape special characters.\nlet quote = \u0026#39;I\\\u0026#39;m learning JavaScript!\u0026#39;; console.log(quote); // I\u0026#39;m learning JavaScript! Arithmatic operations in js In JavaScript, arithmetic operations are used to perform mathematical calculations. Here are the basic ones:\n1. Operators Operator Description Example Result + Addition 5 + 3 8 - Subtraction 5 - 3 2 * Multiplication 5 * 3 15 / Division 6 / 3 2 % Modulus (Remainder) 5 % 2 1 ** Exponentiation (Power) 2 ** 3 8 2. Increment \u0026amp; Decrement Increment (++): Increases value by 1.\nlet x = 5; x++; // x is now 6 Decrement (--): Decreases value by 1.\nlet x = 5; x--; // x is now 4 3. Shortcuts for Updating Values Add and assign: x += 3 (same as x = x + 3) Subtract and assign: x -= 3 (same as x = x - 3) Multiply and assign: x *= 3 Divide and assign: x /= 3 Example: let a = 10, b = 3; console.log(a + b); // 13 console.log(a - b); // 7 console.log(a * b); // 30 console.log(a / b); // 3.33 console.log(a % b); // 1 Functions in JavaScript In JavaScript, functions are reusable blocks of code that perform a specific task. Here\u0026rsquo;s a quick overview:\n1. Function Declaration Syntax:\nfunction functionName(parameters) { // code to execute return result; // optional } Example:\nfunction add(a, b) { return a + b; } console.log(add(5, 3)); // 8 2. Function Expression Assign a function to a variable.\nconst multiply = function (x, y) { return x * y; }; console.log(multiply(4, 5)); // 20 3. Arrow Functions (ES6) A concise way to write functions.\nconst subtract = (a, b) =\u0026gt; a - b; console.log(subtract(10, 4)); // 6 4. Default Parameters Set default values for function arguments.\nfunction greet(name = \u0026#34;Guest\u0026#34;) { return `Hello, ${name}!`; } console.log(greet()); // Hello, Guest! console.log(greet(\u0026#34;Alice\u0026#34;)); // Hello, Alice! 5. Anonymous Functions Functions without a name, often used in callbacks.\nsetTimeout(function () { console.log(\u0026#34;Hello after 2 seconds!\u0026#34;); }, 2000); Example: function sayHello(name) { console.log(`Hello, ${name}!`); } sayHello(\u0026#34;John\u0026#34;); // Hello, John! ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/interview/htmlcssjs/3.-javascript/","title":"HTML,CSS,JS 3  Javascript"},{"content":"[[IBM Coding Questions]] 1st Step : ibm coding assessment programming test (coding test for 2 questions) 2nd step: technical | HR Interview:\nrefer: https://www.geeksforgeeks.org/ibm-interview-experience-for-software-developer/\ntest question is on hacker Rank\n3rd step: Top Coding Questions and Answers 2024 While preparing for the IBM coding assessment round, candidates should familiarize themselves with these common topics. These include:\nData Structures\nArrays Linked lists Stacks Queues Trees Graphs Algorithms\nSorting Searching Dynamic programming Backtracking Mathematical Problems\nBasic arithmetic Number theory Combinatorics String Manipulation\nString parsing Substring search Regular expressions ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/interview/ibm/","title":"interview Ibm"},{"content":"1. program to find the HCF/GCD of 2 numbers without using recursion. import java.util.Scanner; public class Solution { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(\u0026#34;\u0026#34;); int a = scanner.nextInt(); System.out.print(\u0026#34;\u0026#34;); int b = scanner.nextInt(); while (a != b) { if(a==0) { System.out.print(b); break; } if(b == 0) { System.out.println(a); } if ( a \u0026gt; b ) { a = a - b; } else { b = b - a; } } System.out.printla(a); scanner.close(); } } 2. Write a program to find the factorial of a number. Factorial of a number nnn is the product of all positive integers less than or equal to nnn. It is denoted as n!n!n!. For example:\n5!=5×4×3×2×1=1205! = 5 \\times 4 \\times 3 \\times 2 \\times 1 = 1205!=5×4×3×2×1=120 0!=10! = 10!=1 (By definition) 1. Iterative Method (Without Recursion)\nimport java.util.Scanner; public class FactorialIterative { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // Input number System.out.print(\u0026#34;Enter a number: \u0026#34;); int num = scanner.nextInt(); // Calculate factorial long factorial = 1; for (int i = 1; i \u0026lt;= num; i++) { factorial *= i; // Multiply each number } // Display result System.out.println(\u0026#34;The factorial of \u0026#34; + num + \u0026#34; is: \u0026#34; + factorial); scanner.close(); } } 2. Recursive Method: Recursion ka use tab hota hai jab ek function apne aapko call karta hai.\nimport java.util.Scanner; public class FactorialRecursive { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // Input number System.out.print(\u0026#34;Enter a number: \u0026#34;); int num = scanner.nextInt(); // Calculate factorial using recursion long factorial = findFactorial(num); // Display result System.out.println(\u0026#34;The factorial of \u0026#34; + num + \u0026#34; is: \u0026#34; + factorial); scanner.close(); } // Recursive function to calculate factorial public static long findFactorial(int n) { if (n == 0 || n == 1) { return 1; // Base case } return n * findFactorial(n - 1); // Recursive case } } 3. Given a string of characters followed by their frequency, compress it into a proper format. Input: a3b5c2a2 Output: abc\nLogic Traverse the input string character by character. If the current character is a letter: Store it as the current character. If the current character is a digit: Extract the frequency of the previous character. Append the character to the result string once (ignoring its frequency for compression). Continue this process until the entire input string is traversed. Example Walk-through Input: a3b5c2a2 Read a, frequency = 3 → Add a once to the result (a). Read b, frequency = 5 → Add b once to the result (ab). Read c, frequency = 2 → Add c once to the result (abc). Read a, frequency = 2 → Add a once again (abca). Final output: abc.\nimport java.util.Scanner; public class StringCompression { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // Input string System.out.print(\u0026#34;Enter the string: \u0026#34;); String input = scanner.nextLine(); // Result string StringBuilder result = new StringBuilder(); // Process the input string for (int i = 0; i \u0026lt; input.length(); i++) { char ch = input.charAt(i); // If the character is a letter, add it to the result once if (Character.isLetter(ch)) { result.append(ch); } } // Print the compressed string System.out.println(\u0026#34;Compressed string: \u0026#34; + result.toString()); scanner.close(); } } 4. palindrome of a string ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/interview/ibm-coding-questions/","title":"interview IBM Coding Questions"},{"content":"refer this:\nhttps://drive.google.com/drive/u/0/folders/1rSqEniErpnkADlyJYcF9s1a0ao3GkhPM [[java oops in hinglish]] ide vscode jdk (java development kit) java is compiled and interpreted in java 9 java introduced repel i.e jshell\nEnhance for loop ternary operator Switch\n[[java oops in hinglish]] String ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/interview/java-revision-udemy-ajink-wala/","title":"interview Java revision udemy ajink wala"},{"content":"if - then condition public class Main { Public static void main(String[] args) { if (boolean expression T or F) { //body } else { // do this } } }\nElse If loops for loop /* Syntax of for loop for ( initialization; condition; increment /decrement){ //body } */\nWhile Loops /* Syntax: while (condition) { //body } */\nWhen to use which loop use while loop when we don\u0026rsquo;t know how many time loop run and use for loop when we know how many time does loop run\ndo while loop do {\n} while (condition);\ndo while loop executes atleast ones and after that it will check condition\nQ1 Check if the char is at lowercase or uppercase\nQ2. Fibonacci no.\nQ3 count repeated numbers\nQ4. reverse a number\n![alt text](Pastedimage20241117195929.png) ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/2.-conditions-and-loops/","title":"Java Learning 2  Conditions and loops"},{"content":"\nBhai, Big O Notation samajhna ekdum zaruri hai agar tumhe DSA (Data Structures and Algorithms) mein master banna hai. Ye ==algorithm ki performance aur efficiency ko samajhne ka ek standard tareeka hai==. Chal basic aur examples ke saath samajhte hain:\nWhat is Big O Notation? Big O Notation ek ==mathematical concept hai jo algorithm ke time complexity aur space complexity ko analyze karta hai.== Ye batata hai ki input size (n) ke badhne par algorithm ka performance kaise change hoga. Why is Big O Important? Predict Performance: Ye help karta hai kisi algorithm ka behavior predict karne mein jab input size kaafi bada ho. Compare Algorithms: Algorithms ke efficiency compare karne ke liye use hota hai. Optimization: Code ko fast aur memory-efficient banane ke liye. Common Big O Notations Big O Name Example Performance O(1) Constant Time Accessing an array element Best (Fastest) O(log n) Logarithmic Time Binary Search Very Fast O(n) Linear Time Iterating through an array Moderate O(n log n) Log-Linear Time Merge Sort, Quick Sort (Best/Average) Moderate O(n²) Quadratic Time Nested loops (e.g., Bubble Sort) Slow O(2^n) Exponential Time Recursive Fibonacci Very Slow O(n!) Factorial Time Solving Traveling Salesman Worst (Slowest) Time Complexity Examples O(1) - Constant Time\nIndependent of input size. int getFirstElement(int[] arr) { return arr[0]; // Sirf ek step } O(log n) - Logarithmic Time\nInput size half hota jata hai har step par (e.g., Binary Search). int binarySearch(int[] arr, int target) { int low = 0, high = arr.length - 1; while (low \u0026lt;= high) { int mid = low + (high - low) / 2; if (arr[mid] == target) return mid; else if (arr[mid] \u0026lt; target) low = mid + 1; else high = mid - 1; } return -1; } O(n) - Linear Time\nEk loop jo input ke size ke proportional chale. int findMax(int[] arr) { int max = arr[0]; for (int num : arr) { if (num \u0026gt; max) max = num; } return max; } O(n²) - Quadratic Time\nNested loops ke case mein. void printPairs(int[] arr) { for (int i = 0; i \u0026lt; arr.length; i++) { for (int j = i + 1; j \u0026lt; arr.length; j++) { System.out.println(arr[i] + \u0026#34;, \u0026#34; + arr[j]); } } } O(2^n) - Exponential Time\nRecursive solutions jisme choices kaafi hoti hain (e.g., Fibonacci). int fibonacci(int n) { if (n \u0026lt;= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); } Space Complexity Space complexity algorithm ke ==memory usage ko represent karta== hai. Example: Iterative algorithms usually O(1) hoti hain (constant memory). Recursive algorithms stack space use karte hain. Key Points to Remember Focus on Growth Rate: Big O input size ke growth pe zyada focus karta hai, exact runtime par nahi. Dominant Term Consider Karo: Sirf sabse bada term count hota hai. Example: O(n² + n) =\u0026gt; Dominant term O(n²) hoga. Best, Worst, Average Cases: Best case: Algorithm ka sabse fast scenario. Worst case: Sabse slow scenario (important for Big O). Average case: Typical performance. Comparison Example Algorithm Input Size n=10n = 10 Input Size n=100n = 100 O(1) 1 1 O(log n) ~3 ~7 O(n) 10 100 O(n log n) ~30 ~700 O(n²) 100 10,000 O(2^n) 1,024 Too large Bhai, agar kisi specific algorithm ya example pe Big O ko samajhna ho, toh bol. Har complexity ko real-world mein relatable bana ke samjha dunga! 😎\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/big-o-notation/","title":"Java Learning Big O notation"},{"content":"Setting up jenkins using Docker docker pull jenkins/jenkins:lts Create a network for Jenkins if you plan to connect it with other services (e.g., Docker agents or a database):\ndocker network create jenkins Run the Jenkins container with proper configuration:\ndocker run -d \\ --name jenkins \\ --restart=unless-stopped \\ --network jenkins \\ -p 8080:8080 \\ -p 50000:50000 \\ -v jenkins_home:/var/jenkins_home \\ jenkins/jenkins:lts Now Jenkins will fireup on http://localhost:8080\naccess logs of jenkins for password\ndocker logs jenkins copy log password and add to http://localhost:8080\nConfigure jenkins Manage Docker Permissions\nIf Jenkins needs to run Docker commands, you’ll need to bind the Docker socket and grant permissions:\nStop the Jenkins container: docker stop jenkins Relaunch Jenkins with Docker socket binding: docker run -d \\ --name jenkins \\ --restart=unless-stopped \\ --network jenkins \\ -p 8080:8080 \\ -p 50000:50000 \\ -v jenkins_home:/var/jenkins_home \\ -v /var/run/docker.sock:/var/run/docker.sock \\ jenkins/jenkins:lts Inside Jenkins, install the Docker Pipeline plugin to integrate Docker with your pipelines. install plugin called docker pipline to seamlely work docker container inside jenkins\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/devops---cloud/jenkins/jenkins-index/","title":"Jenkins Jenkins Index"},{"content":"\nKubernetes Architecture Video tutorial followed : https://www.youtube.com/watch?v=a-nWPre5QYI\u0026t=1020s\n1. Deploy a K8s cluster on local Machine. Deployed ngnix image inside kubernetes and applied load balancer over it Tools MiniKube install kubectl with this command : curl -LO \u0026#34;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\u0026#34; make it executable and move to path sudo chmod +x kubectl sudo mv kubectl /usr/local/bin Install minikube: curl -LO https://github.com/kubernetes/minikube/releases/latest/download/minikube-linux-amd64 sudo install minikube-linux-amd64 /usr/local/bin/minikube \u0026amp;\u0026amp; rm minikube-linux-amd64 Start MiniKube: run kubectl webserver kubectl create deployment webserver --image=nginx:alpine command to delete pod\nkubectl delete pod webserver expose deployment server\nkubectl expose deployment webserver --type=LoadBalancer --port=80 service/webserver exposed kubectl get services minikube service webserver --url View minikube dashboard minikube dashboard yash@boi:~$ kubectl get service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.96.0.1 \u0026lt;none\u0026gt; 443/TCP 26m webserver LoadBalancer 10.100.82.247 \u0026lt;pending\u0026gt; 80:30934/TCP 15m yash@boi:~$ kubectl get service webserver NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE webserver LoadBalancer 10.100.82.247 \u0026lt;pending\u0026gt; 80:30934/TCP 15m yash@boi:~$ kubectl delete service webserver service \u0026#34;webserver\u0026#34; deleted ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/kubernates/1.-introduction/","title":"Kubernates 1  Introduction"},{"content":"CBIS are those that ==make use of computer technology== to perform some dedicated task\nThe essential elements / components of a CBIS are: 1. Hardware The physical devices and equipment used in the system. Includes: Input devices (e.g., keyboards, scanners). Processing units (e.g., CPUs, GPUs). Output devices (e.g., monitors, printers). Storage devices (e.g., hard drives, SSDs). 2. Software The set of instructions and programs that operate the hardware. Types: System Software: Operating systems and utilities (e.g., Windows, Linux). Application Software: Tools for specific tasks (e.g., CRM software, ERP systems). 3. Database Organized collection of data that can be accessed, managed, and updated. Ensures data integrity, security, and availability. Examples: Relational databases (e.g., MySQL, Oracle). Cloud databases (e.g., Amazon RDS). 4. Communication-Network The infrastructure that enables connectivity and data exchange between system components. Includes: Networking hardware (e.g., routers, switches). Protocols for communication (e.g., TCP/IP, HTTP). Communication media (e.g., fiber optics, Wi-Fi). 5. Business Procedure Standardized methods and workflows that the CBIS supports or automates. Define how tasks are completed and decisions are made using the system. Examples: Order processing procedures. Payroll management systems. 6. People The users and stakeholders involved in the system\u0026rsquo;s operation. Categories: End-users: Employees or customers who interact with the system. IT staff: Developers, administrators, and support personnel. Decision-makers: Managers and executives relying on the system for insights. Summary in Table Form: Component Description Hardware Physical devices like computers, storage, and networking equipment. Software Programs that instruct the hardware to perform tasks. Database ==Central repository of structured data== for efficient access and management. Communication-Network ==Infrastructure for data sharing and connectivity across systems.== Business Procedure ==Workflows and rules governing the use of the CBIS.== People Users, IT staff, and decision-makers interacting with the system. Each of these components plays a critical role in ensuring the effectiveness and efficiency of a CBIS. Together, they create a cohesive system for managing and using information within an organization.\nTypes of Computer based Information System Types of Computer-Based Information Systems (CBIS) can be categorized based on their ==purpose, users, and the types of decisions they support==. Here are the key types:\n1. Transaction Processing Systems (TPS) Purpose: Handle and record routine, day-to-day business transactions. Features: Ensure accuracy and reliability in processing large volumes of data. Act as the foundation for other types of information systems. Examples: Point-of-sale systems in retail. Payroll systems. Order processing systems. 2. Management Information Systems (MIS) Purpose: Provide summarized and structured information to middle managers for decision-making and reporting. Features: ==Transform raw data from TPS into meaningful reports==. ==Focus on operational efficiency and short-term planning==. Examples: Monthly sales reports. Inventory control systems. 3. Decision Support Systems (DSS) Purpose: Help managers and analysts make complex, non-routine decisions by analyzing data and presenting simulations or models. Features: Support \u0026ldquo;what-if\u0026rdquo; analysis and scenario modeling. Often incorporate external data and predictive analytics. Examples: Investment analysis tools. Production scheduling systems. 4. Executive Information Systems (EIS) / Executive Support Systems (ESS) Purpose: ==Provide top executives with easy-to-access, summarized, and graphical data to support strategic decision-making==. Features: Focus on long-tercomplex, non-routine decisions by analyzing data and presenting simulations or models.m planning and external environment analysis. Use dashboards and data visualization. Examples: Market trend analysis systems. Corporate performance dashboards. 5. Enterprise Systems Purpose: Integrate core business processes across departments into a unified system. Features: Ensure seamless information flow between functional areas. Improve operational efficiency and collaboration. Examples: Enterprise Resource Planning (ERP) systems (e.g., SAP, Oracle). Supply Chain Management (SCM) systems. 6. Knowledge Management Systems (KMS) Purpose: Facilitate the capture, organization, and sharing of knowledge within an organization. Features: Help employees access organizational expertise. Promote innovation and collaboration. Examples: Document management systems. Wikis and intranet platforms. 7. Office Automation Systems (OAS) Purpose: Support daily office work and improve communication and productivity. Features: Facilitate document creation, communication, and scheduling. Often used by administrative staff. Examples: Email systems. Word processing and spreadsheet software. 8. Expert Systems (ES) Purpose: Use artificial intelligence to mimic human expertise in specific areas to provide recommendations or solutions. Features: Rely on a knowledge base and inference rules. Handle tasks requiring specialized expertise. Examples: Medical diagnosis systems. Loan approval systems. Summary in Table Form: Type of CBIS Purpose Examples Transaction Processing Systems (TPS) Handle routine business transactions. Payroll, order processing. Management Information Systems (MIS) Summarize data for decision-making. Sales reports, inventory systems. Decision Support Systems (DSS) Aid in complex decision-making. Investment analysis, forecasting tools. Executive Information Systems (EIS) Provide strategic insights for executives. Performance dashboards, market analysis. Enterprise Systems Integrate business processes organization-wide. ERP systems, SCM systems. Knowledge Management Systems (KMS) Capture and share organizational knowledge. Wikis, document management systems. Office Automation Systems (OAS) Streamline office tasks and communication. Email, word processing. Expert Systems (ES) Provide expert-like solutions. Medical diagnosis, fraud detection. These systems collectively support various levels of an organization\u0026rsquo;s operations, decision-making, and strategic planning.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/mis/computer-based-information-system-cbis/","title":"MIS Computer Based Information System (CBIS)"},{"content":"The sigmoid activation function takes real values as input and converts them to numbers between 0 and 1 using the sigmoid formula.\nRELU Leaky ReLU Function: where α alphaα is a small constant (typically 0.01). Description: Allows a small, non-zero gradient when xxx is negative, which helps keep neurons active. Pros: Reduces the risk of dead neurons. Cons: Requires setting an additional parameter (α\\alphaα). ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/deep-learning/module-1/activation-functions/","title":"Module 1 Activation Functions"},{"content":"Syllabus Big data and its characteristics Big Data refers to extremely ==large and complex datasets== that traditional data processing software cannot handle effectively. It ==involves the collection, processing, and analysis of large volumes== of diverse and ==rapidly generated data==. Characteristics of Big Data (The 5 Vs) Big Data is generally defined by five main characteristics, often referred to as the 5 Vs:\nVolume:\nRefers to the ==amount of data generated, which is massive in scale==. Examples include data from social media, online transactions, sensors, and mobile devices. Requires large storage and distributed systems for processing. Velocity:\nDescribes the ==speed== at which data is ==generated, processed, and analyzed== Real-time or near-real-time data processing is crucial for timely decision-making. Examples include social media updates, stock trading, and streaming data. Variety:\nIndicates the different types and ==formats== of data, both ==structured and unstructured.== Examples include text, images, videos, audio, and social media interactions. Requires techniques to handle unstructured data and extract insights from various formats. Veracity:\nRefers to the ==accuracy, quality, and reliability of data==. ==Data can be incomplete, inconsistent, or inaccurate, which impacts analysis.== Handling veracity requires data cleaning and validation techniques to ensure trustworthy insights. Value:\nThe most important V, representing the ==usefulness and insights== that can be derived from Big Data. Turning data into actionable insights or ==added value for businesses==, such as ==improving decision-making== or enhancing customer experiences. Types of Big data Structured Data:\n==Organized in a predefined format==, typically in ==rows and columns== (like relational databases). Easy to store, process, and analyze using traditional tools such as SQL. Examples: ==Financial transactions, inventory data, customer data, and sensor readings.== Unstructured Data:\nHas no ==predefined structure== and doesn’t fit neatly into rows and columns. ==More complex to process and analyze as it requires specialized tools for handling.== Examples: Social media ==posts, videos, images, emails, audio recordings, and web pages.== Semi-Structured Data:\nContains elements of ==both structured and unstructured data.== Has an overall structure but lacks strict formatting (often in tagged formats). Examples: ==JSON and XML files==, emails with metadata, and log files. Types of Big Data Based on Sources Human-Generated Data:\nData generated by humans through interaction with various digital platforms and devices. Examples include social media posts, blog articles, emails, customer feedback, and online transaction records. Machine-Generated Data:\nProduced by ==machines or devices without direct human input==, often through ==sensors or automated processes==. Examples include sensor data from IoT devices, server logs, GPS data, industrial machine logs, and weather sensors. Process-Mediated Data:\nGenerated as a ==byproduct of business processes or activities.== Often comes from enterprise applications like ==ERP, CRM, and financial systems.== Examples ==include supply chain data, sales and transaction records, and purchase histories.== Types of Big Data Based on Analytics and Use Cases Operational Big Data:\n==Generated from daily operations and business activities==, often in real-time. ==Used for process optimization, real-time analytics, and decision-making.== Examples: Log data, transaction records, and website activity. Analytical Big Data:\nData gathered, processed, and analyzed to ==derive insights for strategic decision-making.== Typically ==historical data used for pattern recognition==, ==trend analysis, and forecasting.== Examples: Market analysis data, historical customer behavior, and product development insights Traditional VS Big Data Hadoop Ecosystem Hadoop is an open-source, distributed computing framework designed for processing and storing vast amounts of data across multiple servers\n==Developed by the Apache Software Foundation==, Hadoop allows massive datasets to be processed in parallel on large ==clusters== of ==commodity hardware==, providing fault tolerance, scalability, and flexibility.\nIt’s commonly used for Big Data processing and analytics due to its ability to ==handle structured, semi-structured, and unstructured data.==\nCore Components of Hadoop 1. Hadoop Distributed File System (HDFS) Purpose: ==HDFS is the primary storage system of Hadoop==, designed to store and manage large datasets across distributed machines. Key Features: ==Distributed Storage==: Splits data into large blocks (default 128 MB) and distributes them across multiple nodes in the cluster. ==Fault Tolerance==: Data blocks are ==replicated (typically 3 copies==) across nodes, so if a node fails, the data can still be accessed from another replica. ==High Throughput==: Optimized for fast read and write operations, essential for large-scale batch processing. Architecture: ==NameNode==: The ==master node== that manages the metadata (information about file locations and replicas) of the HDFS. ==DataNode==: The ==worker nodes== that store the actual data blocks and report back to the NameNode. 2. MapReduce Purpose: MapReduce is Hadoop’s processing model, allowing ==parallel processing of large datasets across clusters==. Key Features: ==Parallel Processing==: Distributes tasks across multiple nodes, enabling efficient processing of massive data. ==Fault Tolerance==: If a node fails, Hadoop reassigns the task to another node to complete it. Architecture:\nMap Task: The first step in the process, where data is ==split into key-value pairs and processed in parallel across nodes.== Reduce Task: The second step, where ==intermediate data from Map tasks is consolidated to produce the final output.== 3. YARN (Yet Another Resource Negotiator) Purpose: YARN is the ==resource management layer in Hadoop==, which ==allocates== and ==manages== ==resources (CPU, memory) ==across applications in the cluster. Key Features: ==Resource Allocation==: Efficiently allocates resources based on application demands, supporting various workloads. ==Multi-Tenancy==: Allows multiple applications to run concurrently, improving cluster utilization. Architecture: ==ResourceManager==: The master node that allocates resources to various applications. ==NodeManager==: Runs on each ==DataNode==, monitoring resources and reporting back to the ResourceManager. 4. Hadoop Common Purpose: ==Provides libraries, utilities, and Java-based modules== essential for Hadoop’s core functionality. Key Features: ==Cross-Component Support:== Supplies essential tools, such as Java libraries, to enable communication and data access across different Hadoop components. ==Utilities: Supports Hadoop’s core operations and configuration==. Hadoop Ecosystem The Hadoop ecosystem consists of a variety of tools and technologies that complement the core Hadoop components to provide a more comprehensive data processing and analytics solution.\nData Ingestion and Storage Tools\nApache Scoop: ==Used to transfer data between Hadoop and relational databases (like MySQL, Oracle==). It’s effective for batch data transfer. Apache HBase: ==A NoSQL database that runs on top of HDFS, providing real-time read/write access to large datasets==. Ideal for semi-structured data storage. Data Processing and Computation Tools\nApache Hive: A ==data warehousing tool that enables SQL-like querying== (HiveQL) on Hadoop, making it accessible to users familiar with SQL. Apache Pig: A ==high-level platform for data transformation==, allowing users to write ==scripts== in Pig Latin for data processing. It’s optimized for complex data processing jobs. Apache Spark: A fast, ==general-purpose cluster computing engine== that can handle ==real-time data processing==, in-memory computing, and a wider range of workloads than MapReduce Data Management and Workflow Orchestration\nApache Zookeeper: A centralized service that manages distributed applications by ==maintaining configuration information==, ==naming, and synchronization.== Data Access and Querying Tools\nApache HCatalog: A ==metadata management service== that integrates with Hive and allows for a centralized view of data across different Hadoop tools. ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/big-data-analysis/module-1/big-data-and-hadoop/","title":"Module 1 big data and hadoop"},{"content":" In a feedforward neural network, data moves forward from the input layer through hidden layers to the output layer. Each layer transforms the input data using weights, biases, and activation functions. A Feedforward Neural Network (FNN) is a type of artificial neural network where connections between the nodes do not form cycles. This characteristic differentiates it from recurrent neural networks (RNNs). The network consists of an input layer, one or more hidden layers, and an output layer. Information flows in one direction—from input to output—hence the name \u0026ldquo;feedforward.\u0026rdquo;\nStructure of a Feedforward Neural Network Input Layer: The input layer consists of neurons that receive the input data. Each neuron in the input layer represents a feature of the input data. Hidden Layers: One or more hidden layers are placed between the input and output layers. These layers are responsible for learning the complex patterns in the data. Each neuron in a hidden layer applies a weighted sum of inputs followed by a non-linear activation function. Output Layer: The output layer provides the final output of the network. The number of neurons in this layer corresponds to the number of classes in a classification problem or the number of outputs in a regression problem. ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/deep-learning/module-1/feedforward/","title":"Module 1 feedforward"},{"content":"\nMUlti Layered Feed forward network = [[feedforward]] Learning factor In deep learning, the learning factor, commonly called the ==learning rate==, controls ==how much the model\u0026rsquo;s weights are adjusted in response to the estimated error for each iteration.== It is a crucial ==hyperparameter== that determines the size of steps taken towards minimizing the loss function.\nHigh learning rate: Faster training but risks ==overshooting== the optimal solution, potentially missing out on accuracy. Low learning rate: ==More precise convergence== but ==slower training== and risk of getting ==stuck in local minima==. The factors that improve the convergence of EBPTA (error backprapogation Through Activation ) are called as learning factors\nThe factors are as follows:\nInitial weights Steepness of activation function Learing constant Momentum Network architecture Necessary number of hidden neurons 1. Initial weights:\nThe weights of the network to be trained are typically initialized at small random values. The initialization strongly affects the ultimate solution 2. Steepness of activation function\nThe neuron’s continuous activation function is characterized by its steepness factor Also the derivatice of the activation function serves as a multiplying factor in building components of the error signal vectors. 3. Learing constant:\nThe effectiveness and convergence of the error back propagation learning algorithm depen significantly on the value of the learning constant. 4. Momentum:\nThe purpose of the momentum method is ti ==accelerate the convergence== of the error back propagation learning algorithm. The method involves supplementing the current weight adjustment with a fraction of the most recent weight adjustment. 5. Network architecture:\nOne of the most important attributes if a layerd neural network design is choosing the architecture The number of input nodes is simply determined by the dimension or size of the input vector to be classified. The input vector size usually corresponds to the total number of distinct features of the input patterns. 6. Necessary number of hidden neurons:\nThis problem of choice of size of the hidden layer is under intensive study with no conclusive answers available. One formula can be used to find out how many hidden layer neurons need to be used to achieve classification into M classes in x dimensional patterns space. [[Activation Functions]] Loss Function a loss function ==quantifies the difference between a model\u0026rsquo;s predictions and the actual target values==. It guides the training process by providing a ==feedback signal== that allows the model to ==adjust its weights to minimize error==. Choosing an appropriate loss function is crucial and often depends on the type of problem ==(e.g., regression vs. classification)== and the output layer\u0026rsquo;s activation function.\nOutput Activation:\nBinary Classification: Use a ==sigmoid activation== function in the output layer, which outputs values ==between 0 and 1==, making it suitable for binary cross-entropy. Multi-Class Classification: Use ==softmax activation== in the output layer to produce a probability distribution over classes, suitable for categorical cross-entropy. Choosing the Right Output Function and Loss Function The choice of output layer activation and loss function combination depends on the task type:\nRegression:\nOutput Activation: None (linear output layer). Loss Function: Mean Squared Error (MSE) or Mean Absolute Error (MAE). Binary Classification:\nOutput Activation: Sigmoid function, which outputs probabilities between 0 and 1. Loss Function: Binary Cross-Entropy Loss. Multi-Class Classification:\nOutput Activation: Softmax function, which outputs a probability distribution across multiple classes. Loss Function: Categorical Cross-Entropy Loss. Why Matching the Output Activation and Loss Function Matters The correct pairing ensures that the model outputs match the range and interpretation needed by the loss function. For example, if a sigmoid activation is paired with binary cross-entropy, the loss function expects outputs between 0 and 1, ==which aligns with the sigmoid’s output range==. Similarly, ==softmax aligns well with categorical cross-entropy, as both deal with probabilistic outputs over multiple classes.==\nOptimization techniques In deep learning, optimization techniques are ==crucial for adjusting a model\u0026rsquo;s weights to minimize the loss function==, ==helping the model to learn effectively and generalize well==. These techniques ==focus on optimizing gradient descent==, the core algorithm for training neural networks.\nIn simple words, Optimization algorithms are responsible for reducing losses and provide most accurate results possible. The weight is initialized using some initialization strategies and is updated with each epoch according to the equation. The best results are achieved using some optimization strategies or algorithms called Optimizer.\n1. Gradient Descent ==Iterative algorithm==, ==starts from a random point on the function== and ==traverses down its slope in steps until it reaches lowest point of that function. == This algorithm is ==apt for cases== where ==optimal points cannot be found by equating the slope of the function to 0==. For the function to reach minimum value, the weights should be altered. ==With the help of back propagation, loss is transferred from one layer to another and “weights” parameter are also modified depending on loss so that loss can be minimized==.\nDrawbacks of GD\nAs for Gradient Descent algorithm, the entire data set is loaded at a time. This makes it ==computationally intensive== there are chances the iteration values may get ==stuck at local minima== or saddle point and never converge to minima. To obtain the best solution, ==the must reach global minima.== 2. Stochastic Gradient Descent (SGD) ==Extension of GD== , overcomes disadvantages of GD\nSGD tries to overcome the disadvantage of ==computationally intensive by computing the derivative of one point at a time== Due to this fact, SGD takes more number of iterations compared to GD to reach minimum and also contains some noise when compared to Gradient Descent As SGD computes derivatives of only 1 point at a time, the time taken to complete one epoch is large compared to Gradient Descent algorithm.\n3. Mini Batch — Stochastic Gradient Descent ==MB-SGD is an extension of SGD algorithm==. It overcomes the time-consuming complexity of SGD by taking a batch of points / subset of points from dataset to compute derivative.\n[!NOTE] It is observed that the derivative of loss function of MB-SGD is similar to the loss function of GD after some iterations. But the number iterations to achieve minima in MB-SGD is large compared to GD and is computationally expensive. The update of weights in much noisier because the derivative is not always towards minima.\n4.AdaGrad AdaGrad is an effective algorithm for specific cases with ==sparse data or high-dimensional feature spaces==, but its dim==inishing learning rate can be a drawbac==k for ==general-purpose deep learning tasks.==\nAdaGrad (Adaptive Gradient Algorithm) is an optimization algorithm in deep learning that ==adapts the learning rate for each parameter individually== based on the ==historical gradients for that parameter==\nAdaptive Learning Rate: Unlike standard gradient descent, ==AdaGrad modifies the learning rate for each parameter based on how frequently that parameter has been updated in the past.==\nGradient Accumulation: $G_t​$ is an accumulated sum of squared gradients over all previous steps, meaning parameters with high gradients slow down due to larger denominators, while parameters with lower gradients can speed up\n==Good for Sparse Data:== AdaGrad performs well in situations with sparse features, such as natural language processing, where certain parameters (like rare words) may update infrequently. The adaptive nature of AdaGrad allows these rarely updated parameters to take larger steps.\nLimitations: Learning Rate Decay diminishing learning rate problem Applications: AdaGrad is commonly used in scenarios with sparse data or where certain parameters require significantly different learning rates. However, because of its diminishing learning rate, it is less commonly used in deep networks without modification.\n5. RMSprop (Root Mean Square Propagation) optimization technique designed to address AdaGrad\u0026rsquo;s diminishing learning rate problem, especially useful in deep learning tasks like training recurrent neural networks.\nRMSprop uses an exponentially decaying average of past squared gradients to adjust the learning rate, preventing it from decaying too fast.\nformula $$ E[g2]t​=γE[g2]t−1​+(1−γ)⋅gt2​ θt+1=θt−ηE[g2]t+ϵ⋅gt\\theta_{t+1} = \\theta_t - \\frac{\\eta}{\\sqrt{E[g^2]_t + \\epsilon}} \\cdot g_tθt+1​=θt​−E[g2]t​+ϵ $$\nwhere:\nE[g2]tE[g^2]_tE[g2]t​ is the exponentially decaying average of past squared gradients, gtg_tgt​ is the gradient at step ttt, γ\\gammaγ (decay rate) is typically set around 0.9, η\\etaη is the learning rate, ϵ\\epsilonϵ is a small constant for numerical stability. The exponential decay keeps the learning rate from becoming too small over time, making RMSprop ==suitable for non-stationary objectives==\nApplications: RMSprop is widely used for tasks like training recurrent neural networks (RNNs) and other deep models that benefit from adaptive learning rates.\nAdam (Adaptive Moment Estimation) Adam combines the ideas of both momentum and RMSprop, making it one of the most popular and effective optimization algorithms in deep learning.\nAdam maintains two moving averages: one for the gradient ==(momentum)== and one for the squared gradient ==(adaptive learning rate).==\n==Bias Correction:== The bias correction ensures stable updates, especially in the early training stages when the moment estimates may be biased toward zero.\n==Combines RMSprop and Momentum==: Adam combines the per-parameter adaptive learning rate from RMSprop and the momentum concept, ==making it very effective for complex, noisy, and sparse data.==\nApplications: Adam is widely used across various deep learning tasks, including ==CNNs, RNNs==, and large networks. Its robustness and ease of tuning make it a go-to optimizer.\noverfitting: Overfitting in deep learning (and machine learning) occurs when a ==model learns the training data too well, capturing noise and random fluctuations==rather than the underlying pattern. This results in excellent performance on the training data but ==poor generalization to new, unseen data==, as the model has essentially \u0026ldquo;memorized\u0026rdquo; the training examples rather than learning general rules.\nSymptoms:\nHigh accuracy on training data but low accuracy on validation/test data. Increasing gap between training and validation error over epochs. Causes:\nComplex Model: Using a model that has too many parameters relative to the amount of training data (e.g., very deep networks on small datasets). Insufficient Data: A small or non-representative training dataset can lead to a model that only works well on specific examples. Too Many Training Epochs: Training for too long can cause the model to start fitting to noise in the data rather than general patterns. Solutions to Overfitting: ==Regularization==: Techniques like L1/L2 regularization (penalizing large weights), Dropout (randomly turning off neurons during training), or ==Batch Normalization.== Data Augmentation: Expanding the dataset by applying transformations like rotation, scaling, or flipping to make the model more robust. ==Early Stopping:== Monitoring the validation loss and stopping training when it begins to increase. Cross-Validation: Using cross-validation to check if the model’s performance generalizes well across different subsets of the data. Simplifying the Model: Reducing the number of layers or neurons to prevent the model from fitting every detail of the training data. Bias Bias is the ==error introduced by approximating== a real-world problem (which may be complex) with a simplified model. In essence, it represents the assumptions made by a model to learn the target function.\nHigh Bias: A model with high bias ==makes strong assumptions about the data==, usually leading to ==underfitting==. It may oversimplify the data structure, failing to capture important patterns.\nA low-bias model is ==flexible== and ==can fit the data closely==, with fewer simplifying assumptions.\nCharacteristics of High-Bias Models:\nPoor fit to the training data and test data (==underfitting==). ==Large error== in both the ==training and test sets==. ==High training error==. Variance Variance is the ==model’s sensitivity to small fluctuations== in the training data. High-variance models ==capture a lot of noise from the training data==, which makes them more ==complex and prone to overfitting==.\nHigh Variance: A model with high variance is overly complex, capturing noise as if it were a signal, leading to overfitting. This means the model performs well on the training data but poorly on new, unseen data. Low Variance: Low-variance models are less sensitive to fluctuations in the training data and are generally simpler.\nCharacteristics of High-Variance Models:\nGood fit to the training data but poor fit to the test data (overfitting). High variance in model predictions across different datasets or samples. High test error. The Bias-Variance Tradeoff The bias-variance tradeoff is about finding a balance between bias and variance to minimize the total error, allowing a model to generalize well to new data.\nBias Squared $(\\text{Bias}^2):$\nRepresents errors due to incorrect assumptions in the model (e.g., assuming linearity when the relationship is nonlinear). High bias leads to underfitting, which increases training and test errors. Variance:\nRepresents errors due to the model’s sensitivity to small changes in the training set. High variance leads to overfitting, where the model captures noise as if it were an actual pattern, reducing generalizability. Irreducible Error:\nRepresents noise inherent in the data that no model can capture, such as random error from measurement or unmodeled influences. This error is inherent to the problem and cannot be reduced by the model. Visual Representation of Bias-Variance Tradeoff High Bias: Error from bias is high, but error from variance is low. Total error is high due to underfitting. High Variance: Error from variance is high, but error from bias is low. Total error is high due to overfitting. Optimal Point: The sweet spot is where both bias and variance are balanced, resulting in the lowest possible error. Regularization in DL Regularization in deep learning refers to techniques that prevent a model from overfitting by adding a penalty to the loss function. This penalty discourages the model from learning overly complex patterns that may capture noise instead of meaningful structures in the data. The two most common forms of regularization in deep learning are L1 and L2 regularization.\nWhy Use Regularization? Regularization helps improve the generalization of a model by:\nControlling the complexity of the model. Preventing it from assigning excessive importance to any single feature. Encouraging the model to rely on simpler patterns, which are more likely to generalize well. L1 and L2 Regularization 1. L2 Regularization (Ridge Regularization) Definition: L2 regularization adds a penalty term that is proportional to the sum of the squared values of the weights.\nFormula: In L2 regularization, the regularized loss function is:\nwhere:\nLLL is the original loss function (e.g., mean squared error or cross-entropy), λ\\lambdaλ is the regularization parameter (also called the penalty term), which controls the strength of the regularization, wiw_iwi​ represents each individual weight in the model. Effect on Weights:\nThe L2 term encourages weights to become smaller but does not drive them exactly to zero. By penalizing large weights, L2 regularization leads to models that are more distributed across multiple features rather than focusing heavily on any one feature. Gradient Update with L2:\nDuring training, L2 regularization adjusts the weight update as: wi=wi−η⋅(∂L∂wi+λ⋅wi)w_i = w_i - \\eta \\cdot \\left( \\frac{\\partial L}{\\partial w_i} + \\lambda \\cdot w_i \\right)wi​=wi​−η⋅(∂wi​∂L​+λ⋅wi​) where η\\etaη is the learning rate. This causes a \u0026ldquo;shrinkage\u0026rdquo; effect, where weights are scaled down in addition to the regular gradient update. Use Cases: L2 regularization is commonly used in regression problems and deep learning models where we want to avoid overly large weights but still retain small contributions from multiple features.\n2. L1 Regularization (Lasso Regularization) Definition: L1 regularization adds a penalty that is proportional to the sum of the absolute values of the weights.\nFormula: In L1 regularization, the regularized loss function LregL_{\\text{reg}}Lreg​ is:\nwhere:\nLLL is the original loss function, λ\\lambdaλ is the regularization parameter, ∣wi∣|w_i|∣wi​∣ denotes the absolute value of each weight. Effect on Weights:\nL1 regularization promotes sparsity, meaning it encourages some weights to become exactly zero. This effectively removes certain features from the model, making it simpler and focusing only on the most significant features. This can lead to sparse models that are easier to interpret, as irrelevant features are \u0026ldquo;zeroed out.\u0026rdquo; Use Cases: L1 regularization is used when feature selection is desired, such as in sparse data scenarios where some features are irrelevant. It is often applied in fields like natural language processing and computer vision.\nChoosing Between L1 and L2 Regularization L2 Regularization:\nUseful when you want all features to contribute a bit and don’t necessarily want to remove any entirely. Effective for situations where features are dense, and feature selection is not required. L1 Regularization:\nPreferable if you suspect only a few features are important and you want the model to ignore irrelevant features. Helps create sparse models, especially useful in high-dimensional data where certain features are redundant. Parameter sharing Parameter sharing in deep learning refers to the ==practice of reusing the same set of parameters (weights) across multiple parts of a model==, rather than having separate parameters for each connection or node. This approach is especially ==beneficial for reducing the number of parameters in the model==, saving memory, improving computational efficiency, and ==enhancing generalization==.\nmost commonly used in CNN ( convolutional Neural Networks ) and RNN ( Recurrent Neural Network )\nAdvantages Reduces the number of parameter improve generalization Enable translation and time Invarience Dropout in Deeplearning Dropout is a ==regularization technique== used in deep learning to ==prevent overfitting==, particularly in large neural networks. It involves ==randomly== \u0026ldquo;dropping out\u0026rdquo; (i.e., ==setting to zero==) a subset of neurons during training. ==This means that each neuron has a fixed probability of being temporarily ignored, or deactivated, on each training iteration.==\nRandomly Deactivating Neurons\nFor example, with a ==dropout rate of 0.5==, approximately 50% of the neurons are dropped out in each training iteration. Effect on Forward Pass and Backward Pass During the forward pass, the deactivated neurons do not contribute to the output. In the backward pass, no gradient is computed for these deactivated neurons, effectively treating them as if they don’t exist for that iteration. Why Dropout Helps Prevent Overfitting Creates Redundant Representations:\nDropout forces the network to avoid relying too heavily on any single neuron or subset of neurons. This ==encourages the network to learn more distributed and redundant representations of features==, making it more ==robust== to small variations in input. Prevents Co-adaptation of Neurons:\nWhen neurons are \u0026ldquo;dropped out\u0026rdquo; randomly, they cannot co-adapt (i.e., form dependencies on each other’s outputs) because they might not be active together in any given forward pass. This prevents the network from \u0026ldquo;==memorizing==\u0026rdquo; the training data and helps it ==generalize better to unseen data==. Acts as an Ensemble of Networks:\nDropout can be thought of as training a collection of different \u0026ldquo;sub-networks\u0026rdquo; within the original network. Each sub-network is trained on a different random selection of active neurons, so the final network during inference represents an average of multiple smaller networks, which enhances generalization. Choosing the Dropout Rate Common ==dropout rates range from 0.2 to 0.5==, but the optimal rate depends on the architecture and dataset. ==- Lower dropout rates (e.g., 0.2) are often used in the early layers, where features are more general, while higher rates (e.g., 0.5) may be used in later layers to encourage feature diversity.== Advantages of Dropout Reduces Overfitting: By preventing neurons from co-adapting, dropout reduces the likelihood of overfitting, especially in deep networks with many parameters. Improves Generalization: Dropout encourages the model to learn distributed representations, which improves generalization to unseen data. Limitations of Dropout Training Time: Dropout increases the training time since each neuron needs to learn without relying on specific neurons being active every time. Not Always Effective: In some networks (e.g., recurrent neural networks), dropout can lead to reduced performance if not applied carefully. Weight Decay ( L2 regularization ) Weight decay is a regularization technique used in deep learning to prevent overfitting of neural networks by adding a penalty on the size of weights in the model.\nWeight Decay, or L2 Regularization, is a regularization technique applied to the weights of a neural network. We minimize a loss function compromising both the primary loss function and a penalty on the L2 Norm of the weights:\nwhere ( lambda ) is a value determining the strength of the penalty (encouraging smaller weights).\nThe term \u0026ldquo;weight decay\u0026rdquo; is commonly used to refer to a specific form of regularization called L2 regularization\nWeight decay help to Conquire overfitting problem Weight decay is implemented by adding a penalty term to the loss function.\nThe penalty term discourages large weights, making the model simpler and improving generalization on new data. Benefits:\nPrevents overfitting by reducing model sensitivity. Encourages smoother predictions and simpler models. Batch Normalization Batch normalization (BN) stabilizes and accelerates training in deep neural networks by normalizing the inputs to each layer.\nBenefits:\nFaster Training: Reduces the internal covariate shift, allowing higher learning rates. Improved Stability: Makes training more stable, reducing the need for careful initialization. Reduces Overfitting: Acts as a regularizer, reducing the need for other forms of regularization (like dropout). Where to Apply: Typically added before the activation function in each layer, especially in deep networks (e.g., CNNs, RNNs).\nHelps models converge faster, reduces sensitivity to initialization, and can improve model generalization.\nEarly Stopping Early stopping is a form of regularization used to prevent overfitting in machine learning and deep learning models. It involves stopping the training process before the model starts to overfit. The idea is to monitor the model’s performance on a validation set during the training process and stop training when the performance starts to degrade, which is an indication that the model is beginning to overfit the training data.\nStops training when performance on a validation set stops improving, preventing overfitting\nWorking: Monitors validation loss; if it doesn’t improve for a set number of epochs (patience), training halts.\nBenefits:\nPrevents Overfitting: Stops before the model starts fitting noise in the training data. Saves Resources: Reduces training time by stopping early. Where to Use: Common in any iterative training process, especially for deep networks.\nData augmentation Expands training data by creating modified versions of existing samples to improve model generalization.\nTechniques:\nImage: Random rotations, flips, crops, brightness adjustments.\nText: Synonym replacement, random insertion/deletion of words.\nAudio: Pitch shift, time stretch, noise addition\nBenefits:\nReduces Overfitting: Increases data diversity, helping models generalize better. Improves Robustness: Trains the model on more varied inputs, making it more resilient. Where to Use: Common in image, audio, and text data when datasets are limited.\nAdding Noise to Input (Gaussian noise) Purpose: Makes the model robust by training it on slightly noisy inputs. How it Works: Adds small, random noise to input data during training (e.g., Gaussian noise for images). Benefits: Improves Generalization: Forces the model to focus on essential patterns rather than memorizing exact data points. Resilience to Variations: Helps the model handle noisy real-world data better. Where to Use: Common in image and audio data, and applicable to other types where noise is realistic. Adding Noise to Output (Label Smoothing) Purpose: Softens the model’s confidence on predictions to avoid overfitting on exact labels. How it Works: Adjusts true labels to be less confident (e.g., 0.9 for correct class, 0.1 for others), reducing sensitivity to label noise. Benefits: Prevents Overconfidence: Makes the model less likely to overfit by preventing extreme confidence. Improves Generalization: Reduces the gap between training and test performance. Where to Use: Common in classification tasks where exact class boundaries are less clear. ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/deep-learning/module-2/2.training-optimization-regularization-of-deep-network/","title":"Module 2 2 Training, optimization, Regularization of Deep network"},{"content":"\nWhat is HDFS? Hadoop Distributed File System (HDFS) is the ==primary storage system== used by Hadoop to store large datasets in a distributed manner across multiple nodes in a ==cluster==. ==Inspired by Google File System== (GFS), HDFS is ==designed for high fault tolerance, scalability, and support for high-throughput data access==. It handles data storage needs for applications that process vast amounts of structured and unstructured data, making it ideal for Big Data processing. Key Characteristics of HDFS Distributed Storage: HDFS splits large files into smaller blocks (default size is 128 MB or 64 MB) and distributes these blocks across multiple nodes. Fault Tolerance: Data blocks are replicated across different nodes to prevent data loss in case of hardware failures. High Throughput: Optimized for large, sequential data reads and batch processing, rather than low-latency access to small data files. Scalability: Scales horizontally across thousands of nodes without requiring major architectural changes. Write Once, Read Many: Files are typically written once and read many times, allowing for efficient and simple data access patterns in analytics. HDFS Architecture HDFS has a ==master-slave architecture== with two main components:\n1. NameNode master node Role: Acts as the ==master node in HDFS==, ==managing== the file system ==metadata==. Responsibilities: Keeps track of the file directory structure, such as file names, locations, permissions, and hierarchies. Maintains the block locations and replication information for every file stored in HDFS. ==Does not store actual data blocks==; it only keeps metadata. Reliability: ==Single point of failure (SPOF) in Hadoop ==1.x, though Hadoop 2.x introduced High Availability (HA) configurations to prevent downtime by using a standby NameNode. 2. DataNode slave node Role: The ==worker nodes== that store actual data blocks on local storage. Responsibilities: Stores, retrieves, and manages the data blocks requested by clients or the NameNode. Periodically sends heartbeat signals to the NameNode to confirm it is operational. Sends block reports to the NameNode, which include information on stored data blocks and their health status. Fault Tolerance: If a DataNode fails, the NameNode reassigns the data blocks to other nodes based on the replication factor, ensuring no data loss. 3. Secondary NameNode Role: A helper to the NameNode, though not a true backup. It periodically takes snapshots of the NameNode’s metadata. Responsibilities: Merges the edit log with the File System Image (FsImage), which helps reduce the NameNode’s workload and keeps metadata up-to-date. If the primary NameNode fails, this metadata snapshot can help reconstruct the system but is not a direct substitute. Not for Failover: Hadoop 2.x introduced Standby NameNodes for High Availability rather than relying on the Secondary NameNode. Key Concepts in HDFS 1. Blocks and Block Size Block Concept: Large files are split into smaller, fixed-size blocks, typically 128 MB by default (configurable). Advantages: Easier distribution across nodes. Optimized read/write throughput since processing can happen in parallel. Replication: Blocks are replicated across DataNodes for redundancy (default replication factor is 3). 2. Replication and Fault Tolerance Replication Factor: The number of copies of each block stored across different nodes (default is 3). Fault Tolerance: If a DataNode fails, HDFS ensures data availability by replicating the missing blocks on other nodes. Rack Awareness: HDFS is aware of the physical location of nodes and can store data copies across different racks to minimize data loss in case of rack failures. 3. Data Read and Write Operations in HDFS Write Operation: Data is split into blocks and sent to DataNodes. The NameNode assigns which DataNodes to store the replicas. Data is stored on the primary DataNode, then replicated to the other DataNodes. Read Operation: The client requests the file from the NameNode. The NameNode provides the block locations, and the client reads data blocks directly from the relevant DataNodes in parallel. 4. Heartbeat and Block Report Mechanism Heartbeat: DataNodes send regular signals to the NameNode indicating they are active. Block Report: Periodic report from each DataNode to the NameNode about all the blocks it stores, helping the NameNode maintain block locations and detect any block-level failures. 5. Rack Awareness Definition: A topology-aware feature in HDFS that understands the physical layout of nodes and racks. Purpose: Data blocks are distributed across racks to minimize data loss risk if an entire rack fails. Benefits: Increases fault tolerance and reduces inter-rack network traffic, as replicas are placed on different racks. Advantages of HDFS ==Scalability==: Can handle petabytes or even exabytes of data by scaling horizontally. ==Cost-Efficiency==: Runs on commodity hardware, reducing the need for high-cost storage solutions. ==High Fault Tolerance==: Replication and distributed architecture provide strong data reliability. ==High Throughput Access==: Optimized for batch processing and large datasets, which are common in Big Data analytics. ==Data Locality:== Moves computation close to where data is stored, reducing network congestion and increasing processing speed. Limitations of HDFS ==Latency for Small Files==: HDFS is inefficient for handling a large number of small files, as each file’s metadata is stored in the NameNode, which can lead to memory overload. ==Single Point of Failure== (in Hadoop 1.x): The NameNode failure would bring down the entire system, though HA was introduced in Hadoop 2.x to mitigate this. ==Limited Random Access==: HDFS is optimized for high-throughput and large sequential reads, not random reads or updates. ==Write Once, Read Many==: Files in HDFS are immutable after they are written; updating a file requires rewriting it. HDFS and Data Access Patterns Batch Processing: HDFS excels in scenarios where data access is required in bulk, typically in batch processing jobs, making it suitable for MapReduce and other large-scale data analytics. Sequential Data Access: Optimized for reading large files in a sequential manner, rather than random data access like traditional file systems. Map Reduce MapReduce is a ==programming model and processing technique for distributed computing==, primarily used within the Hadoop ecosystem to process large datasets in parallel across clusters of computers. ==Developed by Google==, MapReduce is the core component that enables Hadoop to perform high-performance and fault-tolerant distributed data processing. Let’s dive into the details of MapReduce, including how it works, its key concepts, and use cases.\nOverview of Map-reduce Purpose: Map-reduce enables processing of vast amounts of data in a ==parallel, distributed fashion.== Components: It consists of two main phases, the ==Map phase== and the ==Reduce phase==, which split the task into smaller subtasks, execute them in parallel, and then aggregate the results. Fault Tolerance: Automatically handles node failures by redistributing tasks to other nodes in the cluster. How MapReduce Works MapReduce operates in two main stages:\n1. Map Phase Function: The ==Map phase processes input data and generates== ==a set of intermediate== ==key-value pairs==. Process: Each input data file is divided into blocks, which are assigned to different nodes in the cluster. Each node executes a Map function on its assigned data blocks, which processes records individually. The output is in the form of key-value pairs (for example, for counting words, the key could be a word, and the value could be the count of occurrences). Intermediate Data: This phase generates intermediate data in key-value pairs, which is then sorted and grouped by key for the next phase. 2. Shuffle and Sort Phase Function: The Shuffle and Sort phase sorts all the intermediate data by key and groups it together for the Reduce phase. Process: Intermediate data from each Map task is grouped by key, so that all values corresponding to a particular key are together. This sorting and grouping make it easier for the Reduce phase to aggregate results for each key. 3. Reduce Phase Function: The Reduce phase ==consolidates the intermediate data==, ==applying the logic to combine or aggregate values associated with each key.== Process: The Reduce function takes each key and processes the list of values associated with it. This aggregation could be a sum, count, average, or any other operation, depending on the analysis required. Output: The final output is typically stored in HDFS, representing the result of the entire MapReduce job. Detailed Steps of a MapReduce Job Execution 1. Input Splitting Data Splitting: Hadoop splits the input data into fixed-size chunks (default 128 MB) called splits. Assignment to Mappers: Each split is assigned to a Mapper, which processes one split independently of others. 2. Mapping Mapper Execution: Each Mapper processes the split data line-by-line, applying the user-defined Map function to each record. Key-Value Generation: Mappers produce intermediate key-value pairs as output. 3. Shuffling and Sorting Shuffle: Intermediate key-value pairs are shuffled to group identical keys together. Sort: The keys are sorted to prepare data for the Reduce phase, allowing efficient aggregation of values by key. 4. Reducing Reducer Execution: Each unique key is sent to a Reducer along with its corresponding list of values. Aggregation: Reducer applies the aggregation or combination logic on the values, producing a consolidated result for each key. 5. Output Writing Final Storage: The results of the Reduce phase are written back to HDFS or other storage systems, typically as output files (one file per Reducer). Key Concepts in MapReduce 1. Key-Value Pairs Definition: Data in MapReduce is represented as key-value pairs, both as input and output. Flexibility: This structure allows MapReduce to process different data types in a uniform way. 2. Mappers and Reducers Mapper: Processes data and emits intermediate key-value pairs. Multiple Mappers work in parallel. Reducer: Consolidates data based on keys and applies a final aggregation, such as summing or counting. 3. Combiner (Optional) Purpose: An optional step that acts as a “mini-reducer” to reduce the amount of intermediate data passed to Reducers, minimizing network traffic. Usage: Useful for scenarios where partial aggregation can be done at the Mapper level (e.g., local word counts before sending to Reducer). 4. Partitioner Function: Determines how key-value pairs are distributed to Reducers by controlling which key-value pairs are sent to which Reducer. Example: A default partitioner might hash the key to decide the Reducer, ensuring an even distribution of workload. 5. Job Tracker and Task Tracker (Hadoop 1.x) / Resource Manager and Node Manager (Hadoop 2.x) Job Tracker: Oversees the job’s execution (assigning tasks and monitoring nodes) in Hadoop 1.x. Task Tracker: Executes individual tasks (Map or Reduce) on worker nodes. In Hadoop 2.x, YARN’s Resource Manager and Node Managers replaced Job Tracker and Task Tracker for better scalability and fault tolerance. MapReduce Example: Word Count This example shows how MapReduce processes a word count job:\n1. Input Data \u0026#34;big data and hadoop\u0026#34; \u0026#34;hadoop and mapreduce\u0026#34; 2. Map Phase Mapper Output: (\u0026#34;big\u0026#34;, 1), (\u0026#34;data\u0026#34;, 1), (\u0026#34;and\u0026#34;, 1), (\u0026#34;hadoop\u0026#34;, 1) (\u0026#34;hadoop\u0026#34;, 1), (\u0026#34;and\u0026#34;, 1), (\u0026#34;mapreduce\u0026#34;, 1) 3. Shuffle and Sort Phase Grouped Data: (\u0026#34;and\u0026#34;, [1, 1]), (\u0026#34;big\u0026#34;, [1]), (\u0026#34;data\u0026#34;, [1]), (\u0026#34;hadoop\u0026#34;, [1, 1]), (\u0026#34;mapreduce\u0026#34;, [1]) 4. Reduce Phase Reducer Output: (\u0026#34;and\u0026#34;, 2), (\u0026#34;big\u0026#34;, 1), (\u0026#34;data\u0026#34;, 1), (\u0026#34;hadoop\u0026#34;, 2), (\u0026#34;mapreduce\u0026#34;, 1) 5. Final Output The final output is stored in HDFS, providing a count of each word in the input data. Advantages of MapReduce ==Scalability==: Can scale to handle petabytes of data across thousands of nodes. ==Fault Tolerance==: Automatic data replication and task re-execution in case of node failures. ==Data Locality==: Tasks are assigned to nodes where data is stored, minimizing network traffic. ==Parallel Processing==: Executes tasks in parallel, optimizing processing time for large datasets. Limitations of MapReduce ==Inefficient for Small Tasks==: MapReduce is optimized for large-scale batch processing, and overhead can be high for smaller tasks. ==High Latency for Real-Time Processing==: Designed for batch processing, not for real-time analytics. Frameworks like Apache Spark are better suited for low-latency applications. ==Single Data Flow:== MapReduce is not suitable for iterative computations (e.g., machine learning algorithms), as each iteration requires a separate MapReduce job, increasing complexity and time. Use Cases for MapReduce ==Log Analysis==: Processing large volumes of logs for insights on server usage, error rates, or web traffic patterns. ==Search Indexing==: Building an inverted index for search engines, where documents are mapped to the keywords they contain. ==Data Aggregation==: Summing, counting, and averaging large datasets, such as in customer analytics or transaction histories. ==ETL Operations==: Transforming and loading data from various sources into data warehouses or storage systems for further analysis. ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/big-data-analysis/module-2/hdfs-and-mapreduce/","title":"Module 2 HDFS and MapReduce"},{"content":"\nNoSQL databases are a category of database management systems (DBMS) that provide an alternative to traditional relational databases (RDBMS).\ndesigned to ==handle large volumes== of diverse and complex data, ==support high scalability, and enable flexible data modeling.==\nNoSQL databases ==are ideal for big data, real-time web applications,== and other use cases where the rigid schemas and transactional consistency of relational databases are not necessary or practical.\nDefination : \u0026ldquo;NoSQL\u0026rdquo; stands for \u0026ldquo;Not Only SQL,\u0026rdquo; highlighting that these databases do not strictly adhere to the traditional relational model\nNoSQL databases offer flexible data models and ==can handle unstructured, semi-structured, and structured data.==\nScalability: Designed for ==horizontal scalability==, NoSQL databases can handle growing volumes of data by ==adding more servers rather than increasing the capacity of a single server.==\nCharacteristics of NOSQL schema flexibility scalability high performance Distribution : often ==distributed across clusters==, which helps in ==balancing load ==and enhancing fault tolerance. Data Structure Flexibility: support various data formats, ==including JSON, XML, BSON, and binary formats==, making it easier to handle diverse data types. Types of NoSQL Databases 1. Key-Value Stores Structure: ==Data== is ==stored== as ==simple key-value pairs==, where each key is unique, and values can be any type of data, such as ==strings, JSON, or binary data.== Performance: ==Highly efficient== for retrieving data by key, making them suitable for caching and session management. Examples: ==Redis, DynamoDB, Memcached, Riak==,azuretables. Use Cases: ==Caching, user profiles, session management, real-time recommendations.== 2. Document Stores Structure: Data is stored as documents in ==formats like JSON or BSON==, which ==allows a flexible schema and hierarchical data storage.== Document Model: Each document can have ==different fields, and fields can be nested, making it ideal for semi-structured data.== Examples: ==MongoDB, CouchDB, Amazon DocumentDB==. Use Cases: Content management, ==product catalogs==, user profiles, ==e-commerce data==, and any application requiring hierarchical or complex data. 3. Column-Family Stores Structure: Data is ==organized in rows and columns== but ==differs from relational databases in its storage structure, as columns are grouped into \u0026ldquo;column families.\u0026quot;== Column Families: ==A column family is a container for rows, where each row can contain different columns within the same family. This model is optimized for reading and writing large datasets across distributed systems==. Examples: ==Apache Cassandra, HBase, ScyllaDB.== Use Cases: ==Real-time analytics, time-series data, recommendation engines, IoT data.== 4. Graph Databases Structure: ==Data is stored in nodes, edges, and properties, representing entities, relationships, and attributes, respectively.== Graph Model: Graph databases are ==optimized for complex relationships and connected data, making it easier to traverse relationships without complex joins.== Examples: ==Neo4j, Amazon Neptune, ArangoDB,hygraph==. Use Cases: ==Social networks, recommendation systems, fraud detection, network and supply chain analysis==. Core Concepts in NoSQL Databases 1. CAP Theorem Definition: CAP Theorem states that a distributed data store ==cannot simultaneously guarantee Consistency, Availability, and Partition Tolerance==. Choices in NoSQL: NoSQL databases often prioritize availability and partition tolerance, favoring eventual consistency over strict consistency. Consistency: All nodes have the same data at the same time. Availability: The system is always available for read and write operations. Partition Tolerance: The system continues to function even if there’s a network partition or communication breakdown. 2. Eventual Consistency vs. Strong Consistency Eventual Consistency: ==Data updates may not immediately reflect on all nodes==, but they eventually converge to a consistent state. Strong Consistency: Ensures that once an update is made, ==all nodes see the latest value immediately.== Trade-Off: Many NoSQL databases choose eventual consistency to optimize for availability and partition tolerance. 3. Sharding Definition: Sharding is a technique ==used to partition data across multiple servers or nodes, improving scalability and performance==. Horizontal Scaling: Sharding ==allows NoSQL databases to distribute data and load across multiple nodes==, enabling horizontal scaling. Implementation: NoSQL databases like ==MongoDB and Cassandra== ==use sharding== to balance data across clusters. 4. Replication Definition: Replication involves ==creating multiple copies of data== on different nodes or data centers for fault tolerance. High Availability: Replication ensures that if one node fails, other copies can still be accessed, making the system highly available. Consistency Models: Replication strategies can affect consistency; some databases offer tunable consistency to balance speed and reliability. Advantages and disadvantages of nosql Advantages Disadvantages Schema Flexibility Lack of ACID Transactions Horizontal Scalability Limited Query Capabilities Performance and speed [[Consistency trade-offs]] [[developer agencet]] [[Standardization Challenges]] High Availability Use Cases for NoSQL Databases 1. Big Data Applications Description: NoSQL databases are ==ideal for handling large and diverse data==, ==such as logs, clickstream data, or IoT sensor data==. Examples: Hadoop with ==HBase or Cassandra ==for ==high-throughput data storage and analysis.== 2. Content Management Systems (CMS) Description: ==Document stores like MongoDB or Couchbase== are well-suited for CMS applications due to their schema flexibility. Examples: ==Storing articles, product descriptions, images, and media assets.== 3. Social Networking and Graph-Based Applications Description: ==Graph databases like Neo4j== are optimized for storing and traversing complex relationships, which is essential for social networks. Examples: Friend connections, recommendations, and influencer analysis. 4. E-Commerce Applications Description: NoSQL databases can handle product catalogs, inventory systems, and personalized recommendations, which need fast, flexible data access. Examples: Redis or DynamoDB for shopping carts, product recommendations, and session storage. 5. Real-Time Analytics and Monitoring Description: In applications where real-time processing is critical, ==NoSQL databases like Cassandra or Redis provide high-performance, low-latency access.== Examples: Monitoring dashboards, financial tick data, and sensor readings for IoT. Popular NoSQL Databases and Their Specializations MongoDB: Document-oriented, schema-less, JSON-like storage, ideal for flexible data. Cassandra: Column-family store designed for high availability, used in real-time data applications. Redis: In-memory key-value store, used for caching and real-time applications. Neo4j: Graph database optimized for relationship-based data and queries. DynamoDB: Amazon\u0026rsquo;s managed key-value and document database, known for high scalability. RDBMS VS NoSQL RDBMS NoSQL ==Relational== (tables with rows and columns) ==Non-relational== (document, key-value, graph, or column family) ==Fixed schema== (predefined structure) ==Flexible schema== (dynamic and schema-less) ==Enforces ACID properties== (Atomicity, Consistency, Isolation, Durability) Can support ACID in some cases but often relaxes consistency for scalability (BASE model) ==Vertical scaling== (adding more power to a single server) ==Horizontal scaling== (adding more servers) ==Uses normalization== to reduce redundancy Often ==denormalized== for faster access SQL (==Structured Query Language==) ==Varies by database== (e.g., MongoDB uses JSON-like query language) ==Complex transactions and multi-row queries, consistency-critical applications== ==Large-scale data, rapid development, unstructured or semi-structured data, real-time applications== ==MySQL, PostgreSQL, Oracle, SQL Server== ==MongoDB, Cassandra, Redis, Couchbase== ==Stores data in tables== with relationships ==Stores data as documents==, ==key-value pairs, graphs, or columns== May be ==slower== with very ==large== datasets Optimized for ==high-speed transactions== and large volumes of data ==Supports JOIN operations== to relate data across tables Generally ==avoids JOINs==, uses embedded or linked data models instead ==Strong transaction support== (multi-step transactions with rollback) Varies, ==typically lightweight transactions==, limited multi-document transactions ==Strong consistency== by default ==Often eventual consistency==, though some support strong consistency ==Financial applications==, e-commerce, CRM ==Social media, IoT, content management, big data applications== ==Good at complex queries with multiple joins and aggregations== ==Limited support for complex querying, may require custom code== ==Row-based storage== ==Document, key-value, graph, or column-based storage== ==Established, mature technology with widespread use== ==Newer, with rapid innovation and varied adoption== NoSQL Solution for big data Bulk Image Processing Public web page Data Remote Sensor Data Event Log Data Mobile Phone Dhata Social Media Data Game Data Open Linked Data Explain Column family store and Graph Store NoSQL architectural pattern with example. NoSQL databases are categorized based on their underlying data models and are optimized for specific use cases. The four primary types of NoSQL databases are:\nKey-Value Store Document Store Column Family Store Graph Store Let’s explore each in detail.\n1. Key-Value Store Key-value stores are the simplest type of NoSQL database, designed to store data as a collection of ==key-value pairs==, ==similar to a dictionary or hash table==. Each key is unique and directly points to a single data value, making these stores efficient for read and write operations.\nArchitecture:\n==Data is stored in a large hash table where each entry consists of a unique key and its associated value.== Values are usually ==opaque to the database==, meaning the database doesn’t interpret or structure them; they can be strings, binary data, JSON objects, or other formats. The database retrieves values using the keys directly, allowing for extremely fast lookups. Advantages:\n==Fast data access== and retrieval due to direct key lookups. ==Simple structure, easy to scale horizontally==. Limitations:\n==Limited querying capabilities==; the database only supports key-based access. ==Not ideal for complex queries or data relationships. == Examples:\nRedis and DynamoDB are popular key-value stores. Use Case: Session management, caching, real-time analytics, and user profile storage. 2. Document Store Document stores manage ==semi-structured data in a flexible format==, typically using documents encoded in ==JSON, BSON, XML==, or similar formats. Each document is a self-contained unit that can hold nested structures, arrays, and key-value pairs, allowing for flexible schema designs.\nArchitecture:\n==Data is stored in \u0026ldquo;documents\u0026rdquo;== within \u0026ldquo;collections\u0026rdquo; instead of rows and tables. Each ==document is identified by a unique key== and can contain various fields, sub-documents, and arrays. Document databases ==support flexible schemas==, meaning documents in the same collection can have different structures. Advantages:\n==Flexibility== in handling varied data structures. Ideal for applications with complex data models or evolving requirements, as schema changes don’t disrupt existing data. Limitations:\n==Not suitable for applications that require strict ACID compliance.== ==Joins and complex relationships== can be ==challenging== to implement. Examples:\nMongoDB, Couchbase, and Amazon DocumentDB. Use Case: Content management systems, e-commerce catalogs, and applications requiring high flexibility in data storage. 3. Column Family Store (Column-Oriented Database) Column family stores, or column-oriented databases, ==organize data into column families instead of rows==. This approach allows for ==highly optimized storage== and retrieval of data, especially for read-heavy applications with specific columns frequently accessed together.\nArchitecture:\n==Data is grouped by column families==, which are collections of related columns. Each row can contain different columns, allowing flexible data storage. Rows are typically distributed across nodes, allowing for horizontal scaling and data redundancy. Advantages:\n==Optimized for fast retrieval of specific columns==, making it suitable for analytical workloads. Allows for efficient data compression due to columnar storage. Limitations:\nLimited support for complex querying; ==JOIN operations are generally not supported.== Requires knowledge of access patterns for effective data modeling. Examples:\nApache Cassandra, HBase, and ScyllaDB. Use Case: Time-series data, real-time analytics, logging systems, and recommendation engines. 4. Graph Store Graph stores focus on representing data as ==interconnected nodes and edges==, ideal for applications where ==relationships between data points are essential==. These databases are optimized for traversing and querying connections, such as finding the ==shortest path between nodes or identifying relationship patterns==.\nArchitecture:\nData is represented as nodes (entities) and edges (relationships) with properties (attributes) attached to both nodes and edges. Graph databases are designed to handle and optimize graph traversal operations, enabling efficient execution of relationship-based queries. Advantages:\nProvides high performance for queries involving relationships and connections between data. Supports complex relationship models that are difficult to represent in traditional databases. Limitations:\nNot ideal for applications where data is not inherently graph-like. Can be more complex to scale horizontally compared to other NoSQL types. Examples:\nNeo4j, Amazon Neptune, and ArangoDB. Use Case: Social networks, recommendation engines, fraud detection, and network analysis. Summary of Use Cases by Database Type NoSQL Type Ideal Use Cases Key-Value Store Session storage, caching, real-time analytics Document Store Content management, e-commerce, catalogs Column Family Store Time-series data, logging, recommendation engines Graph Store Social networks, fraud detection, network analysis Each type of NoSQL database is optimized for different types of data and use cases, providing flexibility and performance for specific application needs.\nDistribute query to all the data node\nLetting the database distribute queries evenly to data nodes\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/big-data-analysis/module-3/1.-nosql/","title":"Module 3 1  NoSQL"},{"content":"### Syllabus What is Autoencoders Autoencoders are a ==type of neural network architecture== used primarily for ==unsupervised learning== tasks, where the goal is to learn a compressed, efficient representation of input data. They are often used for ==dimensionality reduction, feature learning, denoising, and data generation.==\nEncoder: Maps the input data to a lower-dimensional, compressed representation called a latent space or bottleneck.\nLatent Representation: The most crucial characteristics of the input data are captured by the latent representation. It is a compact, concentrated depiction that ideally retains the most important information.\nDecoder: Reconstructs the input data from the compressed representation.\nThe network’s goal is to minimize the difference between the original input and its reconstruction, often measured with a ==loss function== (e.g., mean squared error for images).\nWorking:\nThe encoder ==reduces the dimensionality of the data==, capturing essential features. The ==decoder tries to rebuild the original data== from this compressed form, learning important patterns and structures in the data. Applications:\nDimensionality Reduction: Used as an alternative to PCA for compressing high-dimensional data. Anomaly Detection: Detect outliers by identifying inputs with high reconstruction errors. Denoising: Removes noise from corrupted data, especially in image and audio processing. Image Generation: Variational Autoencoders can generate new, realistic images based on learned data distributions. Limitations of Autoencoders:\nNeed for Large Datasets: Require substantial data to learn useful representations. Non-Generalizable: Trained on specific data distributions and may not generalize well to unfamiliar data. Here’s a breakdown of each type of autoencoder with key points for each:\n1. Linear Autoencoder Purpose: Primarily used for ==dimensionality reduction==, similar to Principal Component Analysis ==(PCA).== Structure: ==Uses linear activation functions ==(instead of nonlinear ones like ReLU or Sigmoid) in both the encoder and decoder. Characteristics: ==Performs similarly to PCA== when the encoder and decoder are linear. Learns a lower-dimensional representation by projecting data onto a linear subspace. Not widely used in practice because nonlinear autoencoders generally perform better in capturing complex patterns. Use Case: Useful as a conceptual== bridge between autoencoders and PCA==. 2. Undercomplete Autoencoder Purpose: Designed to learn a compressed representation by ==creating a bottleneck with fewer neurons than the input dimensions.== Structure: The ==latent space (bottleneck) is smaller than the input==, forcing the network to learn the most important features. Characteristics: Helps in removing redundant information and focusing on essential features. Works well for dimensionality reduction and feature extraction. Use Case: Effective for applications where the goal is to learn a compact representation of the data. 3. Overcomplete Autoencoder Purpose: Has a ==latent space larger than the input dimension==, creating an overcomplete representation. Structure: More neurons in the bottleneck layer than in the input, which can lead to high capacity for storing data. Characteristics: Risk of learning a near-perfect identity mapping, which may lead to overfitting if regularization is not applied. To avoid learning trivial mappings, additional constraints (e.g., sparsity) are often added. Use Case: Can be useful with added regularization (like sparsity or noise) to learn richer features. 4. Denoising Autoencoder Purpose: Designed to remove noise from data ==by learning to reconstruct the original input from a noisy version.== Structure: The input data is deliberately corrupted (e.g., adding Gaussian noise), and the autoencoder is trained to reconstruct the clean version. Characteristics: Encourages the model to learn robust features that are invariant to noise. Forces the autoencoder to learn general patterns instead of memorizing data. Use Case: Commonly used in image and audio processing for noise reduction and in scenarios where robust representations are needed. 5. Sparse Autoencoder Purpose: Learns features with ==sparse activations== by encouraging the majority of neurons to be inactive ==(close to zero)== for a given input. Structure: Often has an ==overcomplete architecture with additional regularization (e.g., L1 regularization)== to enforce sparsity in the bottleneck layer. Characteristics: Allows the network to learn interpretable features, as each neuron in the bottleneck becomes sensitive to specific patterns. Reduces overfitting by making the network focus on a smaller subset of the neurons for each input. Use Case: Effective in feature learning, especially in cases where sparse representations are beneficial (e.g., image recognition, natural language processing). 6. Contractive Autoencoder Purpose: Designed to make the model robust to small input variations by ==penalizing the sensitivity== of the bottleneck representation. Structure: Adds a regularization term to the loss function, penalizing the gradient of the encoder’s output with respect to the input, which minimizes changes in the representation for small input changes. Characteristics: Encourages the model to ==learn smooth mappings== and to be ==invariant to minor input variations.== ==Enhances robustness and generalization==. Use Case: Commonly used when input data may have slight variations, such as in ==image recognition or sensor data, and robustness is critical==. Regularization in Autoencoders Regularization in autoencoders refers to techniques that help improve the model\u0026rsquo;s generalization and prevent it from learning trivial solutions (like copying the input directly). Regularization in autoencoders is especially important because autoencoders can easily learn to memorize the input without extracting meaningful features, which makes them less useful for tasks like dimensionality reduction, anomaly detection, and feature learning. Here are some common regularization methods used in autoencoders:\n1. Sparse Regularization Purpose: Encourages only a subset of neurons in the hidden layer to activate for each input, leading to a sparse representation. Method: Adds a penalty (like L1 regularization) to force some of the activations in the bottleneck layer to be close to zero. Benefit: Helps the autoencoder learn interpretable and compact representations by focusing on the most important features. Application: Sparse autoencoders are commonly used in feature learning and image processing. 2. Denoising Regularization Purpose: Makes the model robust to noise by adding random noise to the input and training the autoencoder to reconstruct the original, clean input. Method: Applies noise (e.g., Gaussian noise, masking noise, or dropout) to the input before feeding it into the encoder. Benefit: Forces the autoencoder to learn stable, noise-invariant representations and prevents it from simply copying the input. Application: Denoising autoencoders are often used for image denoising, anomaly detection, and pretraining for downstream tasks. 3. Contractive Regularization Purpose: Reduces sensitivity to small changes in the input, making the representation smoother and more robust to small variations. Method: Adds a penalty on the Frobenius norm of the Jacobian matrix of the encoder’s activations with respect to the input, encouraging minimal variation in the representation. Benefit: Encourages the model to learn features that are robust to slight changes, making it useful for feature extraction. Application: Often used in applications where robustness to small changes in input is important, like image and signal processing. 4. Dropout Regularization Purpose: Prevents overfitting by randomly dropping neurons during training, encouraging the network to learn redundant representations. Method: Randomly drops a subset of neurons (both in encoder and decoder layers) during training, which forces the model to distribute the learned features across multiple neurons. Benefit: Reduces over-reliance on any single neuron, improving generalization and preventing the autoencoder from memorizing the data. Application: Commonly used in deep autoencoders for large datasets to ensure robust learning. 5. Variational Regularization (for Variational Autoencoders) Purpose: Forces the latent space to follow a specified distribution, allowing the autoencoder to generate new data samples. Method: Adds a Kullback-Leibler (KL) divergence loss to ensure the latent representation approximates a standard normal distribution. Benefit: Useful for generating new data (like synthetic images or text), and smooths the latent space so similar inputs produce similar encodings. Application: Used in Variational Autoencoders (VAEs) for tasks like data generation, anomaly detection, and representation learning. 6. Early Stopping Purpose: Prevents overfitting by stopping training when performance on a validation set stops improving. Method: Monitors validation loss; if there is no improvement after a set number of epochs (patience), training is halted. Benefit: Reduces overfitting, ensures the model doesn’t memorize data, and saves computational resources. Application: Widely used in any training process where generalization is important, including autoencoder training. 7. Weight Regularization (L1 and L2 Regularization) Purpose: Reduces the complexity of the model by penalizing large weights, which can prevent overfitting. Method: Adds a penalty term to the loss function—L1 regularization penalizes the absolute value of weights (making some weights zero), while L2 regularization penalizes the square of weights (encouraging smaller weights). Benefit: Encourages simpler models with smaller weights that generalize better. Application: Useful for controlling complexity in overcomplete autoencoders, where the latent space is larger than the input. Applications of Autoencoder Image and Audio Compression: Autoencoders can compress huge images or audio files while maintaining most of the vital information. An autoencoder is trained to recover the original picture or audio file from a compressed representation.\nAnomaly Detection: One can detect anomalies or outliers in datasets using autoencoders. Training the autoencoder on a dataset of normal data and any input that the autoencoder cannot accurately reconstruct is called an anomaly.\nDimensionality Reduction: Autoencoders can lower the dimensionality of high-dimensional datasets. We can accomplish this by teaching an autoencoder a lower-dimensional data representation that captures the most relevant features.\nData Generation: Employ autoencoders to generate new data similar to the training data. One can accomplish this by sampling from the autoencoder’s compressed representation and then utilizing the decoder to create new data.\nDenoising: One can utilize autoencoders to reduce noise from data. We can accomplish this by teaching\nan autoencoder to recover the original data from a noisy version.\nRecommender System: Using autoencoders, we can use users’ preferences to generate personalized suggestions. We can accomplish this by training an autoencoder to learn a compressed representation of the user’s history of system interactions and then utilizing this representation to forecast the user’s preferences for new items.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/deep-learning/module-3/autoencoders/","title":"module 3 AutoEncoders"},{"content":"Syllabus Stream data model The stream data model in big data analytics is a processing model designed to ==handle data that is continuously generated in real-time== by various ==sources== such as ==sensors, social media, transactions, and log files==. This data arrives in an ongoing, unbounded flow rather than being stored in fixed batches. The model enables the analysis, transformation, and storage of data as it streams in, allowing for real-time insights and actions. Here’s an in-depth look at the stream data model and its components, characteristics, and applications:\n1. Characteristics of the Stream Data Model ==Continuous Data Flow==: ==Data== is ==generated and collected continuously==, often in small, ==high-frequency increments==. ==Low Latency Processing==: Stream processing is designed for ==near real-time== or real-time data processing, with ==minimal delay between== data generation and analysis. Unbounded Data Sets: Unlike batch data, which is processed in finite sets, streaming data is unbounded and constantly growing. Time Sensitivity: The value of data in stream processing often diminishes over time, making timely processing essential. ==Event-Based Processing==: Stream data typically consists of individual events (e.g., transactions, clicks, sensor readings) that are processed in the order they are received. 2. Components of the Stream Data Model Data Sources: The sources generating data, such as IoT sensors, social media platforms, application logs, and financial transactions. Stream Ingestion: Tools or platforms that capture and ingest streaming data. Examples include Apache Kafka, Amazon Kinesis, and Apache Pulsar. Stream Processing Engine: This engine processes data in real-time, often performing transformations, aggregations, and computations. Common stream processing frameworks include Apache Flink, Apache Spark Streaming, and Apache Storm. Data Storage: Storage systems optimized for stream data, often involving both temporary storage (for intermediate results) and long-term storage (for historical analysis). Examples include NoSQL databases (e.g., Cassandra, HBase) and distributed file systems (e.g., HDFS, S3). Output / Action: After processing, results are directed to target systems for real-time dashboards, alerts, or storage for further analysis. Results can also trigger automated actions or updates in other systems. 3. Stream Processing Models Real-Time Analytics: Processes data as it arrives, providing immediate insights and actions. For example, identifying fraudulent transactions as they happen. ==Window-Based Processing==: Uses time or event count windows to group and process data streams in manageable chunks. Common window types include: Tumbling Window: Fixed-size, non-overlapping windows (e.g., 5-minute windows). ==Sliding Window==: Fixed-size, overlapping windows, allowing for more granular analysis. Session Window: Windows based on periods of activity, separated by periods of inactivity. Complex Event Processing (CEP): Detects patterns and correlations across multiple streams and time intervals, often used for anomaly detection and predictive analytics. 4. Applications of the Stream Data Model in Big Data Analytics The stream data model is applied across industries for real-time decision-making and responsive actions, including:\n==Financial Services==: Fraud detection, high-frequency trading, real-time risk assessment. ==IoT and Sensor Analytics==: Monitoring and analyzing data from connected devices, such as temperature readings, GPS coordinates, and machine telemetry, to detect anomalies and trigger alerts. ==Social Media and Customer Sentiment Analysis==: Monitoring user activity and sentiment on platforms like Twitter and Facebook to identify trends, public sentiment, or breaking news. ==E-commerce and Retail==: Real-time recommendation engines, dynamic pricing, and personalized offers based on customer behavior. ==Operations and System Monitoring==: Real-time monitoring of logs and system metrics for IT infrastructure and network performance. 5. Advantages of the Stream Data Model Low Latency: Enables instant insights and actions, crucial for applications like fraud detection and operational monitoring. Scalability: Stream processing systems can handle large volumes of data, often using distributed systems to achieve scalability. Resource Efficiency: Stream processing avoids storing all incoming data, focusing on immediate analysis and reducing storage costs. Adaptability: Designed to handle various types of data formats and sources, from structured logs to unstructured social media data. 6. Challenges in the Stream Data Model Data Consistency: Ensuring consistent processing of out-of-order or delayed events can be challenging. Fault Tolerance: Real-time systems must be resilient to failures, which often requires complex, distributed recovery mechanisms. Scalability and Performance: Managing the high throughput and velocity of data streams requires resources, careful system design, and potentially distributed computing. Window Management: Determining the appropriate window size for analysis can impact performance and accuracy. 7. Tools and Technologies for Stream Processing Several tools and technologies support the stream data model, each optimized for specific use cases:\nMessage Brokers for Data Ingestion: Apache Kafka, Amazon Kinesis, RabbitMQ Stream Processing Frameworks: Apache Flink (for low-latency processing), Apache Spark Streaming (integrated with Spark), Apache Storm (for complex event processing), and Google Dataflow (for cloud-native stream processing). Visualization and Alerting: Tools like Grafana and Kibana are often integrated with stream processing pipelines to visualize and alert based on real-time metrics and insights. Data Stream Management System A Data Stream Management System (DSMS) is a ==specialized system for managing and processing continuous data streams in real time==. Unlike ==traditional databases, which store static data and respond to periodic queries==, a DSMS handles transient data that arrives in a ==continuous, unbounded flow==. This makes it ideal for applications that need to ==process and analyze high-velocity data==, such as IoT applications, financial trading systems, network monitoring, and real-time analytics.\n1. Core Functions and Purpose of a DSMS Continuous Query Processing: DSMSs support continuous queries, which are persistent queries that automatically run as data flows through the system, providing updated results in real-time. Real-Time Processing: DSMSs process data with minimal delay to deliver insights almost instantaneously, making them suitable for time-sensitive applications. Transient Data: Data in a DSMS is often processed on-the-fly, meaning it may not be permanently stored. Instead, it is analyzed, acted upon, or discarded after processing. Event-Based Architecture: DSMSs operate in an event-driven manner, where each data point or event triggers processing steps according to predefined rules or queries. 2. Architecture of a DSMS A typical DSMS architecture includes the following components:\nData Sources: The input streams generated by various sources, such as IoT devices, sensors, social media feeds, application logs, and transaction records. Data Stream Ingestion Layer: A layer responsible for capturing and ingesting data streams. This often includes message brokers like Apache Kafka or Amazon Kinesis that handle high-throughput data ingestion. Stream Processing Engine: The ==core component== that processes data streams in real time. It ==executes continuous queries==, performs computations, applies transformations, and supports operations like filtering, aggregation, and joining. Query Processor: ==Manages and optimizes the execution of continuous queries==. The query processor interprets incoming data against active queries and outputs the relevant results. Windowing Mechanism: Since streaming data is unbounded, DSMSs use windowing to segment data into manageable chunks (e.g., time-based, count-based, or session-based windows) for more efficient processing. Storage (Optional): Some DSMSs incorporate temporary or permanent storage for buffering, logging, or archiving, allowing historical analysis or hybrid processing of historical and real-time data. Output and Action Layer: Sends the results of stream processing to other systems, dashboards, or applications, triggering actions, alerts, or responses. 3. Key Features of a DSMS Support for Continuous Queries: Continuous queries allow users to define processing rules that execute as new data flows in, unlike traditional SQL, which operates on static datasets. Windowing Support: Allows partitioning of streams into smaller subsets based on time, count, or events, enabling aggregation and analysis of data in near-real-time segments. Scalability: DSMSs are designed to scale horizontally, processing large volumes of data across distributed nodes to handle high-velocity data streams. Fault Tolerance: Ensures that data processing is resilient to failures, using techniques like checkpointing and data replication for reliable operation. Low Latency: DSMSs are optimized for minimal processing delay to support applications where real-time decisions are critical. 4. Processing Models in a DSMS DSMSs commonly use a few distinct processing models to handle streaming data:\nStateless Processing: Each event is processed independently without reference to past data. This model is fast and resource-efficient, suitable for filtering, transformations, and basic event processing. Stateful Processing: Requires maintaining a state across events, such as tracking counts, calculating averages, or maintaining session information. Stateful processing is essential for operations like running totals or detecting patterns over time. Window-Based Processing: Data streams are divided into \u0026ldquo;windows\u0026rdquo; to aggregate data over fixed intervals, such as every minute or hour, or based on a count of events. Complex Event Processing (CEP): This advanced model identifies patterns, correlations, or conditions across multiple streams or time intervals, such as detecting fraud by recognizing unusual transaction patterns across accounts. 5. Examples of DSMS Platforms Apache Flink: A stream-processing framework with a powerful stateful and low-latency engine. Flink supports complex event processing, windowing, and fault tolerance, making it suitable for large-scale real-time analytics. Apache Spark Streaming: An extension of Apache Spark that performs stream processing in micro-batches. It offers scalability and integrates with the broader Spark ecosystem for hybrid batch-stream processing. Apache Storm: A real-time stream processing system that provides reliable, distributed processing and is often used for low-latency processing needs. Amazon Kinesis Data Analytics: A managed service on AWS that enables real-time analytics on streaming data, integrating with Kinesis Data Streams and other AWS services. Google Dataflow: A fully managed stream processing service that provides real-time data processing capabilities, based on Apache Beam, for both batch and streaming data. 6. Use Cases of DSMS The DSMS is useful in any scenario where immediate action on data is necessary. Key use cases include:\nReal-Time Fraud Detection: Financial institutions use DSMSs to analyze transaction data streams for unusual patterns and detect fraud in real time. IoT and Sensor Data Monitoring: DSMSs process data from IoT devices and sensors to monitor environments, machines, or infrastructure, enabling predictive maintenance and quick responses to anomalies. Network Monitoring and Security: DSMSs are deployed to monitor network traffic, detect intrusions, and respond to security threats based on patterns in real-time. Personalized Recommendations: E-commerce platforms use streaming data from user behavior to update recommendations dynamically, providing users with up-to-date, relevant suggestions. Social Media Analytics: Real-time analysis of social media streams to detect trends, measure sentiment, and track public reactions to events. 7. Benefits of Using a DSMS Real-Time Decision Making: By providing immediate insights, DSMSs enable quick, informed actions in critical applications. Efficient Processing of High-Velocity Data: DSMSs are optimized to handle high-throughput data streams, avoiding the need to store and batch-process large volumes of data. Scalability and Flexibility: DSMSs can scale horizontally, often distributed across multiple nodes, to manage large and variable data volumes effectively. Cost Efficiency: Processing data as it arrives reduces the need for long-term storage and allows organizations to manage only the essential data they need. 8. Challenges of DSMS Complexity in Managing State: For stateful applications, ensuring accurate state management, especially in the event of node failures or restarts, can be challenging. Latency Sensitivity: Maintaining low latency while ensuring reliability and scalability is complex, especially in distributed environments. Scalability and Resource Usage: As data volumes grow, scaling a DSMS to meet performance requirements without excessive resource use requires careful architecture and tuning. Data Consistency: Ensuring consistency and reliability when processing high-velocity, distributed data streams can be technically challenging. Difference between DSMS and DBMS Data Stream Management System (DSMS) Database Management System (DBMS) Handles ==continuous==, ==unbounded== data streams Manages ==static==, ==finite==, and ==persistent== data Often transient (data may not be ==stored permanently==) Persistent storage with structured tables or collections ==Real-time== or near real-time processing ==Batch processing== or on-demand querying ==Continuous queries== that process incoming data instantly ==Ad-hoc or scheduled queries== on stored data Designed for ==low-latency, real-time analytics== Typically ==higher latency compared== to DSMS ==Event-driven==; processes data as it arrives ==Query-driven==; data is accessed when requested by a user ==Stateful== processing with complex event handling Primarily uses ==CRUD operations== for state management ==Flexible schema;== often schema-less or semi-structured ==Structured schema==, usually predefined (e.g., tables, columns) Real-time analytics, fraud detection, IoT monitoring Transactional systems, long-term storage, historical analysis Apache Flink, Apache Kafka Streams, Amazon Kinesis MySQL, PostgreSQL, Oracle, MongoDB Typically ==horizontal scaling==, suited for distributed data Both ==vertical and horizontal scaling==, often within ==clusters== Supports ==time-based, count-based, and session windows== No ==native support for windowing in traditional DBMSs== Provides ==recovery and checkpointing== for stream processing ==Ensures ACID compliance== and data integrity Eventual ==consistency often prioritized== ==Strong consistency== (ACID properties in relational DBMSs) Processes data on-the-fly, reducing storage requirements Requires disk space for all stored data, increasing resource use Stream Queries Stream Queries are a type of query specifically ==designed to process and analyze continuous, real-time data streams rather than static datasets==. In a data stream management system (DSMS) or a real-time data processing framework, stream queries run continuously, evaluating incoming data as it arrives. This is different from traditional database queries, which operate on finite datasets and return a single result set upon completion.\nKey Characteristics of Stream Queries Continuous Execution: Stream queries are ==persistent and execute continuously==, producing updated results in real time as new data flows in.\nReal-Time Results: Stream queries are optimized to provide results with minimal latency, enabling real-time insights and actions.\nEvent-Driven Processing: Each data point (or event) triggers an evaluation of the query. Stream queries can act on each event or group events based on conditions such as time windows.\nWindowing: Since stream data is unbounded, stream queries use windowing mechanisms (time-based, count-based, or session-based windows) to break data into finite chunks for easier processing and analysis.\nStateless and Stateful Processing: Stream queries may be stateless, processing each event independently, or stateful, where they keep track of information across events (e.g., counting occurrences, calculating averages over time).\nTypes of Stream Queries Filtering: Extracts specific events based on conditions. For instance, monitoring all user login events where login attempts exceed a threshold.\nAggregation: Calculates metrics such as count, sum, average, or max over a sliding or tumbling window. Useful for metrics like \u0026ldquo;average temperature over the past 5 minutes.\u0026rdquo;\nJoining Streams: Combines data from multiple streams, often with a time constraint, to create relationships between data points from different sources.\nPattern Matching: Identifies complex patterns across events, commonly used in fraud detection or anomaly detection.\nUse Cases of Stream Queries Real-Time Analytics: Monitoring business metrics like order volume, active users, or website traffic. Fraud Detection: Identifying unusual transaction patterns or login attempts by continuously evaluating transaction data streams. IoT Monitoring: Analyzing sensor data for threshold breaches or anomalies in environmental conditions. Customer Engagement: Providing dynamic, personalized content and recommendations based on real-time user behavior. Benefits of Stream Queries Immediate Insights: Enable organizations to take real-time actions based on live data. Scalability: Stream queries scale horizontally, processing data as it arrives. Reduced Data Storage: They often reduce the need for extensive storage by processing data on-the-fly and only storing results or significant events. Sampling techniques for efficient stream processing 1. Sliding Window This is the simplest and most straightforward method. A first-in, first-out (FIFO) queue with size n and a skip/sub-sampling factor k ≥1 is maintained. In addition to that, a stride factor s ≥ 1 describes by how many time-steps the window is shifted before analyzing it.\nSliding Window (Image by Author).\nAdvantage\nsimple to implement deterministic — reservoir can be filled very fast from the beginning Drawbacks\nthe time history represented by the reservoir R is short; long-term concept drifts cannot be detected easily — outliers can create noisy analyses 2. Unbiased Reservoir Sampling A reservoir R is maintained such that at time t \u0026gt; n the probability of accepting point x(t) in the reservoir is equal to n/t.\nThe algorithm [1] is as follows:\nFill the reservoir R with the first n points of the stream. At time t \u0026gt; n replace a randomly chosen (equal probability) entry in the reservoir R with acceptance probability n/t. This leads to a reservoir R(t) such that each point x(1)…x(t) is contained in R(t) with equal property n/t.\nAdvantages\nThe reservoir contains data points from all history of the stream with equal probability. Very simple implementation; adding a point requires only O(1) Drawbacks\nA concept drift cannot be compensated; the oldest data point x(1) is equal important in this sampling technique as the latest data point x(t). 3. Biased Reservoir Sampling In biased reservoir sampling Alg. 3.1, [2] the probability of a data point x(t) being in the reservoir is a decreasing function of its lingering time within R. So the probability of finding points of the sooner history in R is high. Very old data points will be in R with very low probability.\nIllustration of the Biased Reservoir Sampling (Image by Author)\nThe probability that point x(r) is contained in R(t) equals to\nThe example from the github.com\\andremueller\\goservoir package shows the lingering time of a stack of unbiased reservoir samplers.\nReservoir Sampling Chain output (Image by Author)\nAdvantages:\nO(1) algorithm for adding a new data point. Slowly moving concept drifts can be compensated. An adjustable forgetting factor can be tuned for the application of interest. Drawbacks:\nIt is a randomized technique. So the algorithm is non-deterministic. However, the variance might be estimated by running an ensemble of independent reservoirs [3] 4. Histograms A histogram is maintained while observing the data stream. Hereto, data points are sorted into intervals/buckets\n![\\ell_i,u_i)\nIf the useful range of the observed values is known in advance, a simple vector with counts and breakpoints could do the job.\nV-optimal histograms tries to minimize the variance within each histogram bucket. [4] proposes an algorithm for efficiently maintaining an approximate V-optimum histogram from a data stream. This is of relevance for interval data, such as a time-series of temperature values; i.e., absolute value and distance between values have a meaning.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/big-data-analysis/module-4/1.-mining-data-streams/","title":"module 4 1  Mining Data Streams"},{"content":"Syllabus Distance Measure: In big data analysis, distance measures are used to ==calculate the similarity or dissimilarity between data points==, which is ==essential== in tasks like ==clustering, classification, anomaly detection, and recommendation systems==. The selection of a distance measure depends on the type of data (numerical, categorical, text, etc.) and the application. Here are some common distance measures and their use cases:\n1. Euclidean Distance Formula: $d(x,y)= \\sqrt{\\sum_{i=1}^n (x_i - y_i)^2}$ Use Case: Commonly ==used in clustering algorithms== (e.g., ==K-means== ==clustering==) and nearest neighbor methods. It works well for numerical, continuous data. Properties: Measures the \u0026ldquo;straight-line\u0026rdquo; distance between two points in Euclidean space. It is sensitive to scale, so data normalization is often needed. 2. Cosine Similarity (Cosine Distance) Formula: $similarity(x,y) = \\frac{x \\cdot y}{|x| |y|}​$ Cosine Distance: d(x,y) = 1 − cosine similarity Use Case: Widely used in text mining and document similarity, especially with sparse vectors (e.g., TF-IDF vectors in natural language processing). Properties: Measures the cosine of the angle between two vectors, making it useful when only the direction (not the magnitude) of vectors matters. 3. Jaccard Similarity (Jaccard Index) Formula: $Jaccard(A,B) = \\frac{|A \\cap B|}{|A \\cup B|}​$ Jaccard Distance: $d(A,B)=1−Jaccard(A,B)$ Use Case: Commonly used in categorical data, binary attributes, and set-based data (e.g., user-item preferences in recommendation systems). Properties: Measures the similarity between two sets as the ratio of their intersection to their union. 4. Hamming Distance Formula: Use Case: Used for categorical or binary data, especially for text comparison (e.g., in DNA sequencing, error detection/correction). Properties: Counts the number of differing elements between two strings of equal length. Suitable for comparing categorical data or binary feature vectors. 5. Edit Distance (Levenshtein Distance) Formula: The minimum number of edits (insertions, deletions, substitutions) needed to transform one string into another. Use Case: Common in text and DNA sequence analysis, spell-checking, and natural language processing. Properties: Measures the dissimilarity between sequences; useful in cases where sequence order is important. CURE ALGORITHM (Clustering using algorithm) The CURE (==Clustering Using Representatives==) algorithm is a ==hierarchical clustering algorithm== designed to ==handle large datasets== and ==address some limitations of traditional clustering methods, particularly with irregularly shaped clusters and large variations in cluster sizes==. Developed to be efficient for big data, CURE is especially useful in cases where other clustering algorithms (like K-means) might fail due to assumptions about cluster shapes or sizes.\nKey Features of CURE ==Multiple Representative Points==: CURE uses multiple points to represent each cluster, not just a centroid or a single average point. This approach makes it more resilient to different shapes and scales in data.\nScalability: By using random sampling and partitioning strategies, CURE can scale well with large datasets, a necessity in big data contexts.\n==Hierarchical Approach==: CURE is an agglomerative (bottom-up) hierarchical clustering algorithm. It initially treats each data point as an individual cluster and iteratively merges clusters based on the distance between their representative points.\nHandling Outliers: CURE is ==effective in handling outliers and noise due to its use of representative points==. Outliers do not unduly influence cluster centroids or shapes.\nCURE Algorithm Steps in Detail Here\u0026rsquo;s a step-by-step description of the CURE algorithm:\nStep 1: Data Sampling Since working with the full dataset may be computationally intensive, CURE ==first randomly samples a subset of the dataset==. This sampling reduces computation while preserving the general structure of the clusters. Step 2: Initial Clustering (Partitioning) The algorithm then ==partitions the sampled data into smaller subsets==, each containing a manageable number of points. Each ==subset is clustered individually using a fast hierarchical== clustering method (like ==agglomerative clustering==) until the subset size is reduced to a target number of clusters. This step allows CURE to quickly produce an initial set of clusters, making it feasible to process large datasets. Step 3: Selecting Representative Points For each cluster created in the initial clustering phase, CURE selects a set of points called ==representative points== to capture the geometry and distribution of the data points in that cluster. The algorithm typically chooses these points by selecting a number of data points farthest away from the cluster\u0026rsquo;s centroid. The exact number of representative points is a parameter of the algorithm. Shrinkage: Each representative point is then “shrunk” or moved closer to the cluster\u0026rsquo;s centroid by a certain factor. This shrinkage factor is another parameter of the algorithm, which helps reduce the impact of outliers. Step 4: Hierarchical Clustering on Representative Points CURE applies an ==agglomerative hierarchical clustering== method to merge clusters based on the distances between their representative points. In each iteration, CURE merges the two clusters that have the closest pair of representative points (measured by ==Euclidean distance==). This process continues until a desired number of clusters is achieved or the minimum distance between clusters exceeds a specified threshold. Step 5: Assigning Non-Sampled Points to Clusters After the main clustering is complete, the remaining (non-sampled) data points are assigned to the nearest cluster based on the distance to the representative points of each cluster. This step ensures that the entire dataset is clustered, not just the initial sample. Parameters of the CURE Algorithm Number of Representative Points (k): The number of points chosen to represent each cluster. More representative points result in a better approximation of the cluster shape but increase computational complexity.\nShrinkage Factor $( \\alpha )$: A value between 0 and 1 that determines how much each representative point is moved toward the cluster centroid. A higher shrinkage factor reduces the influence of outliers.\nNumber of Clusters (c): The final number of clusters desired. This parameter can also be based on a threshold distance to control when the clustering process stops.\nAdvantages of CURE Flexibility with Cluster Shapes: CURE handles irregularly shaped clusters better than centroid-based algorithms like K-means, thanks to its use of multiple representative points.\nReduced Impact of Outliers: The shrinkage factor helps mitigate the effect of outliers on cluster shapes.\nScalability: The use of random sampling and partitioning helps CURE scale efficiently for large datasets.\nHierarchical Structure: As a hierarchical method, CURE provides a structure that allows for easy interpretation and visualization of the data hierarchy, which is useful for exploring data patterns.\nLimitations of CURE Parameter Sensitivity: The performance and results of CURE are sensitive to the values of parameters like the number of representative points and shrinkage factor. Finding the optimal parameters can require experimentation.\nComputational Complexity: Although it is optimized for large datasets, CURE still involves multiple clustering steps, which can be computationally intensive for extremely large datasets if sufficient resources aren’t available.\nMemory Requirements: The algorithm needs to store multiple representative points for each cluster, which can consume significant memory when handling a large number of clusters or representative points.\nExample of CURE Algorithm in Action Imagine a dataset with two large clusters shaped like \u0026ldquo;donuts\u0026rdquo; and one small spherical cluster. Traditional methods might have difficulty distinguishing these shapes because of how they represent clusters with a single centroid.\nUsing CURE:\nSampling and Partitioning: CURE randomly samples the dataset and partitions it into manageable subsets.\nInitial Clustering: Each subset is clustered hierarchically to generate an initial set of small clusters.\nRepresentative Points and Shrinkage: For each initial cluster, CURE chooses a specified number of representative points spread around the cluster, then shrinks these points toward the centroid.\nAgglomerative Clustering: CURE then performs hierarchical clustering on these representative points, gradually merging clusters based on the closest pair of representative points until the desired number of clusters is reached.\nFinal Clustering: The remaining data points (not part of the sample) are assigned to the nearest final clusters.\nIn this example, CURE’s use of multiple representative points allows it to capture the donut-shaped clusters’ boundary and interior points, handling the shape complexity that other algorithms might miss.\nApplications of CURE Geospatial Data Analysis: Identifying clusters in spatial data where shapes are irregular and varied, such as in geographical location clustering.\nImage Segmentation: Separating clusters in image data, where clusters might not always have uniform shapes or sizes.\nSocial Network Analysis: Detecting communities or groups with non-uniform structures in social network data.\nMarket Segmentation: Grouping customer data where customer behavior patterns (clusters) vary significantly in shape and size.\nIn summary, CURE is a powerful clustering algorithm for large datasets with complex cluster shapes, providing flexibility and adaptability that simpler algorithms like K-means cannot offer. It achieves this through sampling, partitioning, and the innovative use of multiple representative points, making it suitable for diverse applications in big data analysis.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/big-data-analysis/module-5/1.-finding-similar-items-and-clustering/","title":"Module 5 1  Finding Similar Items and clustering"},{"content":"Syllabus Pagerank ==PageRank is a link analysis algorithm== developed by Larry Page and Sergey Brin, the co-founders of Google, to ==rank websites in search engine results==. It uses the ==link structure of the web to measure== the ==importance== or ==authority== of a webpage. A page that has many links to it, especially from other ==high-ranking pages==, is considered more important and thus receives a higher PageRank score.\nConcept of PageRank PageRank works on the principle that a page is important if many other important pages link to it. This recursive idea of importance helps rank webpages by their perceived \u0026ldquo;==authority==\u0026rdquo; in the web structure, where links are essentially treated as votes. However, links from pages that themselves are linked by many other pages carry more weight.\nPageRank is based on a random surfer model, where a \u0026ldquo;==random surfer==\u0026rdquo; starts on a page and either:\nClicks a random link on the page (following links), or Jumps to a completely random page with a certain probability. The algorithm assigns higher ranks to pages where there is a high probability that the random surfer will end up, due to both the number and quality of links pointing to it.\nMathematical Formulation of PageRank Given a web graph where pages link to each other, PageRank calculates the rank of a page ( P ) as follows:\nPageRank Formula The PageRank of page ( P ), denoted as ( PR(P) ), is defined by the following formula:\n$$PR(P) = \\frac{1 - d}{N} + d \\sum_{i=1}^{k} \\frac{PR(P_i)}{L(P_i)}$$\nWhere:\n( d ): Damping factor, usually set to 0.85. This represents the probability that the random surfer continues following links (and not jumping to a random page). ( N ): Total number of pages on the web. ( k ): Number of pages linking to ( P ). ( P_i ): A page that links to ( P ). ( PR(P_i) ): The PageRank score of page ( P_i ). ( L(P_i) ): The number of outbound links on page ( P_i ). The formula combines two parts:\nRandom Jump Probability ( \\left(\\frac{1 - d}{N}\\right) )**: This is the probability that the surfer jumps to a random page. Link Contribution ( \\left( d \\sum_{i=1}^{k} \\frac{PR(P_i)}{L(P_i)} \\right) )**: The probability that the surfer follows links from pages that link to ( P ), weighted by their PageRank and the number of links on those pages. Understanding the Components Damping Factor (d): Controls the ==likelihood of a random jump==. Setting ( d ) to ==0.85 means there\u0026rsquo;s an 85% ==chance the surfer will follow a link on a page and a 15% chance they will jump to a random page. This factor prevents \u0026ldquo;sink\u0026rdquo; pages (pages with no outgoing links) from distorting the rankings and ensures convergence of the PageRank computation.\nLink Contribution: Each page that links to page ( P ) contributes a fraction of its own PageRank to ( P ). The contribution of each linking page is divided by the number of outbound links on that page, representing that each link distributes the linking page’s PageRank equally.\nIteration and Convergence: PageRank values are computed iteratively. Starting with an initial guess (often equal values for all pages), the PageRank values are updated in each iteration using the formula until they converge (i.e., the values change very little between iterations).\nExample Calculation of PageRank Consider a small web with 3 pages, ( A ), ( B ), and ( C ), and the following link structure:\n( A ) links to ( B ) and ( C ). ( B ) links to ( C ). ( C ) links to ( A ). Assume a damping factor ( d = 0.85 ).\nInitial Values: Start with an initial PageRank of 1 for each page. Iterate using PageRank formula: Apply the formula iteratively for each page until the values converge. Each iteration might look like:\nPR(A): Based on incoming links from ( C ), PR(B): Based on incoming links from ( A ), PR(C): Based on incoming links from ( A ) and ( B ). After several iterations, the values converge to stable scores reflecting the \u0026ldquo;importance\u0026rdquo; of each page in this mini-network.\nImplementation Steps To compute PageRank for a large web graph, the following steps are typically used:\nInitialize: Assign an initial PageRank to each page, typically ( \\frac{1}{N} ) where ( N ) is the total number of pages. Iterate: For each page, update its PageRank using the contributions from all linked pages. Convergence Check: After each iteration, check if the PageRank values have converged (i.e., change by less than a predefined small threshold). Normalization: In practice, PageRank values are often normalized so that they sum up to 1. Properties of PageRank Probabilistic Interpretation: PageRank can be interpreted as the steady-state distribution of a ==Markov chain==, where each page is a state, and links represent transition probabilities. Global Ranking: PageRank provides a global ranking of pages, making it useful for ordering search results in search engines. Resilience to Manipulation: Because PageRank considers the number and quality of inbound links, it is more resilient to manipulation than simpler ranking methods based solely on the number of links. Applications of PageRank ==Search Engines==: Initially used by Google to rank web pages, PageRank remains foundational in understanding the relevance of pages to search queries. ==Social Network Analysis==: Used to find influential nodes in social networks. ==Recommendation Systems==: Applied in systems that recommend items or products based on link structures or user connections. ==Scientific Research==: Used in ranking academic papers based on citation networks. ==Bioinformatics==: For identifying important genes or proteins within networks of biological interactions. Advantages and Limitations of PageRank Advantages Quality of Results: Considers both the quantity and quality of links, providing a more nuanced and reliable metric than raw link counts. Efficient Calculation: Can be computed on very large graphs with iterative techniques. Interpretability: Has an intuitive probabilistic interpretation that relates to user behavior on the web. Limitations Computational Cost: Although efficient, computing PageRank on very large networks (like the entire web) can be resource-intensive. Spam and Manipulation: While resistant to simple link spam, sophisticated link farming and manipulative SEO techniques can still influence PageRank. Static Nature: PageRank doesn’t account for content relevance or the context of the search query itself. Modern search engines combine it with other ranking factors. Modern Modifications and Variants Personalized PageRank: A variant where the random surfer has a higher probability of jumping to pages of personal interest, often used for recommendation systems. Topic-Sensitive PageRank: This modifies the random jump to be more likely to visit pages related to a particular topic. TrustRank: A version of PageRank that prioritizes links from trusted sources, helping to reduce the influence of spammy or low-quality links. Summary PageRank is a powerful and influential algorithm that transformed how web pages are ranked in search engines by considering the structure of the web and the quality of links. Although it is only one component of modern ranking systems, its fundamental idea of \u0026ldquo;link authority\u0026rdquo; remains a central concept in web search, network analysis, and beyond. Its adaptability to various domains has made it one of the most impactful algorithms in data science and information retrieval.\nRecommendation systems Recommendation systems are essential in modern applications to help users find items of interest based on their preferences and past interactions. There are several models for recommendation systems, with content-based recommendation and collaborative filtering being two of the most widely used approaches. Let’s dive into each of these, discussing their mechanisms, strengths, limitations, and practical examples.\n1. Content-Based Recommendation Systems In content-based recommendation systems, the system recommends items that are similar to items the user has liked or interacted with in the past. These recommendations are based solely on the content or features of the items and the user’s previous behaviors or preferences.\nHow It Works Profile Creation:\nA user profile is created by analyzing items the user has previously interacted with. For example, in a movie recommendation system, if a user has watched several action movies, the system will understand that this user has a preference for the \u0026ldquo;action\u0026rdquo; genre. The profile consists of features or keywords that describe the user’s preferences. Item Representation:\nEach item is represented by a set of attributes (e.g., for a movie, attributes might include genre, director, cast, etc.). Often, TF-IDF (Term Frequency-Inverse Document Frequency) or word embeddings (like Word2Vec or BERT) are used to represent the content of textual data in numerical form. Matching:\nThe system recommends items that are similar to the user profile by calculating the similarity between item features and the user profile. Cosine similarity and Euclidean distance are common measures used to find items similar to those the user liked before. Strengths of Content-Based Recommendations Personalized Recommendations: It can provide recommendations specific to individual preferences. No Cold Start for Items: New items can be recommended as long as they have content features, making it ideal for recommending newly added items. Limitations of Content-Based Recommendations Limited Discovery: The system can’t recommend items outside the user’s interests, leading to a “filter bubble” effect. Feature Engineering Requirement: It requires well-defined and relevant item features, which can be challenging for complex items. Example of Content-Based Recommendation A news website might use a content-based recommendation system to suggest articles based on a user’s reading history. If a user often reads articles tagged \u0026ldquo;technology\u0026rdquo; and \u0026ldquo;startups,\u0026rdquo; the system will recommend more articles with similar tags.\n2. Collaborative Filtering Collaborative filtering makes recommendations based on the behavior and preferences of other users. It doesn’t rely on the content of the items but instead finds patterns in the interactions between users and items.\nThere are two main types of collaborative filtering:\nUser-Based Collaborative Filtering Item-Based Collaborative Filtering A. User-Based Collaborative Filtering This approach recommends items that users with similar preferences liked in the past.\nHow It Works:\nIdentify Similar Users: Find users who have similar preferences by analyzing user-item interactions (like ratings or clicks). Recommend Items: Once similar users are identified, items that those similar users liked and that the active user hasn’t interacted with are recommended. Example: If User A and User B have similar tastes, items that User B liked but User A hasn’t seen can be recommended to User A.\nB. Item-Based Collaborative Filtering In item-based collaborative filtering, the algorithm recommends items that are similar to items the user has already liked.\nHow It Works:\nIdentify Similar Items: Calculate similarities between items based on user interactions. Recommend Based on Similarity: Recommend items similar to those the user has already interacted with. Example: In an e-commerce setting, if a user bought or viewed a specific product, the system recommends similar products that other users viewed or purchased in addition to the original product.\nCollaborative Filtering Algorithm (Matrix Factorization) One common approach for collaborative filtering is matrix factorization, specifically Singular Value Decomposition (SVD) or Alternating Least Squares (ALS). Matrix factorization techniques decompose the user-item interaction matrix into two smaller matrices, representing latent factors for users and items. This factorization captures hidden patterns and similarities that can be used for recommendation.\nSteps:\nCreate a User-Item Matrix: Each cell represents a user’s rating or interaction with an item. Decompose the Matrix: Use SVD to factorize the matrix into two matrices representing user and item latent factors. Predict Interactions: Reconstruct the matrix by multiplying these latent matrices to predict missing interactions. Strengths of Collaborative Filtering Does Not Rely on Item Features: Works purely on user interactions, making it applicable across domains. Potential for Discovery: Recommends items outside of the user’s known interests, leading to serendipitous discovery. Limitations of Collaborative Filtering Cold Start Problem: It requires historical user interactions, which makes it challenging to recommend items to new users or for new items. Sparsity: Real-world datasets are often sparse, as users interact with only a small subset of items, which can make it difficult to identify patterns. 3. Hybrid Recommendation Systems Hybrid recommendation systems combine content-based and collaborative filtering approaches to leverage the strengths of both and address their limitations.\nApproaches:\nWeighted Hybrid: Combining the scores from content-based and collaborative models. Switching Hybrid: Switching between content-based and collaborative filtering depending on the context (e.g., using content-based for new users). Feature-Augmented Hybrid: Using content features to improve collaborative filtering or vice versa. Example Models for Content-Based and Collaborative Filtering Content-Based Model Example: TF-IDF with Cosine Similarity Use TF-IDF to create a vector representation for each item (e.g., a movie or article). Calculate a user profile vector by averaging the vectors of items they liked. Recommend items by finding those with the highest cosine similarity to the user profile vector. Collaborative Filtering Model Example: Matrix Factorization (SVD) In a movie recommendation system:\nCreate a matrix of user ratings for movies. Factorize this matrix to get latent factors for users and movies. Use these factors to predict ratings for unrated movies, recommending movies with the highest predicted ratings. Practical Example of Recommendation System Consider Netflix:\nContent-Based: If a user watches several science fiction movies, the system identifies \u0026ldquo;science fiction\u0026rdquo; as a preferred genre and recommends other science fiction titles. Collaborative Filtering: Netflix also looks at what similar users have watched. If many users with similar tastes watched a particular thriller, it recommends that thriller to this user. Summary Model Description Strengths Limitations Content-Based Recommends items similar to those the user has interacted with, based on item features. Personalized, works for new items Limited discovery, requires well-defined features Collaborative Filtering Recommends items based on the interactions of similar users or similar items, without needing content. Discovers new interests, works across domains Cold start, data sparsity Hybrid Combines content-based and collaborative filtering to balance strengths and weaknesses. Addresses cold start, combines personalization with discovery Increased complexity https://www.ques10.com/p/42523/for-the-given-graph-show-how-clique-percolation--1/\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/big-data-analysis/module-6/1.-real-time-big-data-models/","title":"Module 6 1  Real-time Big Data Models"},{"content":"N-Grams are a fundamental concept in Natural Language Processing (NLP), ==representing contiguous sequences of N items (words, characters, or other tokens) from a given text or speech==. They are commonly used for tasks like text analysis, predictive modeling, and language modeling.\n1. Definition An N-Gram is a continuous sequence of NNN items extracted from a larger sequence of text.\nUnigram: Single token (e.g., word or character). Bigram: Sequence of two tokens. Trigram: Sequence of three tokens. N-Gram: General term for sequences of NNN tokens. 2. Types of N-Grams Word N-Grams:\nBased on words as tokens. Example: \u0026ldquo;I love NLP\u0026rdquo;. Unigrams: [I], [love], [NLP] Bigrams: [I love], [love NLP] Trigrams: [I love NLP] Character N-Grams:\nBased on individual characters. Example: \u0026ldquo;NLP\u0026rdquo; Unigrams: [N], [L], [P] Bigrams: [NL], [LP] Trigrams: [NLP] 4. Applications of N-Grams Language Modeling:\nPredict the next word in a sequence. Example: Given \u0026ldquo;I love\u0026rdquo;, predict \u0026ldquo;NLP\u0026rdquo; using bigrams. Text Classification:\nExtract N-Gram features for spam detection, sentiment analysis, or topic modeling. Spell Correction:\nIdentify likely corrections by analyzing N-Gram frequency in a language corpus. Machine Translation:\nImprove translation by capturing short context sequences using N-Grams. Speech Recognition:\nPredict word sequences from phoneme data. Plagiarism Detection:\nDetect similarities in text by comparing N-Grams between documents. Information Retrieval:\nEnhance search engine accuracy by matching query terms using N-Grams 5. Advantages Context Representation: Captures local context in text. Simplicity: Easy to generate and use for basic NLP tasks. Flexibility: Applicable to words, characters, or phonemes. 6. Disadvantages Curse of Dimensionality: Higher NNN values lead to exponential growth in the N-Gram space, requiring more memory and computational power. Lack of Long-Range Dependencies: Cannot capture relationships beyond the immediate NNN-length sequence. Data Sparsity: For large NNN, many N-Grams may not appear in the training data. 9. Limitations and Modern Approaches N-Grams fail to capture long-term dependencies in text. Modern models like Recurrent Neural Networks (RNNs), Transformers, and BERT handle context better by modeling entire sentences or documents rather than local N-Grams. N-Grams are foundational tools in NLP for capturing context in text data. While simple and effective for many applications, they are limited by their fixed context size and data sparsity issues, making them less effective for complex, long-range dependencies. Despite these limitations, N-Grams remain a valuable starting point for many NLP tasks.\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/n-gram/","title":"NLP n-gram"},{"content":"Part-of-Speech (POS) Tagging is a fundamental task in Natural Language Processing (NLP) ==where each word in a given text is assigned a corresponding part of speech (e.g., noun, verb, adjective) based on its definition and context==. It helps in ==understanding the grammatical structure of sentences== and is a key step in many NLP pipelines.\n1. Definition POS tagging involves:\nTokenization: Splitting the text into individual words or tokens. Tagging: Assigning a POS tag to each token based on its role in the sentence. 2. Common Parts of Speech Tags Methods **1. [[Rule-Based Tagging]] Uses a set of ==linguistic rules to assign tags==. Example rule: If a word ends in \u0026lsquo;-ing\u0026rsquo;, tag it as VBG (gerund/present participle). Limitations: Requires extensive manual rule creation. Struggles with ambiguous or complex sentences. 2. Statistical and Machine Learning Tagging Leverages probabilistic models or machine learning algorithms to predict tags based on training data. Common algorithms include: Hidden Markov Models (HMMs): Uses probabilities of word sequences and tags to determine the most likely tags. Conditional Random Fields (CRFs): Captures dependencies between tags for more accurate predictions. Neural Networks: Deep learning models like RNNs, LSTMs, and Transformers are used for context-aware tagging. 4. Applications of POS Tagging Named Entity Recognition (NER): Identifying names, dates, and other entities often requires POS information. Parsing and Syntax Analysis: Understanding sentence structures relies on POS tags. Information Retrieval: POS tagging improves search accuracy by filtering irrelevant words. Sentiment Analysis: Distinguishing between adjectives (e.g., good, bad) and other parts of speech. Machine Translation: Helps in generating grammatically correct translations. 5. Challenges in POS Tagging Ambiguity: Words with multiple meanings or usages. Example: \u0026ldquo;Book a table\u0026rdquo; vs. \u0026ldquo;Read a book\u0026rdquo; (verb vs. noun). Out-of-Vocabulary Words: Handling rare or unseen words in the training data. Complex Sentence Structures: Nested clauses and long dependencies. Domain-Specific Language: Scientific, legal, or technical jargon may need specialized models. ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/part-of-speech-pos-tagging/","title":"NLP Part-of-Speech (POS) Tagging"},{"content":"The Porter Stemmer is one of the most commonly used stemming algorithms in Natural Language Processing (NLP). Developed by ==Martin Porter== in 1980, it ==reduces words to their stem (root form) by systematically removing suffixes== ==according to a set of predefined rules.==\nThe Porter Stemmer is a ==rule-based stemming algorithm== that applies ==heuristic rules== to strip affixes (e.g., -ing, -ly, -ed) from words. It aims to ==retain the base meaning== of a word while ==discarding inflectional and derivational endings==. Characteristics** Rule-based: Uses a series of suffix-removal rules in sequential steps. Linguistically naive: Does not consider linguistic rules or word context. Produces stems that may not be valid words: For example, \u0026ldquo;relational\u0026rdquo; → \u0026ldquo;relat\u0026rdquo;. Language-specific: Primarily designed for English but has inspired similar algorithms for other languages. steps in the Porter Stemming Algorithm The algorithm works in five sequential steps, each targeting specific types of suffixes. Each step includes a set of rules, applied iteratively.\nStep 1: Handle Plural and Past Tense Endings Remove common suffixes like -s, -es, -ed, and -ing. Example: caresses → caress ponies → poni hopping → hop Step 2: Convert Suffixes to Simplified Forms Handle suffixes like -ational, -tional, and -enci. Example: relational → relate conditional → condition Step 3: Remove Derivational Suffixes Handle suffixes like -icate, -ative, and -alize. Example: formative → form rationalize → rational Step 4: Remove Further Suffixes Remove endings like -al, -ance, and -ness. Example: formal → form goodness → good Step 5: Tidy Up Final Words Remove -e or adjust endings for better stem consistency. Example: probate → probat rate → rate Strengths of the Porter Stemmer Simplicity: Easy to implement due to straightforward rule-based design. Efficiency: Processes words quickly, suitable for large text corpora. Widely Used: A standard for many NLP tasks, such as search engines, sentiment analysis, and information retrieval Limitations of the Porter Stemmer Over-Stemming: Sometimes removes too much of the word, leading to unrelated stems. Example: \u0026ldquo;universal\u0026rdquo; → \u0026ldquo;univers\u0026rdquo;. Under-Stemming: Fails to recognize related forms of a word. Example: \u0026ldquo;organization\u0026rdquo; and \u0026ldquo;organize\u0026rdquo; are not stemmed to the same root. Language-Specific: Designed for English; not directly applicable to other languages. Lack of Context Awareness: Operates solely on rules, ignoring word meanings or sentence context. 7. Applications of Porter Stemmer Search Engines: Normalize words for better indexing and query matching. Example: Queries like \u0026ldquo;running\u0026rdquo; and \u0026ldquo;ran\u0026rdquo; can match the same documents. Text Mining: Group words with similar roots for analysis. Sentiment Analysis: Helps in processing variants of opinion words (e.g., \u0026ldquo;happy\u0026rdquo;, \u0026ldquo;happily\u0026rdquo;, \u0026ldquo;happiness\u0026rdquo;). Document Clustering: Identifies related words for grouping similar documents. ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/porter-stemmer/","title":"NLP Porter Stemmer"},{"content":"Definition:\nPragmatics in natural language processing (NLP) ==refers to the study and interpretation of the intended meaning of language in context,== ==considering factors like speaker intentions, social norms, and situational nuances==. It goes beyond the literal meanings (semantics) of words and phrases to understand what the speaker truly means.\nKey Aspects of Pragmatics in NLP Dexies Words whose meaning depends on the speaker’s context, such as time, place, or identity. Examples: Person Deixis: \u0026ldquo;I,\u0026rdquo; \u0026ldquo;you.\u0026rdquo; Spatial Deixis: \u0026ldquo;Here,\u0026rdquo; \u0026ldquo;there.\u0026rdquo; Temporal Deixis: \u0026ldquo;Now,\u0026rdquo; \u0026ldquo;then.\u0026rdquo; Politeness and Social Norms:\nPragmatics considers how language is used to adhere to social norms, maintain relationships, or express politeness. Example: Indirect speech like \u0026ldquo;Would you mind\u0026hellip;?\u0026rdquo; is often used for politeness. Ambiguity Resolution:\nResolves ambiguities by considering context and pragmatic clues. Example: \u0026ldquo;I saw her duck\u0026rdquo; could mean observing a bird or someone lowering their head. ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/pragmatics/","title":"NLP pragmatics"},{"content":"Rule-Based POS Tagging is a traditional approach in Natural Language Processing (NLP) that assigns part-of-speech tags to words based on a set of handcrafted linguistic rules. These rules are created using grammatical patterns and word properties, such as word endings, prefixes, and surrounding context.\n1. Definition Rule-based POS tagging is a method that uses:\nLexical Knowledge: Predefined dictionaries (lexicons) containing words and their possible POS tags. Linguistic Rules: Manually defined rules based on syntax, morphology, and word context to assign the most appropriate tag. 2. Steps in Rule-Based POS Tagging 1. Tokenization Split the input text into tokens (words or punctuation marks). Example: \u0026ldquo;The dog barks loudly.\u0026rdquo; → [The, dog, barks, loudly, .] 2. Lexicon Lookup Use a lexicon or dictionary to determine possible tags for each token. Example: The: [Determiner (DT)] dog: [Noun (NN)] barks: [Verb (VBZ), Noun (NNS)] loudly: [Adverb (RB)] 3. Rule Application Apply linguistic rules to refine and disambiguate tags based on the word\u0026rsquo;s role in the sentence. Rules consider: Morphological patterns (e.g., suffixes like -ed, -ing). Context (neighboring words and their tags). Positional rules (e.g., determiners are often followed by nouns). 4. Final Tagging After applying rules, the algorithm assigns the most likely POS tag to each word. 3. Example of Rule-Based POS Tagging Input Sentence: \u0026ldquo;The dog barks loudly.\u0026rdquo;\nProcess: Tokenization: [The, dog, barks, loudly, .] Lexicon Lookup: The → [DT] Dog → [NN] Barks → [VBZ, NNS] Loudly → [RB] Rule Application: Rule: If a word follows a determiner (DT) and is not a verb, tag it as a noun (NN). Apply to dog: [NN]. Rule: If a word ends in \u0026rsquo;s\u0026rsquo; and is preceded by a noun, tag it as a verb (VBZ) if no verb exists earlier in the clause. Apply to barks: [VBZ]. Rule: If a word ends with \u0026rsquo;ly\u0026rsquo;, tag it as an adverb (RB). Apply to loudly: [RB]. Final Tags: [The/DT, dog/NN, barks/VBZ, loudly/RB, ./.] 4. Types of Rules in Rule-Based POS Tagging 1. Morphological Rules Use word structure to assign tags. Examples: Words ending in -ly → Adverb (RB). Words ending in -ed → Past Tense Verb (VBD). 2. Syntactic Rules Consider the position and role of words in a sentence. Examples: Determiners (DT) are typically followed by nouns (NN). Verbs (VB) are preceded by pronouns (PRP) or nouns (NN). 3. Contextual Rules Resolve ambiguity based on surrounding words. Examples: \u0026ldquo;He barks\u0026rdquo; → barks = Verb (VBZ). \u0026ldquo;The barks of the tree\u0026rdquo; → barks = Noun (NNS). ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/rule-based-tagging/","title":"NLP Rule-Based Tagging"},{"content":"\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/interview/untitled/oops-in-java/2.-introduction/","title":"OOPS in Java 2  Introduction"},{"content":"\nhere we have to find two substring ( left ) a ( right ) and modify smallest substring beside \u0026ldquo;a\u0026rdquo;.\neg: h==a==ckerrank here h is the smallest substring then ckerrank\nso only modify h\nclass Main { public static String getSmallestString(String s) { char[] charArray = s.toCharArray(); boolean modified = false; for(int i =0; i \u0026lt;= charArray.length; i++){ if (charArray[i] == \u0026#39;a\u0026#39; ){ if (modified) { break; } continue; } modified = true ; charArray[i] = (char) (charArray[i] - 1); } if (!modified){ charArray[charArray.length - 1] = (char) (charArray[charArray.length - 1] - 1); } return new String(charArray); } public static void main(String[] args) { String s = \u0026#34;hackerrank\u0026#34;; String result = getSmallestString(s); System.out.println(result); } } Basic Easy questions 1. reverse a string input = hello output = olleh\nclass Main { public static void main(String[] args) { String str = \u0026#34;yash\u0026#34;; String reversed = new StringBuilder(str).reverse().toString(); System.out.println(reversed); } } 2. Check if string is Palindrome or not input: madam output: true\nclass Main { public static void main(String[] args){ String str = \u0026#34;madam\u0026#34;; String reverse = new StringBuilder(str).reverse().toString(); boolean isPlaindrome = reverse.equals(str); System.out.println(isPlaindrome); } } code 2\nclass Main { public static void main(String[] args) { String str = \u0026#34;madam\u0026#34;; // Corrected string initialization String reverse = new StringBuilder(str).reverse().toString(); // Fixed toString() method if (reverse.equals(str)) { // Compare content using equals() System.out.println(\u0026#34;The string is a palindrome.\u0026#34;); } else { System.out.println(\u0026#34;The string is not a palindrome.\u0026#34;); } } } 3. Find the first Non-Repeating Character [[hash map ]] ka concept aayega input: \u0026ldquo;swiss\u0026rdquo; output: \u0026lsquo;w\u0026rsquo;\n4. Remove special character in a string 5. Program to remove White spaces in the string 6. Remove Duplicate characters in Given string ","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/string-questions/","title":"post String Questions"},{"content":"\n","date":"2025-01-10T00:00:00Z","permalink":"http://localhost:1313/post/salary-chart-comparison/salary-in-hand-and-monthly/","title":"Salary chart comparison salary in hand and monthly"},{"content":"Haan bhai, loops ke questions interview mein kaafi common hote hain, kyunki isse tumhari logic building aur time complexity ka samajh test karte hain. Chal, kuch popular loop-based questions aur unke approaches dekhte hain:\n1. Print Patterns Question: Print this pattern:\n* ** *** **** ***** Approach: Use nested loops: Outer loop controls rows, inner loop controls columns. for (int i = 1; i \u0026lt;= 5; i++) { for (int j = 1; j \u0026lt;= i; j++) { System.out.print(\u0026#34;*\u0026#34;); } System.out.println(); } Output:\nO(n²) (Outer loop: O(n), Inner loop: O(n) for each row).\n2. Reverse a Number Question: Reverse the digits of a number (e.g., 12345 → 54321).\nApproach: Use a while loop to extract digits and reverse them. int num = 12345, reversed = 0; while (num != 0) { int digit = num % 10; reversed = reversed * 10 + digit; num /= 10; } System.out.println(reversed); Time Complexity: O(d) (where d = number of digits).\n3. Check Prime Number Question: Write a program to check if a number is prime.\nApproach: Use a loop to check divisors up to n\\sqrt{n}. boolean isPrime = true; int n = 29; for (int i = 2; i \u0026lt;= Math.sqrt(n); i++) { if (n % i == 0) { isPrime = false; break; } } System.out.println(isPrime ? \u0026#34;Prime\u0026#34; : \u0026#34;Not Prime\u0026#34;); Time Complexity: O(√n).\n4. Find the Largest and Smallest in an Array Question: Find the largest and smallest numbers in an array.\nApproach: Use a single loop to compare each element. int[] arr = {3, 5, 7, 2, 8}; int max = arr[0], min = arr[0]; for (int num : arr) { if (num \u0026gt; max) max = num; if (num \u0026lt; min) min = num; } System.out.println(\u0026#34;Max: \u0026#34; + max + \u0026#34;, Min: \u0026#34; + min); Time Complexity: O(n).\n5. Count Frequency of Each Element in an Array Question: Count the frequency of each element in an array.\nApproach: Use nested loops or a HashMap for efficient counting. int[] arr = {1, 2, 2, 3, 3, 3}; Map\u0026lt;Integer, Integer\u0026gt; frequency = new HashMap\u0026lt;\u0026gt;(); for (int num : arr) { frequency.put(num, frequency.getOrDefault(num, 0) + 1); } System.out.println(frequency); Time Complexity: O(n) (using HashMap).\n6. Find Sum of Digits of a Number Question: Find the sum of digits in a number (e.g., 123 → 1 + 2 + 3 = 6).\nApproach: Use a while loop to extract digits and sum them. int num = 123, sum = 0; while (num != 0) { sum += num % 10; num /= 10; } System.out.println(sum); Time Complexity: O(d) (where d = number of digits).\n7. Find Factorial of a Number Question: Find the factorial of a number (e.g., 5! = 5 × 4 × 3 × 2 × 1 = 120).\nApproach: Use a for loop for multiplication. int n = 5, fact = 1; for (int i = 1; i \u0026lt;= n; i++) { fact *= i; } System.out.println(fact); Time Complexity: O(n).\n8. Fibonacci Series Question: Generate the first n Fibonacci numbers.\nApproach: Use a for loop to calculate Fibonacci iteratively. int n = 10, a = 0, b = 1; System.out.print(a + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34;); for (int i = 2; i \u0026lt; n; i++) { int next = a + b; System.out.print(next + \u0026#34; \u0026#34;); a = b; b = next; } Time Complexity: O(n).\n9. Print All Pairs in an Array Question: Print all pairs of numbers from an array.\nApproach: Use nested loops to generate pairs. int[] arr = {1, 2, 3}; for (int i = 0; i \u0026lt; arr.length; i++) { for (int j = i + 1; j \u0026lt; arr.length; j++) { System.out.println(arr[i] + \u0026#34;, \u0026#34; + arr[j]); } } Time Complexity: O(n²).\n10. Check for Palindrome String Question: Check if a string is a palindrome (e.g., madam).\nApproach: Use a for loop to compare characters from both ends. String str = \u0026#34;madam\u0026#34;; boolean isPalindrome = true; for (int i = 0; i \u0026lt; str.length() / 2; i++) { if (str.charAt(i) != str.charAt(str.length() - 1 - i)) { isPalindrome = false; break; } } System.out.println(isPalindrome ? \u0026#34;Palindrome\u0026#34; : \u0026#34;Not Palindrome\u0026#34;); Time Complexity: O(n).\n11. Count Number of Words in a Sentence Question: Count the number of words in a sentence.\nApproach: Use a loop to split and count words. String sentence = \u0026#34;This is a test sentence\u0026#34;; String[] words = sentence.split(\u0026#34; \u0026#34;); System.out.println(\u0026#34;Word count: \u0026#34; + words.length); Time Complexity: O(n).\n12. Find GCD of Two Numbers Question: Find the greatest common divisor (GCD) of two numbers.\nApproach: Use a while loop with the Euclidean algorithm. int a = 56, b = 98; while (b != 0) { int temp = b; b = a % b; a = temp; } System.out.println(\u0026#34;GCD: \u0026#34; + a); Time Complexity: O(log(min(a, b))).\nBhai, inn questions ko achhi tarah practice kar lo. Interview mein loops ke alag-alag variations pooch sakte hain. Agar kisi question ka doubt ho, toh turant pooch lena! 🚀\n","date":"2025-01-04T00:00:00Z","permalink":"http://localhost:1313/post/dsa/loops-questions-for-interviews/","title":"DSA loops questions for interviews"},{"content":"[[Array list vs linked list]] [[Hashset vs Treeset]] [[Hashmap vs Treemap]] [[Leetcode]] [[Exception Handling]] [[File io operations]] [[3. Time and Space Complexity]] [[sorting in java]] ","date":"2025-01-04T00:00:00Z","permalink":"http://localhost:1313/post/dsa/super-30/","title":"DSA Super 30"},{"content":"[[Time table]] [[Interview tips]]\n[[1.Off-campus Companies to apply]]\n[[ibm]]\n[[IBM Coding Questions]]\n[[zoho]]\n[[loops questions for interviews]] Technology Companies [[React js]] [[1. HTML]] [[2. CSS]] ","date":"2025-01-04T00:00:00Z","permalink":"http://localhost:1313/post/interview/1.-interview-index/","title":"interview 1  Interview Index"},{"content":" DevOps languages Placements Projects [[1. DevOps Index]] [[Java Index]] [[1. Interview Index]] [[fusion flux]] [[Git Index]] [[SQL Index]] [[Resume Index]] [[Oopsidian]] [[1. Azure Index]] [[Project Index]] [[Docker Index]] [[0. DSA Index]] [[Shell-Scripting Index]] [[GSOC Google Summer Of Code]] [[Resume Index]] [[Project Index]] [[1. DevOps Index]] [[Git Index]] [[Docker Index]] [[Shell-Scripting Index]] [[1. Azure Index]] [[1. Interview Index]] [[0. DSA Index]] [[Java Index]] [[Git Index]] [[SQL Index]] ","date":"2025-01-04T00:00:00Z","permalink":"http://localhost:1313/post/0.-index/","title":"post 0  Index"},{"content":" Exception: An event that disrupts the normal flow of a program (e.g., divide by zero, accessing an invalid array index, etc.). Exception Handling: Process of handling runtime errors gracefully without crashing the program. try-catch Block Code that may throw an exception is written inside the try block. Exceptions are caught and handled in the catch block. try { //Code that may throw an exception } catch (ExceptionType e){ //Handling code } finally Block Used for cleanup operations, e.g., closing files or database connections. Always executed, whether an exception is thrown or not. try { // code that may throw exceoption } catch (ExceptionType e) { // Handling code } finally { // cleamup code } throw vs throws throw: Ek specific exception ko manually throw karte hain. throws: Method ke declaration mein batate hain ki ye method kaunse exception throw kar sakta hai. void myMethod() throws IOException { throw new IOException(\u0026#34;File not found\u0026#34;); } Types of Exceptions Checked Exceptions\nCompile-time pe catch karna padta hai, warna code chalega nahi. Example: IOException, SQLException. Unchecked Exceptions\nRuntime pe hoti hain, jaise NullPointerException, ArithmeticException. public class ExceptionExample { public static void main(String[] args) { try { int[] arr = {1, 2, 3}; System.out.println(arr[5]); // Error: ArrayIndexOutOfBoundsException } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\u0026#34;Invalid index accessed!\u0026#34;); } } } public class FinallyExample { public static void main(String[] args) { try { int data = 10 / 0; } catch (ArithmeticException e) { System.out.println(\u0026#34;Error: \u0026#34; + e.getMessage()); } finally { System.out.println(\u0026#34;Cleanup: Closing resources\u0026#34;); } } } throw and throws Example\nimport java.io.IOException; public class ThrowExample { static void checkFile() throws IOException { throw new IOException(\u0026#34;File not found!\u0026#34;); } public static void main(String[] args) { try { checkFile(); } catch (IOException e) { System.out.println(\u0026#34;Caught Exception: \u0026#34; + e.getMessage()); } } } ","date":"2025-01-03T00:00:00Z","permalink":"http://localhost:1313/post/dsa/exception-handling/","title":"DSA Exception Handling"},{"content":"git all permissions to perticular dir\nsudo chmod 777 .... .... .... .... 1. To Check File Size Use the ls -lh command for a human-readable file size:\nls -lh -l: Long listing format -h: Human-readable sizes (e.g., KB, MB, GB) Output Example:\n-rw-r--r-- 1 user user 4.0K Jan 3 12:00 example.txt Here, 4.0K is the size of the file.\n2. To Check Directory Size Use the du (disk usage) command:\ndu -sh [directory_name] -s: Summary of the total size -h: Human-readable format Example:\ndu -sh /home/user Output:\n2.1G /home/user This shows the total size of the directory.\n3. To See Sizes of All Files and Subdirectories To list sizes of all files and subdirectories in a directory:\ndu -h [directory_name] 4. Sort Files by Size Use ls with the -S flag to sort files by size:\nls -lSh -S: Sort by file size (largest first) -h: Human-readable 5. Check Free Disk Space To see free and used disk space:\ndf -h df: Disk space usage -h: Human-readable format Example Output:\nFilesystem Size Used Avail Use% Mounted on /dev/sda1 50G 20G 30G 40% / Let me know if you need more help with CLI commands! 🚀\n","date":"2025-01-03T00:00:00Z","permalink":"http://localhost:1313/post/devops---cloud/linux/linux-index/","title":"Linux Linux Index"},{"content":"","date":"2025-01-01T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/handwritten/","title":"Java Learning HandWritten"},{"content":"[[GeeksDirectroy]] [[Portfolio]] [[Ecomm django]] [[fusion flux]] [[My Distro Builder]] ","date":"2025-01-01T00:00:00Z","permalink":"http://localhost:1313/post/projects/1.-project-index/","title":"Projects 1  Project Index"},{"content":"","date":"2025-01-01T00:00:00Z","permalink":"http://localhost:1313/post/projects/ecomm-django/","title":"Projects Ecomm django"},{"content":"","date":"2025-01-01T00:00:00Z","permalink":"http://localhost:1313/post/projects/geeksdirectroy/","title":"Projects GeeksDirectroy"},{"content":"","date":"2025-01-01T00:00:00Z","permalink":"http://localhost:1313/post/projects/my-distro-builder/","title":"Projects My Distro Builder"},{"content":"","date":"2025-01-01T00:00:00Z","permalink":"http://localhost:1313/post/projects/portfolio/","title":"Projects Portfolio"},{"content":"[[2. Introduction]]\n","date":"2024-12-30T00:00:00Z","permalink":"http://localhost:1313/post/interview/untitled/oops-in-java/1.-index/","title":"OOPS in Java 1  Index"},{"content":"Bhai, Java ka Object-Oriented Programming (OOPs) concept ekdum basic aur important hai. Yeh samajhne ke baad programming easy aur logical lagti hai. Main ekdum ground level se, examples ke saath, saari cheezein samjhaunga. Chalo shuru karte hain!\n1. Object-Oriented Programming (OOPs) Kya Hai? OOPs ek programming paradigm hai jo objects ke upar kaam karta hai. Har object ke paas data (attributes) aur behavior (methods) hota hai. Real-Life Example: Socho tum ek Car bana rahe ho:\nAttributes: Color, model, engine power, brand, etc. Behavior: Start, stop, accelerate, brake, etc. Yeh pura ka pura OOPs ka base hai – real-world entities ko code mein model karna.\n2. 4 Pillars of OOPs OOPs ke 4 main features hain:\nEncapsulation Inheritance Polymorphism Abstraction Ab inhe examples ke saath samjhte hain.\n3. Class and Object (Base Concepts) Class: Ek blueprint ya template hoti hai jo objects banane ke liye use hoti hai. Socho Car ek class hai, aur tum isse different objects (Honda, BMW) bana sakte ho. Object: Ek instance of a class hota hai. Agar Car class hai, toh Honda ek object hoga jo attributes aur methods define karega. Code Example: class Car { // This is a class (blueprint) String brand; // Attribute int speed; // Attribute void start() { // Method System.out.println(brand + \u0026#34; is starting!\u0026#34;); } void accelerate() { System.out.println(brand + \u0026#34; is accelerating at \u0026#34; + speed + \u0026#34; km/h!\u0026#34;); } } public class Main { public static void main(String[] args) { // Creating objects Car honda = new Car(); // Object 1 honda.brand = \u0026#34;Honda\u0026#34;; honda.speed = 120; Car bmw = new Car(); // Object 2 bmw.brand = \u0026#34;BMW\u0026#34;; bmw.speed = 150; // Using methods honda.start(); // Output: Honda is starting! honda.accelerate(); // Output: Honda is accelerating at 120 km/h! bmw.start(); // Output: BMW is starting! bmw.accelerate(); // Output: BMW is accelerating at 150 km/h! } } 4. Encapsulation Data ko wrap karna aur usse hide karna. Attributes ko private banate hain aur access karne ke liye getters aur setters ka use karte hain. Encapsulation ka fayda: Data secure rehta hai. Code modular aur maintainable banata hai. Code Example: class Student { private String name; // Private attribute private int age; // Setter for name public void setName(String name) { this.name = name; } // Getter for name public String getName() { return name; } // Setter for age public void setAge(int age) { if (age \u0026gt; 0) { // Validation this.age = age; } else { System.out.println(\u0026#34;Age must be positive!\u0026#34;); } } // Getter for age public int getAge() { return age; } } public class Main { public static void main(String[] args) { Student student = new Student(); // Using setters to set data student.setName(\u0026#34;Yash\u0026#34;); student.setAge(20); // Using getters to get data System.out.println(\u0026#34;Name: \u0026#34; + student.getName()); // Output: Yash System.out.println(\u0026#34;Age: \u0026#34; + student.getAge()); // Output: 20 } } 5. Inheritance Ek class (child) doosri class (parent) se properties aur methods inherit karti hai. Use karte ho jab ek concept ya entity ke multiple variations ho. Example: Parent Class: Animal\nChild Classes: Dog, Cat\nCode Example: // Parent class class Animal { String name; void eat() { System.out.println(name + \u0026#34; is eating.\u0026#34;); } } // Child class class Dog extends Animal { void bark() { System.out.println(name + \u0026#34; is barking.\u0026#34;); } } // Child class class Cat extends Animal { void meow() { System.out.println(name + \u0026#34; is meowing.\u0026#34;); } } public class Main { public static void main(String[] args) { Dog dog = new Dog(); dog.name = \u0026#34;Tommy\u0026#34;; dog.eat(); // Output: Tommy is eating. dog.bark(); // Output: Tommy is barking. Cat cat = new Cat(); cat.name = \u0026#34;Kitty\u0026#34;; cat.eat(); // Output: Kitty is eating. cat.meow(); // Output: Kitty is meowing. } } 6. Polymorphism Many forms ka matlab hai ki same method ko alag-alag tarike se use kar sakte ho. 2 types: Compile-Time Polymorphism (Method Overloading): Same method name but different parameters. Run-Time Polymorphism (Method Overriding): Child class parent class ke method ko override karta hai. Code Example (Overloading): class Calculator { // Method 1: Add 2 numbers int add(int a, int b) { return a + b; } // Method 2: Add 3 numbers int add(int a, int b, int c) { return a + b + c; } } public class Main { public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(calc.add(10, 20)); // Output: 30 System.out.println(calc.add(10, 20, 30)); // Output: 60 } } Code Example (Overriding): class Vehicle { void start() { System.out.println(\u0026#34;Vehicle is starting.\u0026#34;); } } class Car extends Vehicle { @Override void start() { System.out.println(\u0026#34;Car is starting.\u0026#34;); } } public class Main { public static void main(String[] args) { Vehicle vehicle = new Vehicle(); vehicle.start(); // Output: Vehicle is starting. Vehicle car = new Car(); car.start(); // Output: Car is starting. } } 7. Abstraction Bas important details dikhani hain, internal implementation hide karna. Achieve karte ho: Abstract Classes Interfaces Abstract Class Example: abstract class Shape { abstract void draw(); // Abstract method (no body) void display() { System.out.println(\u0026#34;This is a shape.\u0026#34;); } } class Circle extends Shape { @Override void draw() { System.out.println(\u0026#34;Drawing a circle.\u0026#34;); } } public class Main { public static void main(String[] args) { Shape shape = new Circle(); shape.draw(); // Output: Drawing a circle. shape.display(); // Output: This is a shape. } } Interface Example: interface Animal { void sound(); // Method without body } class Dog implements Animal { public void sound() { System.out.println(\u0026#34;Dog barks.\u0026#34;); } } public class Main { public static void main(String[] args) { Animal dog = new Dog(); dog.sound(); // Output: Dog barks. } } 8. Why Use OOPs? Code Reusability: Inheritance se code reuse hota hai. Modularity: Code easily manageable hota hai (encapsulation). Flexibility: Polymorphism se same method ka alag behavior milta hai. Real-World Modeling: Real-world objects ko model karna easy hai. Final Words: Bhai, bas concepts ko clear rakh aur coding practice kar. OOPs ek bar samajh gaya toh tumhare code ka structure aur readability next level pe chali jayegi! Agar aur doubt ho, toh bata de, ek aur example ke saath samjha dunga.\n","date":"2024-12-27T00:00:00Z","permalink":"http://localhost:1313/post/interview/java-oops-in-hinglish/","title":"interview java oops in hinglish"},{"content":"Sure, let’s start preparing the Stack topic in DSA. Here’s a structured explanation of stacks, including their theory, operations, and applications. We\u0026rsquo;ll also go through implementation details step-by-step.\nWhat is a Stack? A stack is a linear data structure that follows the LIFO (Last In, First Out) principle:\nThe last element inserted into the stack is the first one to be removed. Think of a stack like a stack of plates:\nYou add plates to the top (push operation). You remove plates from the top (pop operation). Basic Operations on a Stack: Push: Add an element to the top of the stack. Pop: Remove the top element from the stack. Peek/Top: View the top element without removing it. IsEmpty: Check if the stack is empty. Size: Get the number of elements in the stack. Key Points to Remember: LIFO Principle: Last in, first out. Fixed vs. Dynamic Size: Array-based stacks are of fixed size. Linked list-based stacks can grow dynamically. Overflow/Underflow: Overflow occurs when the stack is full and you try to push. Underflow occurs when the stack is empty and you try to pop. Types of Stacks: Static Stack: Implemented using arrays. Fixed size, might cause overflow. Dynamic Stack: Implemented using linked lists. Can grow/shrink dynamically based on needs. Stack Representation (Diagram): For a stack with elements {5, 10, 15}:\nTop -\u0026gt; 15 10 5 Applications of Stack: Expression Evaluation: Infix to postfix conversion. Evaluation of postfix expressions. Backtracking: Used in recursive algorithms like maze-solving or DFS. Function Call Stack: Keeps track of function calls during recursion. Browser History: Navigate back and forth in browser tabs. Undo/Redo Operations: In text editors or IDEs. How to Implement a Stack? 1. Array-Based Stack: Code Example: class Stack { private int arr[]; private int top; private int capacity; // Constructor to initialize the stack public Stack(int size) { arr = new int[size]; capacity = size; top = -1; } // Push operation public void push(int x) { if (top == capacity - 1) { System.out.println(\u0026#34;Stack Overflow\u0026#34;); return; } arr[++top] = x; } // Pop operation public int pop() { if (top == -1) { System.out.println(\u0026#34;Stack Underflow\u0026#34;); return -1; } return arr[top--]; } // Peek operation public int peek() { if (top == -1) { System.out.println(\u0026#34;Stack is empty\u0026#34;); return -1; } return arr[top]; } // Check if stack is empty public boolean isEmpty() { return top == -1; } } 2. Linked List-Based Stack: Code Example: class Node { int data; Node next; Node(int data) { this.data = data; next = null; } } class Stack { private Node top; // Push operation public void push(int x) { Node newNode = new Node(x); newNode.next = top; top = newNode; } // Pop operation public int pop() { if (top == null) { System.out.println(\u0026#34;Stack Underflow\u0026#34;); return -1; } int data = top.data; top = top.next; return data; } // Peek operation public int peek() { if (top == null) { System.out.println(\u0026#34;Stack is empty\u0026#34;); return -1; } return top.data; } // Check if stack is empty public boolean isEmpty() { return top == null; } } Stack Problems to Practice: Easy: Reverse a string using a stack. Input: \u0026quot;abcd\u0026quot;, Output: \u0026quot;dcba\u0026quot;. Check for balanced parentheses in an expression. Input: \u0026quot;({[()]})\u0026quot;, Output: true. Medium: Next Greater Element. Input: {4, 5, 2, 10}, Output: {5, 10, 10, -1}. Sort a stack using recursion. Let me know if you want to dive deeper into any specific topic, code, or problem related to stacks!\n","date":"2024-12-25T00:00:00Z","permalink":"http://localhost:1313/post/dsa/stack/","title":"DSA Stack"},{"content":"Project Overview: GUI-Based Custom Linux Distribution Builder\nObjective To develop a cross-platform GUI-based application for Windows and Linux that allows users to create custom Linux distributions based on Debian. The application will simplify the process of OS customization, making it accessible to users with limited technical expertise while providing powerful options for advanced users.\nKey Features Frontend (User Interface) Platform: Windows and Linux. User-Friendly Design: Intuitive GUI with step-by-step configuration. Input Fields: OS Name and Version. Target Architecture (e.g., x86_64, ARM). Custom Package List (add/remove packages). Installer Type (e.g., Calamares, CLI-based). Default Wallpaper and Branding. User Accounts and Permissions. Backend (Automation and Build Process) Tooling: Uses Debian’s live-build tool to create custom distributions. Runs inside a Docker container for a consistent and isolated build environment. Automation: Converts GUI inputs into live-build configuration files. Executes the live-build process to generate ISO files. Output: A bootable custom ISO ready for deployment or testing. Target Audience Private Companies: For creating branded and secure operating systems. Developers and Sysadmins: For creating lightweight, development-focused distributions. Educational Institutions: To build OS images tailored for labs or training purposes. Hobbyists: For experimenting with Linux or creating specialized systems. Startups: To generate cloud-ready or containerized images. Development Approach 1. Research and Planning Identify key user requirements. Choose technologies for the GUI and backend. Design the application workflow and GUI layout. 2. Implementation Frontend Development: Use PyQt (Python) or Electron (JavaScript) for the GUI. Create forms for user inputs. Backend Development: Integrate Docker for managing live-build environments. Develop scripts to automate ISO generation based on user inputs. 3. Testing Test the application on both Windows and Linux platforms. Validate the generated ISOs using virtual machines and physical systems. Gather feedback from target users to refine features. Project Workflow User Interaction: User launches the GUI application. Configures OS details through an intuitive interface. Configuration Generation: User inputs are converted into live-build configuration files. ISO Build Process: The application triggers the build process inside a Docker container. Output Delivery: The user receives a bootable ISO file. Potential Enhancements Advanced Features: Role-based templates (e.g., AI/ML, IoT, Enterprise). Cloud-ready image generation for platforms like AWS and Azure. Community and Collaboration: Allow sharing of custom OS templates. Automation: Integrate with CI/CD pipelines for automated distribution builds. Monitoring and Analytics: Provide build logs and error tracking for troubleshooting. Value Proposition Simplicity: Simplifies OS creation for non-technical users. Customization: Provides granular control over the OS setup for advanced users. Scalability: Applicable for personal, educational, and enterprise use cases. Team Roles and Responsibilities Frontend Developer: Build the GUI. Ensure cross-platform compatibility. Backend Developer: Implement Docker-based live-build automation. Manage ISO generation and error handling. Tester: Test GUI functionality and ISO builds. Ensure compatibility across various devices and architectures. Project Manager: Coordinate development efforts. Gather and incorporate user feedback. Next Steps Finalize the project roadmap and milestones. Begin developing the MVP (Minimum Viable Product) with essential features. Assign roles and responsibilities to team members. Test early builds and gather feedback to refine the product. Expected Outcomes A fully functional application capable of generating custom Linux distributions. Increased accessibility to OS customization for diverse user groups. Potential for scaling and expanding the project with advanced features based on user feedback. Conclusion This project aims to revolutionize how users create and deploy custom Linux distributions, bridging the gap between technical complexity and user accessibility. By combining intuitive design with powerful backend automation, we can deliver a tool that benefits hobbyists, educators, and enterprises alike.\n","date":"2024-12-24T00:00:00Z","permalink":"http://localhost:1313/post/hackathons/gujarat/","title":"hackathons Gujarat"},{"content":"","date":"2024-12-24T00:00:00Z","permalink":"http://localhost:1313/post/interview/event-handling/","title":"interview Event Handling"},{"content":"What Are Props? In React, props (short for \u0026ldquo;properties\u0026rdquo;) are ==used to pass data from a parent component to a child component==. Props are ==read-only==, which means ==they cannot be modified by the child component; the parent controls them.==\nExample: If a parent component has some data, it can pass it to its children like this:\nfunction ChildComponent(props) { return \u0026lt;h1\u0026gt;Hello, {props.name}!\u0026lt;/h1\u0026gt;; } function ParentComponent() { return \u0026lt;ChildComponent name=\u0026#34;Amit\u0026#34; /\u0026gt;; } Here:\nThe ParentComponent passes a prop name=\u0026quot;Amit\u0026quot; to the ChildComponent. The ChildComponent accesses it using props.name. How to Pass Props to Components? Props are passed as attributes when calling a child component inside JSX. Let’s see how it works:\nExample 1: Passing Simple Data function Button(props) { return \u0026lt;button\u0026gt;{props.label}\u0026lt;/button\u0026gt;; } function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Button label=\u0026#34;Click Me\u0026#34; /\u0026gt; \u0026lt;Button label=\u0026#34;Submit\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } The Button component receives a label prop. Each Button instance gets its own label. Example 2: Passing Multiple Props function UserCard(props) { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{props.name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: {props.age}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } function App() { return ( \u0026lt;UserCard name=\u0026#34;Sita\u0026#34; age={25} /\u0026gt; ); } The UserCard component receives name and age as props. Props Are Immutable Props are ==read-only.== A child component cannot modify its own props.\nExample: If you try to modify a prop like this:\nfunction Child(props) { props.name = \u0026#34;New Name\u0026#34;; // ❌ Error: Cannot assign to read-only property return \u0026lt;h1\u0026gt;{props.name}\u0026lt;/h1\u0026gt;; } It will throw an error because React enforces that data flows in one direction (from parent to child).\nProps Drilling Props drilling occurs when you pass props through multiple layers of components, even if only the last child needs the data. It can make your code messy and hard to maintain.\nExample: function GreatGrandParent() { return \u0026lt;GrandParent message=\u0026#34;Hello from GreatGrandParent!\u0026#34; /\u0026gt;; } function GrandParent(props) { return \u0026lt;Parent message={props.message} /\u0026gt;; } function Parent(props) { return \u0026lt;Child message={props.message} /\u0026gt;; } function Child(props) { return \u0026lt;h1\u0026gt;{props.message}\u0026lt;/h1\u0026gt;; } The message prop starts in GreatGrandParent and is passed down through GrandParent and Parent before finally reaching Child. This creates unnecessary boilerplate and tightly couples components. Problems with Props Drilling Verbose Code: You need to manually pass props through intermediate components, even if they don’t need it. Tightly Coupled Components: Changes in one component can affect others. Hard to Maintain: As your app grows, managing props through multiple layers becomes cumbersome. Solutions to Avoid Props Drilling Props drilling can be avoided using state management libraries or React\u0026rsquo;s built-in tools like Context API.\n1. Using Context API The Context API allows you to share data across components without explicitly passing props through every level.\nExample with Context API:\nimport React, { createContext, useContext } from \u0026#39;react\u0026#39;; const MessageContext = createContext(); function GreatGrandParent() { return ( \u0026lt;MessageContext.Provider value=\u0026#34;Hello from GreatGrandParent!\u0026#34;\u0026gt; \u0026lt;Child /\u0026gt; \u0026lt;/MessageContext.Provider\u0026gt; ); } function Child() { const message = useContext(MessageContext); // Access context directly return \u0026lt;h1\u0026gt;{message}\u0026lt;/h1\u0026gt;; } The MessageContext is like a global state for the message value. Any component inside the Provider can access the message without drilling props. 2. Using State Management Libraries Libraries like Redux, MobX, or Zustand allow you to manage global state and share it across components without props drilling.\nWhen to Use Props and When Not To Use props when:\nThe data is specific to a child component. You need a simple and direct way to pass data. Avoid props (use Context or state management) when:\nThe same data is needed by many components at different levels. You find yourself drilling props through components that don’t use them. Summary Props:\nUsed to pass data from parent to child. Immutable (cannot be modified by the child). Accessed using props.propertyName. Props Drilling:\nPassing props through multiple layers of components. Can make code messy and harder to maintain. Avoid it by using tools like Context API or state management libraries. Bro, this should make props and props drilling crystal clear! Let me know if you want examples or more details on Context or Redux. 😊\n","date":"2024-12-24T00:00:00Z","permalink":"http://localhost:1313/post/interview/props-properties/","title":"interview Props (Properties)"},{"content":"Learning Roadmap 1. Introduction to React What is React? Why React? Benefits and Features How React differs from other frameworks (e.g., Angular, Vue) Understanding React\u0026rsquo;s Virtual DOM 2. Setting up the Environment Installing Node.js and npm Setting up a React app using create-react-app Understanding the folder structure of a React project Running the development server 3. React Basics JSX Syntax (JavaScript XML) [[React Components]] Functional Components Class Components (briefly understand, mostly outdated now) [[Props (Properties)]] Passing props to components Props drilling **4. [[State Management]] What is State? Using useState Hook Updating state and re-rendering Difference between Props and State **5. [[Event Handling]] Handling Events in React (e.g., onClick, onChange) Passing functions as props for event handling Binding event handlers 6. Conditional Rendering Rendering UI conditionally using if-else Ternary operators in JSX Short-circuit evaluation 7. Lists and Keys Rendering lists using .map() Importance of Keys in lists Dynamic list generation 8. Forms in React Controlled Components Uncontrolled Components Handling form inputs (e.g., text, checkbox, radio) Form validation 9. React Lifecycle (Optional for Functional Components) Class Components Lifecycle Methods (e.g., componentDidMount, componentDidUpdate) Comparison with Functional Components 10. React Hooks Introduction to Hooks Commonly used hooks: useState useEffect useContext Advanced Hooks: useReducer useMemo useRef 11. Context API What is Context? Creating and using a Context Avoiding Prop Drilling with Context API 12. React Router Installing React Router Basic Routing: BrowserRouter, Route, Link, and Switch Dynamic Routing (useParams) Nested Routing 13. State Management Libraries Why use state management libraries? Introduction to Redux (if needed) Redux Core Concepts (Store, Actions, Reducers) Using Redux Toolkit (modern approach) Alternative libraries: Zustand, MobX 14. APIs and Async Operations Fetching data with fetch or axios Handling async operations with useEffect Displaying loading states Error handling 15. Performance Optimization Code splitting with React.lazy and Suspense Memoization using React.memo, useMemo, and useCallback Optimizing re-renders 16. Testing in React Unit Testing with Jest Testing components with React Testing Library Writing snapshot tests 17. Deployment Building your React app for production Deploying React apps on platforms: Vercel Netlify GitHub Pages 18. Advanced Topics (Optional) Higher Order Components (HOCs) Portals in React Error Boundaries React Fragments 19. UI Libraries and Styling Styling options in React: CSS Modules Styled-components Tailwind CSS Using UI libraries like Material-UI, Ant Design, or Chakra UI 20. Real-World Projects Build small projects to practice: Todo App Weather App (using OpenWeather API) Blog or Notes App E-commerce site (basic version) ","date":"2024-12-24T00:00:00Z","permalink":"http://localhost:1313/post/interview/react-js/","title":"interview React js"},{"content":"1. What is State? In React, ==state is an object== that represents the ==dynamic data== or ==current situation== of a component. It controls the behavior and appearance of the component.\nKey Features of State: Mutable: Unlike props, the state can be changed. Component-specific: Each component manages its own state. Triggers Re-renders: ==When the state changes, React automatically re-renders the component to reflect the updated data.== Example: If you’re building a counter, the current count is stored in the state. When the user clicks a button to increment the counter, the state changes, and React updates the UI.\n2. Using useState Hook React provides the useState Hook to manage state in functional components.\nSyntax: const [state, setState] = useState(initialValue); state: Holds the current state value. setState: Function to update the state. initialValue: The initial value of the state. Example: A basic counter using useState:\nimport React, { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // Initial state is 0 return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Initial State: The counter starts at 0. Updating State: Clicking the button calls setCount(count + 1), which updates the state. Re-rendering: React automatically re-renders the component to show the updated count. 3. Updating State and Re-rendering When you update the state using setState (in functional components, via useState), React schedules a re-render of the component. During this re-render:\nThe component function is called again. The updated state value is used to render the component. Rules for Updating State: State Updates are Asynchronous: React may batch multiple state updates to optimize performance.\nsetCount(count + 1); // Does not immediately update count console.log(count); // Logs the old value To get the updated state, use a function updater:\nsetCount((prevCount) =\u0026gt; prevCount + 1); State Must Not Be Modified Directly: Never modify the state directly. Use the setState function.\n❌ Incorrect:\ncount = count + 1; // This won\u0026#39;t trigger a re-render ✅ Correct:\nsetCount(count + 1); // Triggers a re-render Example: Dynamic State function Toggle() { const [isOn, setIsOn] = useState(false); return ( \u0026lt;button onClick={() =\u0026gt; setIsOn(!isOn)}\u0026gt; {isOn ? \u0026#34;ON\u0026#34; : \u0026#34;OFF\u0026#34;} \u0026lt;/button\u0026gt; ); } The state isOn toggles between true and false whenever the button is clicked. 4. Difference Between Props and State Aspect Props State Definition Data passed from parent to child. Data managed within the component. Mutability Immutable (cannot be changed). Mutable (can be updated). Scope Controlled by the parent component. Controlled by the component itself. Triggers Re-render Does not directly trigger re-rendering. Triggers re-rendering when updated. Purpose Used to pass data to components. Used to manage dynamic data. Example to Show the Difference: function ChildComponent(props) { return \u0026lt;h1\u0026gt;{props.message}\u0026lt;/h1\u0026gt;; } function ParentComponent() { const [message, setMessage] = useState(\u0026#34;Hello\u0026#34;); return ( \u0026lt;div\u0026gt; \u0026lt;ChildComponent message={message} /\u0026gt; {/* Props */} \u0026lt;button onClick={() =\u0026gt; setMessage(\u0026#34;Hi\u0026#34;)}\u0026gt;Change Message\u0026lt;/button\u0026gt; {/* State */} \u0026lt;/div\u0026gt; ); } Props: ChildComponent receives message as a prop from ParentComponent. State: ParentComponent uses useState to manage the message. Why State Management is Important? Managing state is crucial in React apps because:\nIt allows components to react dynamically to user actions. It ensures the UI stays in sync with the underlying data. It simplifies complex applications by breaking them into smaller, manageable pieces. Summary State: Represents dynamic data managed within a component. ==Use useState in functional components.== Updating state triggers a re-render of the component. Props vs State: Props are read-only and passed from parent to child. State is mutable and specific to the component. If you want to know about global state management (like Redux or Context API), let me know! 😎\n","date":"2024-12-24T00:00:00Z","permalink":"http://localhost:1313/post/interview/state-management/","title":"interview State Management"},{"content":"[[react components hinglsih]]\nWhat Are React Components? Think of React components as the ==building blocks== of a React app. Each component is responsible for rendering a specific part of the UI (User Interface).\nExample: If your app is like a car:\nThe steering wheel is a component. The seats are components. The engine is another component. All these components come together to form the car (your app).\nTypes of React Components React has two main types of components:\nFunctional Components (Modern way):\nThey are plain JavaScript functions. Lightweight and easier to write. Use ==Hooks for managing state and lifecycle==. function Welcome() { return \u0026lt;h1\u0026gt;Welcome to React!\u0026lt;/h1\u0026gt;; } Class Components (Older way):\nThey are JavaScript classes that extend React.Component. Used for managing state and lifecycle in older React versions. class Welcome extends React.Component { render() { return \u0026lt;h1\u0026gt;Welcome to React!\u0026lt;/h1\u0026gt;; } } Modern React prefers Functional Components because they\u0026rsquo;re simpler and more powerful with Hooks.\nHow to Create a React Component? Define a Function/Class:\n==Always name the component with a capital letter (important for React to recognize it as a component).== Return JSX:\nThe component must return JSX, which is HTML-like code combined with JavaScript. function MyComponent() { return \u0026lt;div\u0026gt;This is my component!\u0026lt;/div\u0026gt;; } Use the Component:\nOnce created, a component can be reused in other components. function App() { return ( \u0026lt;div\u0026gt; \u0026lt;MyComponent /\u0026gt; \u0026lt;/div\u0026gt; ); } Props (Properties) - Passing Data to Components If you want to pass data to a component, you use props (short for properties).\nExample: Passing text to a Button component:\nfunction Button(props) { return \u0026lt;button\u0026gt;{props.text}\u0026lt;/button\u0026gt;; } function App() { return \u0026lt;Button text=\u0026#34;Click Me!\u0026#34; /\u0026gt;; } Here, text is a prop sent to the Button component, and it renders it inside the \u0026lt;button\u0026gt; tag. State - Managing Dynamic Data When a component needs to store and manage its own data that can change, you use state.\nExample: A counter app:\nimport React, { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } useState(0) initializes the state with 0. count holds the current state value. setCount updates the state. Whenever you click the button, the setCount function updates the value of count, and React re-renders the UI.\nReact Lifecycle (For Class Components) If you\u0026rsquo;re using class components, they have lifecycle methods:\nMounting (Component Loads):\ncomponentDidMount() is called after the component is rendered. Updating (Component Updates):\ncomponentDidUpdate() is called after the component’s state or props change. Unmounting (Component is Removed):\ncomponentWillUnmount() is called before the component is removed. For functional components, you use the useEffect Hook to handle lifecycle events.\nExample: A timer that updates every second:\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; function Timer() { const [seconds, setSeconds] = useState(0); useEffect(() =\u0026gt; { const interval = setInterval(() =\u0026gt; { setSeconds((prev) =\u0026gt; prev + 1); }, 1000); return () =\u0026gt; clearInterval(interval); // Cleanup }, []); return \u0026lt;p\u0026gt;Timer: {seconds} seconds\u0026lt;/p\u0026gt;; } Parent-Child Relationship in Components Components can contain other components, forming a parent-child relationship.\nfunction Header() { return \u0026lt;h1\u0026gt;Welcome!\u0026lt;/h1\u0026gt;; } function Footer() { return \u0026lt;p\u0026gt;Thanks for visiting.\u0026lt;/p\u0026gt;; } function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/div\u0026gt; ); } Here:\nHeader and Footer are child components of App. Advantages of React Components Reusability: Write a component once, reuse it everywhere. Maintainability: Break down the UI into smaller, manageable pieces. Performance: React only updates the components that need to change. Testability: Small, isolated components are easier to test. Complete Example Here’s a simple app that shows how to pass data (props) and use components:\nfunction Greeting(props) { return \u0026lt;h1\u0026gt;Hello, {props.name}!\u0026lt;/h1\u0026gt;; } function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Greeting name=\u0026#34;Amit\u0026#34; /\u0026gt; \u0026lt;Greeting name=\u0026#34;Sita\u0026#34; /\u0026gt; \u0026lt;Greeting name=\u0026#34;John\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } The Greeting component takes a name prop and displays it. The App component uses Greeting three times with different names. ","date":"2024-12-24T00:00:00Z","permalink":"http://localhost:1313/post/react-components/","title":"post React Components"},{"content":"components are reusable\nReact mein Components kya hote hain? Samjho ki React ka kaam hai web app banane ka, aur components us app ke ==building blocks== hote hain. Har ek component ek chhoti si chiz ya ek kaam ko handle karta hai.\nReal-life example: Ek car le lo. Car ka steering wheel ek component hai. Seats, ek component hai. Engine, ek aur component. Milke ye saare components ek car banate hain. Similarly, ==React app mein components milkar pura UI banate hain==.\nTypes of React Components React mein do tarah ke components hote hain:\nFunctional Components:\nYeh sirf ek ==JavaScript function== hote hain. Lightweight aur seedhe simple kaam karte hain. Modern React mein yeh zyada use hote hain. function HelloWorld() { return \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;; } Class Components:\nYeh JavaScript classes hoti hain (ES6 class syntax ka use karke). ==Purane React mein zyada use== hote the. Lifecycle methods aur state ke liye use hote hain. class HelloWorld extends React.Component { render() { return \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;; } } Naya React functional components aur ==Hooks pe zyada focus karta hai, toh functional wale ko hi samajhna zyada zaroori hai.==\nReact Component Banane ke Steps Create a Function/Class:\nFunction ko banate waqt function keyword ya arrow function ka use hota hai. Component ka naam hamesha capital letter se shuru hota hai (React ke liye ye important hai). Return JSX:\nComponent ka kaam hota hai HTML ko render karna. React mein hum JSX (JavaScript XML) ka use karte hain. JSX = HTML + JavaScript ka combination. function MyComponent() { return \u0026lt;div\u0026gt;This is my component!\u0026lt;/div\u0026gt;; } Use Component in App:\nEk baar component ban gaya, toh isko kisi aur component ke andar use kar sakte ho. function App() { return ( \u0026lt;div\u0026gt; \u0026lt;MyComponent /\u0026gt; \u0026lt;/div\u0026gt; ); } Props (Properties) - Component ko Data Do Agar tumhe ek component ko data dena ho, toh tum props ka use karte ho.\nExample: Ek button component ko text dena ho.\nfunction Button(props) { return \u0026lt;button\u0026gt;{props.text}\u0026lt;/button\u0026gt;; } function App() { return \u0026lt;Button text=\u0026#34;Click Me!\u0026#34; /\u0026gt;; } Yahan text ek prop hai, jo Button component ko mil raha hai.\nState - Component ke Andar ka Data Agar tumhe ek component ke andar data store karna ho, jo change ho sake, toh tum state use karte ho.\nFunctional component mein useState Hook ka use hota hai.\nimport React, { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Yahan:\ncount hai current state. setCount function state ko update karne ke liye. useState(0) ka matlab hai ki shuru mein state 0 hogi. Component Lifecycle (Sirf Class Components ke liye) Agar tum purane class components ka use karte ho, toh lifecycle methods zaroori hote hain.\nMounting (jab component load hota hai): componentDidMount() Updating (jab data ya state change hoti hai): componentDidUpdate() Unmounting (jab component hata diya jata hai): componentWillUnmount() Lekin Hooks ke saath lifecycle ko useEffect hook se handle karte hain. Example:\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; function Timer() { const [seconds, setSeconds] = useState(0); useEffect(() =\u0026gt; { const interval = setInterval(() =\u0026gt; { setSeconds((prev) =\u0026gt; prev + 1); }, 1000); return () =\u0026gt; clearInterval(interval); // Cleanup }, []); return \u0026lt;p\u0026gt;Timer: {seconds} seconds\u0026lt;/p\u0026gt;; } React Component Architecture Parent-Child Relationship:\nEk component ke andar doosra component ho sakta hai. function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/div\u0026gt; ); } Reusability:\nEk baar component ban gaya toh usko bar-bar use kar sakte ho. React mein Components ke Advantages Reusable: Ek baar likho, har jagah use karo. Testable: Chhoti-chhoti files, asaan testing. Readable: Code structured aur clean lagta hai. Performance: Sirf wahi components update hote hain jo zarurat hain (React ka diffing algorithm). Practical Example Ek basic app banate hain jisme tumhe React components aur props ka use dikhata hoon:\nfunction Greeting(props) { return \u0026lt;h1\u0026gt;Hello, {props.name}!\u0026lt;/h1\u0026gt;; } function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Greeting name=\u0026#34;Amit\u0026#34; /\u0026gt; \u0026lt;Greeting name=\u0026#34;Sita\u0026#34; /\u0026gt; \u0026lt;Greeting name=\u0026#34;John\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } Is example mein:\nGreeting component ko ek name prop diya ja raha hai. Alag-alag naam ke saath woh render ho raha hai. Bhai, agar abhi bhi kuch confusion ho, toh bata! Ek aur step by step samjha dunga ya code likhwa ke karwa dunga! 😎\n","date":"2024-12-24T00:00:00Z","permalink":"http://localhost:1313/post/react-components-hinglsih/","title":"post react components hinglsih"},{"content":" Startups Applied or not Zeroda Razorpay curefit postman sharechat urbancompany licious meesho nykaa swiggy zoho freshworks clevertips paytm juspay unacademy yellowai cloudSEK simpl Thoughtworks mindtree TCS WiproDigital ","date":"2024-12-23T00:00:00Z","permalink":"http://localhost:1313/post/interview/companies-to-target/","title":"interview Companies to Target"},{"content":"1. HCF \u0026amp; GCD of a number import java.util.Scanner; public class Solution { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(\u0026#34;\u0026#34;); int a = scanner.nextInt(); System.out.print(\u0026#34;\u0026#34;); int b = scanner.nextInt(); while (a != b) { if(a==0) { System.out.print(b); break; } if(b == 0) { System.out.println(a); } if ( a \u0026gt; b ) { a = a - b; } else { b = b - a; } } System.out.printla(a); scanner.close(); } } 2. Write a program to find the factorial of a number. import java.util.Scanner; public class FactorialIterative { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // Input number System.out.print(\u0026#34;Enter a number: \u0026#34;); int num = scanner.nextInt(); // Calculate factorial long factorial = 1; for (int i = 1; i \u0026lt;= num; i++) { factorial *= i; // Multiply each number } // Display result System.out.println(\u0026#34;The factorial of \u0026#34; + num + \u0026#34; is: \u0026#34; + factorial); scanner.close(); } } ","date":"2024-12-23T00:00:00Z","permalink":"http://localhost:1313/post/mathematics-for-dsa/","title":"post Mathematics for DSA"},{"content":" DSA Development 1. [[Strings and StringBuilder in java]] learn javascript [[String Questions]] react js 2. [[array question]] sql 3. [[Stack ]] 4. [[4. Patterns]] 5. Queues 6. searching 7. sorting ","date":"2024-12-23T00:00:00Z","permalink":"http://localhost:1313/post/time-table/","title":"post Time table"},{"content":" google ko apply karna hai ","date":"2024-12-23T00:00:00Z","permalink":"http://localhost:1313/post/todo/main/","title":"todo main"},{"content":"https://trailhead.salesforce.com/en/credentials/aiassociate\n","date":"2024-12-22T00:00:00Z","permalink":"http://localhost:1313/post/free-certifications/main/","title":"free certifications main"},{"content":"","date":"2024-12-22T00:00:00Z","permalink":"http://localhost:1313/post/interview/plan-for-fu/","title":"interview plan for fu"},{"content":"qBilkul bhai! Java mein String ek kaafi important topic hai. Main tujhe step-by-step String ke basics se lekar advanced concepts tak revise karwata hoon.\n1. String Introduction String ek class hai jo Java mein java.lang.String package ka part hai. String ko immutable bola jata hai, iska matlab hai ek baar string banne ke baad usko change nahi kar sakte. String ko ya to String literals ke through ya phir new keyword se create karte hain. Example:\n// Using String literal String str1 = \u0026#34;Hello\u0026#34;; // Using new keyword String str2 = new String(\u0026#34;World\u0026#34;); 2. Important Methods of String (a) Length of a String String ka length nikalne ke liye length() method use hota hai.\nString str = \u0026#34;Java\u0026#34;; System.out.println(str.length()); // Output: 4 (b) Concatenation (Join Strings) Strings ko combine karne ke liye + operator ya concat() method ka use hota hai.\nString s1 = \u0026#34;Hello\u0026#34;; String s2 = \u0026#34;World\u0026#34;; System.out.println(s1 + \u0026#34; \u0026#34; + s2); // Output: Hello World System.out.println(s1.concat(\u0026#34; \u0026#34; + s2)); // Output: Hello World (c) Character Extraction charAt(index) - Kisi specific index ka character nikalta hai. substring(startIndex, endIndex) - Ek substring nikalta hai. String s = \u0026#34;Hello\u0026#34;; System.out.println(s.charAt(1)); // Output: e System.out.println(s.substring(1, 4)); // Output: ell (d) String Comparison equals() - Dono strings ka exact match check karta hai. equalsIgnoreCase() - Case ko ignore karke strings compare karta hai. compareTo() - Lexicographical comparison karta hai. String s1 = \u0026#34;Hello\u0026#34;; String s2 = \u0026#34;hello\u0026#34;; // Case-sensitive System.out.println(s1.equals(s2)); // Output: false // Case-insensitive System.out.println(s1.equalsIgnoreCase(s2)); // Output: true // Lexicographical comparison System.out.println(s1.compareTo(s2)); // Output: -32 (e) Searching in String indexOf(char) - Character ka first occurrence batata hai. lastIndexOf(char) - Character ka last occurrence batata hai. contains(String) - String ke andar substring check karta hai. String s = \u0026#34;Java Programming\u0026#34;; System.out.println(s.indexOf(\u0026#39;a\u0026#39;)); // Output: 1 System.out.println(s.lastIndexOf(\u0026#39;a\u0026#39;)); // Output: 13 System.out.println(s.contains(\u0026#34;Java\u0026#34;)); // Output: true (f) String Replacement replace(oldChar, newChar) aur replaceAll(regex, replacement) ka use hota hai.\nString s = \u0026#34;Java is fun\u0026#34;; System.out.println(s.replace(\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;)); // Output: Jeve is fun System.out.println(s.replaceAll(\u0026#34;fun\u0026#34;, \u0026#34;awesome\u0026#34;)); // Output: Java is awesome (g) Case Conversion toUpperCase() - String ko uppercase mein convert karta hai. toLowerCase() - String ko lowercase mein convert karta hai. String s = \u0026#34;Hello World\u0026#34;; System.out.println(s.toUpperCase()); // Output: HELLO WORLD System.out.println(s.toLowerCase()); // Output: hello world 3. Immutable vs Mutable Strings Immutable String: String class immutable hoti hai. Mutable String: StringBuilder aur StringBuffer mutable hote hain. Example of Immutable:\nString s = \u0026#34;Hello\u0026#34;; s.concat(\u0026#34; World\u0026#34;); System.out.println(s); // Output: Hello (original string unchanged) Example of Mutable (StringBuilder):\nStringBuilder sb = new StringBuilder(\u0026#34;Hello\u0026#34;); sb.append(\u0026#34; World\u0026#34;); System.out.println(sb); // Output: Hello World 4. String Pool String literals String Pool mein store hote hain (Heap ke andar ek special memory). Agar ek hi string literal do alag variables mein use ho raha hai, to dono same memory location point karte hain. Example:\nString s1 = \u0026#34;Java\u0026#34;; String s2 = \u0026#34;Java\u0026#34;; System.out.println(s1 == s2); // Output: true But agar new keyword use karenge to alag memory allocate hoti hai.\nString s1 = new String(\u0026#34;Java\u0026#34;); String s2 = new String(\u0026#34;Java\u0026#34;); System.out.println(s1 == s2); // Output: false System.out.println(s1.equals(s2)); // Output: true 5. StringTokenizer (for Splitting) Java mein StringTokenizer ka use string ko split karne ke liye hota hai.\nimport java.util.StringTokenizer; StringTokenizer st = new StringTokenizer(\u0026#34;Java is fun\u0026#34;, \u0026#34; \u0026#34;); while (st.hasMoreTokens()) { System.out.println(st.nextToken()); } // Output: // Java // is // fun 6. Advanced Topics String Joiner: Strings ko join karne ke liye.\nimport java.util.StringJoiner; StringJoiner sj = new StringJoiner(\u0026#34;, \u0026#34;); sj.add(\u0026#34;Java\u0026#34;).add(\u0026#34;Python\u0026#34;).add(\u0026#34;C++\u0026#34;); System.out.println(sj); // Output: Java, Python, C++ String Format: Formatted strings create karna.\nString s = String.format(\u0026#34;Name: %s, Age: %d\u0026#34;, \u0026#34;Ali\u0026#34;, 25); System.out.println(s); // Output: Name: Ali, Age: 25 [[StringBuilder]] vs [[StringBuffer]]:\nStringBuilder fast hai but thread-safe nahi hai. StringBuffer slow hai but thread-safe hai. Yeh tha Java Strings ka ek detailed revision! Agar kisi point mein doubt ho ya code ka example chahiye, to bata de.\n","date":"2024-12-22T00:00:00Z","permalink":"http://localhost:1313/post/string-revision-in-hinglish/","title":"post String revision in HINGLISH"},{"content":"Bilkul bhai, StringBuffer ko bhi simple example aur clear explanation ke saath samjhata hoon. Agar tu StringBuilder samajh gaya hai, to StringBuffer samajhna aur bhi easy ho jayega, kyunki dono kaafi similar hain.\nStringBuffer Kya Hai? StringBuffer bhi ek mutable string class hai, jaise StringBuilder. Iska kaam bhi wahi hai: Strings ko modify karna bina naye objects create kare. Farak? StringBuffer thread-safe hota hai, matlab ye multi-threaded environments ke liye secure hai, lekin ye StringBuilder se thoda slow hota hai. StringBuffer vs StringBuilder Feature StringBuffer StringBuilder Thread-Safety Thread-safe Not thread-safe Performance Slower (due to thread-safety) Faster Usage Multi-threading apps Single-threaded apps StringBuffer Example Without StringBuffer (Using String) Baar-baar string modify karne pe naye objects bante hain, jo memory aur time waste karta hai.\npublic class WithoutStringBuffer { public static void main(String[] args) { String s = \u0026#34;Hello\u0026#34;; s = s + \u0026#34; World\u0026#34;; // Naya object ban raha hai s = s + \u0026#34;!\u0026#34;; System.out.println(s); // Output: Hello World! } } With StringBuffer StringBuffer ek hi object ko baar-baar modify karta hai.\npublic class WithStringBuffer { public static void main(String[] args) { StringBuffer sb = new StringBuffer(\u0026#34;Hello\u0026#34;); sb.append(\u0026#34; World\u0026#34;); // \u0026#34;World\u0026#34; add karega existing object mein sb.append(\u0026#34;!\u0026#34;); System.out.println(sb); // Output: Hello World! } } Yahan koi naya object nahi bana, performance better hai.\nImportant Methods of StringBuffer 1. append() String ke end mein kuch add karne ke liye.\nStringBuffer sb = new StringBuffer(\u0026#34;Hello\u0026#34;); sb.append(\u0026#34; World\u0026#34;); System.out.println(sb); // Output: Hello World 2. insert() String ke specific index par kuch insert karne ke liye.\nStringBuffer sb = new StringBuffer(\u0026#34;Hello World\u0026#34;); sb.insert(6, \u0026#34;Beautiful \u0026#34;); // Index 6 par \u0026#34;Beautiful \u0026#34; insert karega System.out.println(sb); // Output: Hello Beautiful World 3. replace() String ke ek portion ko replace karne ke liye.\nStringBuffer sb = new StringBuffer(\u0026#34;I love Java\u0026#34;); sb.replace(7, 11, \u0026#34;Python\u0026#34;); // \u0026#34;Java\u0026#34; ko \u0026#34;Python\u0026#34; se replace karega System.out.println(sb); // Output: I love Python 4. delete() String ke specific portion ko delete karne ke liye.\nStringBuffer sb = new StringBuffer(\u0026#34;Hello Beautiful World\u0026#34;); sb.delete(6, 16); // Index 6 se 15 tak delete karega System.out.println(sb); // Output: Hello World 5. reverse() String ko reverse karne ke liye.\nStringBuffer sb = new StringBuffer(\u0026#34;Java\u0026#34;); sb.reverse(); System.out.println(sb); // Output: avaJ 6. capacity() StringBuffer ki capacity check karne ke liye.\nStringBuffer sb = new StringBuffer(); System.out.println(sb.capacity()); // Default capacity: 16 sb.append(\u0026#34;Java Programming\u0026#34;); System.out.println(sb.capacity()); // Capacity dynamically grow karegi Thread-Safety of StringBuffer Thread-safety ka matlab hai ki agar ek StringBuffer object ko multiple threads access karte hain, to usme koi data corruption nahi hoga. Java internally synchronized blocks use karta hai, jo ensure karta hai ki ek time pe ek hi thread object ko modify kare.\nStringBuffer vs StringBuilder: Example Agar tumhare program mein multi-threading use ho raha hai, to StringBuffer use karo.\npublic class ThreadSafeExample { public static void main(String[] args) { StringBuffer sb = new StringBuffer(\u0026#34;Hello\u0026#34;); // Thread 1 new Thread(() -\u0026gt; { sb.append(\u0026#34; World\u0026#34;); System.out.println(sb); }).start(); // Thread 2 new Thread(() -\u0026gt; { sb.append(\u0026#34;!\u0026#34;); System.out.println(sb); }).start(); } } Yahan pe StringBuffer thread-safe hai, isliye threads ke beech koi issue nahi hoga. Agar yahi StringBuilder hota, to data corruption ho sakti thi.\nWhen to Use StringBuffer? Multi-threaded Applications: Agar tumhare program mein multiple threads ek hi string object ke saath kaam karte hain, to StringBuffer use karo. Repeated String Modifications: Agar string baar-baar modify karni hai aur thread-safety chahiye. Summary StringBuffer mutable hai, aur multi-threading ke liye safe hai. Agar tum single-threaded program likh rahe ho, to StringBuilder faster hoga. Agar tum immutable strings chahiye (jise modify nahi karna), to String use karo. Agar koi specific doubt ho ya code chahiye, to bata!\n","date":"2024-12-22T00:00:00Z","permalink":"http://localhost:1313/post/stringbuffer/","title":"post StringBuffer"},{"content":"Bhai, samjhata hoon StringBuilder ka concept step-by-step, aram se! Video waale heavy explanation ko side rakhte hain aur simple example se clear karte hain.\nStringBuilder Kya Hai? StringBuilder ek class hai jo Java mein mutable strings (modify hone wale strings) create karne ke liye use hoti hai. Jab tum String use karte ho aur usse baar-baar modify karte ho (like concat, replace, etc.), to naye-naye objects bante hain kyunki String immutable hoti hai. StringBuilder mutable hota hai, matlab tum ek hi object mein changes kar sakte ho. Isse performance improve hoti hai. StringBuilder vs String Feature String (Immutable) StringBuilder (Mutable) Nature Immutable (cannot change) Mutable (can change) Performance Slow for repeated changes Fast for repeated changes Thread-Safety Thread-safe (but slower) Not thread-safe (but faster) StringBuilder Example: Without StringBuilder (Using String) Agar tum String use karke baar-baar modification karte ho, to har baar naya object banta hai.\npublic class StringExample { public static void main(String[] args) { String s = \u0026#34;Hello\u0026#34;; s = s + \u0026#34; World\u0026#34;; // Creates a new object s = s + \u0026#34;!\u0026#34;; System.out.println(s); // Output: Hello World! } } Yahan pe har baar s ke liye naya string object banta hai, jo memory waste karta hai aur slow hota hai.\nWith StringBuilder StringBuilder se ek hi object hota hai, aur usi mein modification hota hai.\npublic class StringBuilderExample { public static void main(String[] args) { StringBuilder sb = new StringBuilder(\u0026#34;Hello\u0026#34;); sb.append(\u0026#34; World\u0026#34;); // Add \u0026#34; World\u0026#34; to the existing object sb.append(\u0026#34;!\u0026#34;); // Add \u0026#34;!\u0026#34; to the existing object System.out.println(sb); // Output: Hello World! } } Yahan koi naya object nahi bana, bas original object modify hua. Faster and efficient!\nImportant Methods of StringBuilder 1. append() String ke end mein kuch add karne ke liye.\nStringBuilder sb = new StringBuilder(\u0026#34;Hello\u0026#34;); sb.append(\u0026#34; World\u0026#34;); System.out.println(sb); // Output: Hello World 2. insert() String ke kisi specific index par kuch insert karne ke liye.\nStringBuilder sb = new StringBuilder(\u0026#34;Hello World\u0026#34;); sb.insert(6, \u0026#34;Beautiful \u0026#34;); // Insert \u0026#34;Beautiful \u0026#34; at index 6 System.out.println(sb); // Output: Hello Beautiful World 3. replace() String ke ek portion ko replace karne ke liye.\nStringBuilder sb = new StringBuilder(\u0026#34;I love Java\u0026#34;); sb.replace(7, 11, \u0026#34;Python\u0026#34;); // Replace \u0026#34;Java\u0026#34; with \u0026#34;Python\u0026#34; System.out.println(sb); // Output: I love Python 4. delete() String ke ek portion ko delete karne ke liye.\nStringBuilder sb = new StringBuilder(\u0026#34;Hello Beautiful World\u0026#34;); sb.delete(6, 16); // Delete characters from index 6 to 16 System.out.println(sb); // Output: Hello World 5. reverse() String ko reverse karne ke liye.\nStringBuilder sb = new StringBuilder(\u0026#34;Java\u0026#34;); sb.reverse(); System.out.println(sb); // Output: avaJ 6. capacity() StringBuilder ka initial size aur uski capacity check karne ke liye.\nStringBuilder sb = new StringBuilder(); System.out.println(sb.capacity()); // Default capacity: 16 sb.append(\u0026#34;Java Programming\u0026#34;); System.out.println(sb.capacity()); // Capacity grows dynamically StringBuilder ka Use Kab Karein? Jab baar-baar string ko modify karna ho (like append, delete, replace, etc.). Jab performance important ho, kyunki StringBuilder memory-efficient hota hai. Jab thread-safety ka issue na ho (StringBuffer thread-safe hota hai, but slow). StringBuilder vs StringBuffer Feature StringBuilder StringBuffer Performance Fast Slow Thread-Safety Not thread-safe Thread-safe Example for Better Understanding Maan lo tumhe ek loop mein continuously string modify karni hai:\nUsing String: public class StringExample { public static void main(String[] args) { String s = \u0026#34;Hello\u0026#34;; for (int i = 0; i \u0026lt; 5; i++) { s = s + i; // New object every iteration } System.out.println(s); // Output: Hello01234 } } Using StringBuilder: public class StringBuilderExample { public static void main(String[] args) { StringBuilder sb = new StringBuilder(\u0026#34;Hello\u0026#34;); for (int i = 0; i \u0026lt; 5; i++) { sb.append(i); // Modifies the same object } System.out.println(sb); // Output: Hello01234 } } StringBuilder wala code memory-efficient aur fast hai kyunki ek hi object modify ho raha hai.\nConclusion StringBuilder tumhe tab use karna chahiye:\nJab tumhe repeatedly string modify karni ho. Jab tum performance optimize karna chahte ho. Agar abhi bhi confusion ho ya code pe practice karni ho, to bata! Saath-saath likh ke samjha doonga.\n","date":"2024-12-22T00:00:00Z","permalink":"http://localhost:1313/post/stringbuilder/","title":"post StringBuilder"},{"content":" companieschevron date - [x] [[zoho]] zoho applied for software developer at 17/12/24 - [x] [[Ibm]] applied on 17th dec but didn\u0026rsquo;t added coverletter - [x] [[chevron]] applied on 21th Dec For Azure Developer ","date":"2024-12-21T00:00:00Z","permalink":"http://localhost:1313/post/interview/1.off-campus-companies-to-apply/","title":"interview 1 Off-campus Companies to apply"},{"content":"Start the vm az vm start --resource-group personal --name MyServer Stop az vm stop --resource-group personal --name MyServer Create an vm az vm create \\ --resource-group MyResourceGroup \\ --name MySpotVM \\ --image UbuntuLTS \\ --priority Spot \\ --eviction-policy Deallocate \\ --size Standard_B1s \\ --admin-username azureuser \\ --ssh-key-value ~/.ssh/id_rsa.pub ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/az-104/az-cli/","title":"AZ-104 AZ-CLI"},{"content":"Azure Application Gateway is a web traffic load balancer designed specifically for HTTP(S) traffic at the application layer (OSI Layer 7). It enables you to manage and optimize the delivery of web applications by offering advanced features like URL-based routing, SSL termination, session persistence, and a Web Application Firewall (WAF) for security.\nKey Features of Azure Application Gateway Layer 7 Load Balancing: Routes traffic based on HTTP(S) properties, such as URLs, headers, or cookies. Example: Route /api requests to one backend pool and /app requests to another. URL Path-Based Routing: Directs requests to specific backend servers based on the URL path. Example: Route requests to /images to a storage service and /data to an API service. SSL Offloading: Terminates SSL/TLS at the gateway, reducing the processing load on backend servers. Optionally re-encrypts traffic when forwarding to backends (end-to-end encryption). Web Application Firewall (WAF): Protects web applications from common vulnerabilities like SQL injection, cross-site scripting (XSS), and others. Based on OWASP (Open Web Application Security Project) core rule set. Multi-Site Hosting: Hosts multiple applications on the same Application Gateway using different domain names. Example: Serve www.site1.com and www.site2.com from the same gateway. Redirection Support: Supports HTTP to HTTPS redirection or custom URL redirection. Session Affinity: Ensures requests from a particular client are always sent to the same backend server during a session. Autoscaling: Automatically scales based on traffic load to ensure high availability and performance. Custom Error Pages: Displays custom error messages for 403, 502, or other errors. When to Use Azure Application Gateway HTTP/HTTPS Traffic Load Balancing: When your application relies heavily on web traffic and you need application-layer routing. Web Application Security: Use WAF to protect against vulnerabilities and attacks. Hosting Multiple Web Applications: Ideal for scenarios where you need to host and route traffic for multiple domains or paths. SSL Offloading: If you want to reduce the overhead of SSL/TLS encryption on backend servers. Dynamic Routing Based on URL/Headers: When you need advanced traffic distribution based on request details. Autoscaling Web Traffic Handling: For unpredictable or growing traffic demands. How Azure Application Gateway Works Frontend: The Application Gateway listens for incoming HTTP/HTTPS requests on a public or private IP. Routing Rules: Configured rules determine how traffic is routed to backend pools based on URL paths, hostnames, or other properties. Backend Pools: A set of backend servers (e.g., VMs, App Services, AKS) that handle the actual requests. Health Probes: Monitors the health of backend servers to ensure traffic is sent only to healthy instances. Comparison: Application Gateway vs. Load Balancer Feature Application Gateway Load Balancer OSI Layer Layer 7 (Application) Layer 4 (Transport) Traffic Type HTTP(S) Any TCP/UDP Routing URL-based, header-based, cookie-based IP-based SSL Offloading Yes No Web Application Firewall Yes No Azure Application Gateway is ideal for managing web applications with sophisticated traffic-routing and security needs. It is often used in conjunction with Azure Front Door for global load balancing or paired with a Load Balancer for hybrid scenarios.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/az-104/azure-application-gateway/","title":"AZ-104 AZure application gateway"},{"content":"DNS (Domain Name System) is the internet\u0026rsquo;s system for translating human-friendly domain names (like www.example.com) into machine-readable IP addresses (like 192.0.2.1) that computers use to communicate with each other.\nHow DNS Works User Request: When you type a URL (e.g., www.example.com) in a browser, your computer sends a request to resolve the domain name into an IP address. DNS Query Process: The query goes through several stages: Recursive Resolver: A DNS server that acts as an intermediary, finding the IP address for the requested domain. Root Server: The resolver contacts a root DNS server to get information about the domain\u0026rsquo;s TLD (Top-Level Domain) (e.g., .com). TLD Nameserver: The resolver queries the nameserver for the TLD to get the authoritative server\u0026rsquo;s location for the domain. Authoritative Nameserver: Finally, the resolver queries the authoritative nameserver for the domain, which provides the IP address. Response: The resolver sends the IP address back to your computer, which uses it to connect to the server hosting the website. Key Components of DNS Domain Names:\nHuman-readable names (e.g., example.com) that map to IP addresses. IP Addresses:\nMachine-readable numerical labels (e.g., 192.168.1.1 for IPv4, or 2001:db8::1 for IPv6). DNS Records:\nSpecific instructions within the DNS system that define how the domain name is handled. Common types include: A Record: Maps a domain to an IPv4 address. AAAA Record: Maps a domain to an IPv6 address. CNAME Record: Aliases one domain to another. MX Record: Specifies mail servers for email handling. TXT Record: Holds text data, often for verification or security. DNS Servers:\nMachines responsible for resolving domain names into IP addresses: Recursive Resolver: Finds the IP address on behalf of the client. Root Server: First step in the DNS hierarchy. TLD Nameserver: Provides information about domains in a specific TLD. Authoritative Nameserver: Final authority for a specific domain. Importance of DNS Ease of Use:\nUsers can remember domain names instead of numeric IP addresses. Scalability:\nEnables the global distribution of websites and services. Redundancy:\nDistributed nature ensures high availability and reliability. Security Features:\nModern DNS supports features like DNSSEC to prevent attacks like spoofing. Common DNS Use Cases Web Browsing: Resolving domain names for websites. Email: Directing email to appropriate mail servers (via MX records). CDN (Content Delivery Network): Distributing traffic to the nearest servers. Load Balancing: Distributing requests across multiple servers. In essence, DNS acts as the internet\u0026rsquo;s \u0026ldquo;phonebook,\u0026rdquo; helping users access online resources seamlessly!\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/az-104/dns/","title":"AZ-104 DNS"},{"content":"Azure Bastion [[User defined routes]] [[Network watcher service]] [[Azure loadbalancer]] [[AZure application gateway]] [[DNS]] [[AZ-CLI]] [[configure and manage virtual networking.excalidraw]] [[Storage Account]] ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/az-104/1.-azure-index/","title":"Azure Index"},{"content":"","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/big-data-analysis/1.-impt-questions/","title":"Big Data Analysis 1  Impt questions"},{"content":"Difference Between Blockchain 1.0 and Blockchain 2.0 Aspect Blockchain 1.0 Blockchain 2.0 Definition The first generation of blockchain focused on cryptocurrency. The second generation of blockchain that introduced smart contracts and dApps. Primary Use Case Digital currency and secure peer-to-peer payments (e.g., Bitcoin). Beyond currency, includes decentralized applications (dApps) and smart contracts. Key Platforms Bitcoin, Litecoin, Dogecoin. Ethereum, EOS, Hyperledger, Cardano. Focus Cryptocurrency transactions. Programmable blockchain with logic (smart contracts). Transaction Type Basic transactions (send/receive digital currency). Complex programmable transactions (logic-based). Smart Contracts Not supported. Supported; automated execution of agreements. dApps (Decentralized Apps) Not possible. Enabled by platforms like Ethereum and EOS. Tokenization Limited to native tokens like Bitcoin (BTC). Custom tokens (e.g., ERC-20, ERC-721) can be created. Complexity Simple ledger system for tracking transactions. Complex and programmable ecosystem. Scalability Limited to basic cryptocurrency needs. Focused on improving transaction speeds and scalability for broader applications. Customization No customization possible. Custom blockchains and applications can be created. Consensus Mechanism Primarily Proof of Work (PoW). Supports PoW, Proof of Stake (PoS), and others. Energy Efficiency Energy-intensive due to PoW mining. More energy-efficient with PoS and other mechanisms. Interoperability Very limited; no cross-chain communication. Focus on cross-chain functionality and interoperability. Adoption Primarily by cryptocurrency users. Adopted by enterprises, developers, and industries. Enterprise Use Cases Rarely used for enterprise solutions. Widely used for supply chain, healthcare, and finance. Innovation Level First generation, introducing the blockchain concept. Second generation, expanding use cases and functionality. Examples Bitcoin, Bitcoin Cash. Ethereum, Polkadot, Hyperledger. Data Storage Only transaction data. Transaction data + executable code (smart contracts). Community Support Crypto enthusiasts. Developers, enterprises, crypto users. Privacy Features Limited to pseudonymity. Advanced features like Zero-Knowledge Proofs in some implementations. Key Summary Blockchain 1.0 focuses only on digital currency and payments. Blockchain 2.0 extends the technology to programmable applications like smart contracts and dApps, making it applicable to various industries. ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/blockchain-2.0/","title":"Blockchain technology Blockchain 2 0"},{"content":"Byzantine Fault Tolerant Algorithm (BFT) Byzantine Fault Tolerance (BFT) is a property of a distributed system that allows it to function correctly and reach consensus even if some nodes behave maliciously or unpredictably. The term \u0026ldquo;Byzantine\u0026rdquo; comes from the Byzantine Generals Problem, a metaphor used to describe the challenges of achieving agreement in a distributed system where some components might fail or act maliciously.\nWhat is the Byzantine Generals Problem? Imagine several generals of a Byzantine army surrounding a city. They must agree on a coordinated plan to attack or retreat. However:\nSome generals may be traitors and send conflicting messages. The challenge is to ensure that loyal generals can agree on a single strategy, regardless of the traitors\u0026rsquo; behavior. The problem highlights the difficulty of achieving consensus in a system where not all participants can be trusted.\nKey Properties of a Byzantine Fault-Tolerant System Agreement: All honest nodes (non-faulty nodes) must agree on the same value. Validity: If all honest nodes propose the same value, the agreed-upon value must be that value. Fault Tolerance: The system should remain operational as long as fewer than f = (n-1)/3 nodes are malicious (where nn is the total number of nodes). How Byzantine Fault Tolerance Works In a Byzantine Fault Tolerant system, nodes communicate and exchange information to reach a consensus. The process involves the following steps:\n1. Propose: One or more nodes propose a value to the network. For example, in a blockchain, this could be a new block of transactions. 2. Vote: Each node evaluates the proposal and shares its vote (opinion) with others. Nodes exchange messages to ensure they have a majority agreement. 3. Consensus: If enough nodes agree on the same value (typically a supermajority, e.g., 2f+12f+1), the system reaches consensus, and the value is finalized. Common Byzantine Fault-Tolerant Algorithms Practical Byzantine Fault Tolerance (PBFT): A widely-used algorithm in private or permissioned blockchains. Operates in three phases: Pre-Prepare, Prepare, and Commit. Designed for systems with a fixed number of nodes and known participants. Tendermint: A consensus algorithm that uses BFT for high-performance blockchain systems. Used in projects like Cosmos. Delegated Byzantine Fault Tolerance (dBFT): Used by blockchains like NEO. A small group of delegates (validators) are elected to reach consensus. HotStuff: A modern BFT algorithm designed for blockchain scalability. Used in projects like Facebook\u0026rsquo;s Diem (formerly Libra). Applications of BFT Permissioned Blockchains: Systems like Hyperledger Fabric use BFT to ensure consensus among trusted nodes. Public Blockchains: Some public blockchains use variants of BFT (e.g., Tendermint in Cosmos). Distributed Systems: BFT is used in fault-tolerant distributed databases and financial systems. Advantages of BFT Fault Tolerance: Can handle both malicious and non-malicious faults (e.g., software bugs, crashes). Consensus in Adversarial Environments: Ensures correct operation even if some participants act dishonestly. Decentralization: Encourages distributed decision-making, reducing the risk of central authority failures. Challenges of BFT High Communication Overhead: Requires extensive message exchanges, making it less efficient for large-scale systems. Scalability Issues: Works well with small networks (e.g., 10–100 nodes). Performance deteriorates in larger networks. Known Participants: Most BFT algorithms assume a fixed set of known participants, which may not suit public blockchains. Comparison with Non-Byzantine Fault Tolerance Feature BFT Non-BFT (e.g., Paxos, Raft) Fault Tolerance Handles malicious behavior Handles only crash failures Communication Overhead Higher Lower Use Case Blockchain, adversarial systems Databases, trusted environments Example: PBFT in Blockchain Pre-Prepare Phase: The leader (primary) proposes a block to all nodes. Prepare Phase: Nodes exchange votes to confirm they’ve received the proposal. Commit Phase: Once a majority of nodes agree, the block is finalized and added to the chain. Conclusion Byzantine Fault Tolerance is a cornerstone of decentralized and secure systems like blockchains. It enables systems to operate correctly even in adversarial conditions. While BFT algorithms are powerful, their scalability and efficiency challenges make them more suitable for permissioned or smaller-scale blockchains rather than large public ones like Bitcoin or Ethereum.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/byzantine-fault-tolerant-algo/","title":"Blockchain technology BYZANTINE FAULT Tolerant algo"},{"content":"Supply chain management involves coordinating and managing the flow of goods, information, and finances from suppliers to consumers. The process often suffers from inefficiencies such as lack of transparency, fraud, and data silos. Blockchain technology, particularly Hyperledger Fabric, offers a solution to these challenges by providing transparency, immutability, and trust in the supply chain.\nOverview of the Problem Lack of Transparency: Supply chains involve multiple stakeholders (manufacturers, suppliers, distributors, retailers), leading to data silos. Limited visibility into the origin and status of goods. Counterfeit Goods: Counterfeiting is a significant problem, particularly in industries like pharmaceuticals and luxury goods. Inefficiency: Manual processes and paperwork slow down operations and increase costs. Compliance Challenges: Difficulty in meeting regulatory requirements due to fragmented data. Solution Using Hyperledger Fabric Key Features Leveraged: Permissioned Access: Only authorized participants (e.g., manufacturers, suppliers, regulators) can access the blockchain network. Immutability: All transactions are recorded immutably on the ledger, ensuring accountability. Channels for Privacy: Private channels can be used for confidential interactions between specific parties. Smart Contracts (Chaincode): Automate processes like purchase orders, shipment tracking, and payments. Real-Time Tracking: Integrate IoT devices to record real-time data like temperature and location. Case Study Example: Walmart and Food Supply Chain Objective: Walmart wanted to enhance food safety and traceability in its supply chain, particularly for fresh produce.\nChallenges: Tracking the origin of produce was time-consuming, taking up to 7 days. Consumers demanded better transparency about the source of their food. Regulatory pressure to comply with food safety standards. Solution Implementation: Blockchain Deployment: Walmart partnered with IBM and used Hyperledger Fabric to build a blockchain-based supply chain platform. Participant Onboarding: Farmers, suppliers, distributors, and retailers were onboarded to the blockchain network. Data Recording: Each participant recorded relevant data, such as harvesting dates, shipping details, and quality checks. Smart Contracts: Automated processes like verifying produce quality and ensuring compliance with safety standards. Integration with IoT: IoT devices tracked the temperature and humidity of goods in transit, ensuring they met quality standards. Outcome: Improved Traceability: Walmart reduced the time required to trace the origin of produce from 7 days to 2.2 seconds. Enhanced Food Safety: Identified contaminated batches quickly, reducing the risk of foodborne illnesses. Increased Consumer Trust: Consumers gained confidence in the quality and origin of their food. Regulatory Compliance: Simplified compliance with food safety regulations. Generalized Workflow for Supply Chain Management Product Creation: A manufacturer records product details (e.g., batch number, date of production) on the blockchain. Shipping: Logistics providers update the blockchain with real-time shipment data (e.g., location, condition). Storage: Warehouses record inventory details and storage conditions. Retail: Retailers update the blockchain with sales data and product delivery confirmation. Consumer Access: Consumers can scan a QR code on the product to access its complete history on the blockchain. Advantages of Using Hyperledger Fabric Transparency: All participants have access to a single source of truth. Fraud Prevention: Immutable records prevent tampering and counterfeiting. Efficiency: Automating processes with smart contracts reduces delays and paperwork. Cost Savings: Reduces inefficiencies and the need for intermediaries. Improved Decision-Making: Real-time insights enable better inventory management and demand forecasting. Challenges in Implementation Integration with Legacy Systems: Existing supply chain systems may not be compatible with blockchain. Participant Onboarding: Convincing stakeholders to adopt the technology can be challenging. Initial Costs: Setting up the blockchain network and integrating IoT devices involves upfront costs. Data Accuracy: Blockchain ensures data integrity but relies on participants to input accurate information. Other Use Cases in Supply Chain Pharmaceuticals: Ensure drug authenticity and track temperature-sensitive medicines. Luxury Goods: Verify the authenticity of high-value items like diamonds and designer handbags. Automotive Industry: Track the origin and quality of components in vehicle manufacturing. Retail: Manage inventory and prevent stockouts or overstocking. Conclusion Hyperledger Fabric is transforming supply chain management by addressing key challenges such as transparency, efficiency, and fraud prevention. The success of real-world implementations like Walmart demonstrates its potential to revolutionize industries reliant on complex supply chains. By integrating blockchain with IoT and other technologies, businesses can build resilient, secure, and efficient supply chain systems.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/case-study-of-supply-chain-management-using-hyperledger/","title":"Blockchain technology Case Study of Supply chain management using hyperledger"},{"content":"A block in a blockchain is a container for ==storing a batch of transactions or data==, along with ==metadata== that links it to other blocks in the chain. Here are the key components of a block in a blockchain:\n1. Block Header The block header contains metadata about the block, which is critical for the functioning and security of the blockchain. Its components include:\na. Block Number Represents the position of the block in the blockchain. Starts at 0 for the genesis block (the first block). b. Previous Block Hash A cryptographic hash of the previous block\u0026rsquo;s header. Links the current block to the previous block, creating the \u0026ldquo;chain\u0026rdquo; in blockchain. Ensures immutability, as altering one block would break the chain. c. Timestamp The time and date when the block was created. Helps maintain chronological order. d. Nonce A random number used in the Proof of Work (PoW) consensus mechanism. Miners adjust the nonce to solve the cryptographic puzzle and create a valid block hash. e. Merkle Root A hash representing all the transactions in the block, derived from a Merkle Tree. Ensures data integrity, as any change in transaction data would alter the Merkle Root. f. Difficulty Target Indicates the difficulty of the mining puzzle in PoW-based blockchains like Bitcoin. Ensures that blocks are mined at a consistent rate. 2. Transactions The transactions are the core data stored in the block. Each block contains a list of validated transactions. Key features include:\nTransaction Data: Sender\u0026rsquo;s address. Recipient\u0026rsquo;s address. Amount transferred. Transaction fee. Digital Signature: Ensures authenticity by verifying that the transaction was authorized by the sender. Transaction Hash: A unique hash for each transaction, used in the Merkle Tree. 3. Transaction Counter A count of the total number of transactions included in the block. Useful for determining block size and processing efficiency. 4. Block Hash A unique identifier for the block. Generated by hashing the block header. Used to reference the block in the chain. 5. Version Number Indicates the software version or protocol rules the block adheres to. Allows compatibility with future upgrades or changes in the blockchain protocol. 6. Block Size The total size of the block in bytes. Includes both transaction data and metadata. For example: Bitcoin\u0026rsquo;s block size is capped at 1 MB. Ethereum’s block size depends on the gas limit. Summary A blockchain block has the following main components:\nBlock Header: Includes metadata like the previous block hash, timestamp, nonce, Merkle Root, and difficulty target. Transactions: The actual data (e.g., payments or records) included in the block. Transaction Counter: Number of transactions in the block. Block Hash: A unique identifier for the block. Version Number: Protocol version used. Block Size: Total size of the block. Together, these components ensure that blockchain blocks are secure, immutable, and interconnected in the chain.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/components-of-blocks-in-blockchain/","title":"Blockchain technology Components of Blocks in blockchain"},{"content":"What is a Consensus Protocol? A consensus protocol is a core mechanism in blockchain systems that allows distributed nodes (participants in the network) to agree on a single, consistent state of the blockchain. Since blockchains are decentralized and have no central authority, consensus protocols ensure that all nodes agree on the validity of transactions and blocks without relying on trust.\nPurpose of a Consensus Protocol The consensus protocol serves multiple purposes:\nAgreement: Ensures all nodes in the network agree on the same version of the blockchain. Fault Tolerance: Helps the network function properly even if some nodes fail or act maliciously. Immutability: Ensures that once a block is added, it cannot be altered. Security: Prevents fraudulent activities like double-spending (spending the same digital currency twice). Key Features of a Consensus Protocol Decentralization: Operates in a distributed environment without a central authority. Fault Tolerance: Handles failures, attacks, or misbehavior by some nodes. Fairness: Every participant (node) gets an equal opportunity to validate and propose blocks. Agreement Finality: Once consensus is reached, the agreed-upon state becomes permanent. Incentive Mechanisms: Rewards participants for contributing to the network’s security. Steps in a Consensus Process Transaction Proposal: A user initiates a transaction and broadcasts it to the network. Validation: Nodes verify the transaction based on predefined rules (e.g., checking digital signatures, balances). Block Creation: A node groups valid transactions into a block and proposes it to the network. Consensus: Nodes collaborate using the consensus protocol to decide whether to accept the proposed block. Block Addition: Once consensus is reached, the block is added to the blockchain. Common Consensus Protocols 1. Proof of Work (PoW) Overview: Requires participants (miners) to solve complex cryptographic puzzles to validate transactions and create new blocks. How It Works: Miners compete to solve a mathematical problem (hash puzzle). The first miner to solve it broadcasts the solution. Other nodes verify the solution, and if valid, the block is added to the blockchain. Advantages: Highly secure and resistant to attacks. Decentralized. Disadvantages: Energy-intensive and slow. Expensive mining equipment required. Use Cases: Bitcoin, Litecoin. 2. Proof of Stake (PoS) Overview: Validators are chosen to create new blocks based on the amount of cryptocurrency they hold and are willing to \u0026ldquo;stake.\u0026rdquo; How It Works: Validators lock up a certain amount of cryptocurrency as a stake. The protocol selects a validator to propose the next block. If the block is valid, the validator earns rewards. Advantages: Energy-efficient compared to PoW. Faster block creation. Disadvantages: Wealth centralization (rich validators have more influence). Potential for “nothing at stake” attacks. Use Cases: Ethereum 2.0, Cardano, Polkadot. 3. Delegated Proof of Stake (DPoS) Overview: A democratic version of PoS where token holders vote to elect a small number of delegates who validate transactions. How It Works: Token holders vote for delegates. The elected delegates validate transactions and propose blocks. Rewards are shared with token holders. Advantages: High scalability and fast transactions. Energy-efficient. Disadvantages: Less decentralized as power is concentrated in a few delegates. Use Cases: EOS, TRON. 4. Proof of Authority (PoA) Overview: Relies on a fixed number of trusted validators (authorities) to validate transactions. How It Works: Validators are pre-approved and known to the network. Validators take turns proposing and validating blocks. Advantages: Extremely fast and scalable. Low energy consumption. Disadvantages: Centralized since validators are selected by a central authority. Use Cases: VeChain, Ethereum testnets. 5. Practical Byzantine Fault Tolerance (PBFT) Overview: Handles Byzantine faults (nodes acting maliciously) by ensuring consensus even if some nodes fail or act dishonestly. How It Works: Nodes broadcast messages to each other about the validity of a transaction. Consensus is achieved if the majority agrees. Advantages: Highly fault-tolerant. Efficient for private or permissioned blockchains. Disadvantages: Not scalable for large public networks. Use Cases: Hyperledger Fabric. Comparison of Popular Consensus Protocols Feature Proof of Work (PoW) Proof of Stake (PoS) Delegated PoS (DPoS) Proof of Authority (PoA) PBFT Energy Use High Low Low Low Moderate Decentralization High Moderate Moderate Low Low to Moderate Scalability Low Moderate High High High Security Very High High Moderate Moderate Moderate Use Cases Bitcoin, Litecoin Ethereum 2.0, Cardano EOS, TRON VeChain Hyperledger Fabric Challenges of Consensus Protocols Scalability: Handling a large number of transactions quickly without compromising security. Energy Efficiency: Reducing power consumption (especially in PoW systems). Fairness: Ensuring equal opportunities for all participants (avoiding centralization). Byzantine Fault Tolerance: Managing malicious or failing nodes effectively. Conclusion Consensus protocols are the backbone of blockchain technology, ensuring that all nodes in a decentralized network agree on a single version of the truth. Different protocols, such as PoW, PoS, and DPoS, cater to various requirements, balancing trade-offs between decentralization, security, scalability, and efficiency. The choice of a consensus protocol depends on the blockchain’s goals and use cases, such as cryptocurrencies, enterprise applications, or smart contract platforms.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/consensus-protocol/","title":"Blockchain technology Consensus Protocol"},{"content":"What is DAO (Decentralized Autonomous Organization)? A Decentralized Autonomous Organization (DAO) is a blockchain-based organization that operates without centralized leadership, relying on transparent rules encoded in smart contracts and governed collectively by its members.\nIn simple terms, DAOs are organizations powered by blockchain technology where decision-making is decentralized and automated, enabling trustless, transparent, and community-driven operations.\nKey Features of DAOs Decentralized Governance:\nDecisions are made collectively by members instead of a central authority. Governance is enforced via blockchain-based smart contracts. Automation via Smart Contracts:\nRules and processes are coded into smart contracts, ensuring automatic and tamper-proof execution. Transparency:\nAll rules, proposals, and transactions are recorded on the blockchain, making them publicly accessible and auditable. Token-Based Participation:\nGovernance tokens represent voting power. Members use tokens to propose and vote on decisions. Trustless System:\nTrust is placed in the code and blockchain rather than individuals or intermediaries. How DAOs Work Formation:\nA DAO is created by writing smart contracts that define its rules, structure, and operations. The DAO is deployed on a blockchain platform, like Ethereum, making it operational. Token Distribution:\nMembers receive governance tokens through purchases, contributions, or investments. Tokens grant voting rights and may represent ownership in the DAO. Proposal and Voting:\nAny member can propose changes, decisions, or initiatives. Members vote on proposals using their governance tokens. Votes are weighted based on the number of tokens held (in most DAOs). Execution:\nSmart contracts automatically execute decisions once a proposal is approved. Funds and resources are allocated directly without intermediaries. Advantages of DAOs Decentralization:\nNo single entity has complete control, reducing the risk of corruption or bias. Transparency:\nBlockchain ensures all decisions and fund allocations are publicly visible and auditable. Global Participation:\nAnyone with internet access can join and contribute to the organization. Efficiency:\nAutomated processes reduce bureaucracy and enhance operational speed. Innovation:\nOpen participation encourages new ideas and initiatives from diverse members. Challenges of DAOs Smart Contract Vulnerabilities:\nBugs in smart contracts can lead to security breaches (e.g., the infamous DAO hack in 2016). Legal Uncertainty:\nDAOs often lack clear legal recognition in many jurisdictions, leading to regulatory challenges. Scalability Issues:\nDecision-making can be slow when a large number of members are involved. Concentration of Power:\nMembers with more governance tokens have more influence, potentially leading to centralization. Coordination Problems:\nAchieving consensus among a large and diverse group of members can be difficult. Types of DAOs Protocol DAOs:\nManage decentralized protocols and their updates. Example: Uniswap DAO, Aave DAO. Investment DAOs:\nPool funds from members to invest in projects and assets. Example: The LAO (for blockchain investments). Service DAOs:\nOffer decentralized services like development, marketing, or legal support. Example: Raid Guild. Collector DAOs:\nFocus on pooling funds to acquire and manage digital assets (e.g., NFTs). Example: PleasrDAO. Social DAOs:\nBuilt around communities with shared interests or goals. Example: Friends with Benefits (FWB). Examples of Popular DAOs MakerDAO:\nManages the Maker protocol, which enables decentralized stablecoins like DAI. Uniswap DAO:\nGoverns the Uniswap decentralized exchange (DEX) protocol. Aave DAO:\nManages Aave, a DeFi lending and borrowing platform. Compound DAO:\nGoverns the Compound protocol for decentralized lending. MolochDAO:\nFocuses on funding Ethereum-related public goods. DAO vs Traditional Organizations Aspect DAO Traditional Organization Leadership Decentralized; governed by members. Centralized; led by a board or management. Decision-Making Community voting via smart contracts. Board meetings and hierarchical approvals. Transparency Full transparency via blockchain. Limited transparency; often internal only. Automation Automated processes using smart contracts. Manual processes and approvals. Global Access Open to anyone with an internet connection. Restricted to employees or stakeholders. Regulatory Framework Lacks clear legal recognition. Legally recognized and regulated. Use Cases of DAOs Decentralized Finance (DeFi):\nGovernance of lending, borrowing, and trading protocols. Crowdfunding:\nPooling funds for projects without intermediaries. Gaming:\nDAOs govern play-to-earn ecosystems and in-game economies. Charity:\nTransparent donation and fund allocation for social causes. Decentralized Governance:\nManaging decentralized communities, networks, or ecosystems. Key Takeaways DAOs are revolutionary in enabling decentralized, automated, and trustless governance. They eliminate the need for intermediaries and foster global collaboration. Despite challenges like legal ambiguity and scalability, DAOs continue to drive innovation in decentralized finance (DeFi), Web3, and blockchain ecosystems. ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/dao/","title":"Blockchain technology DAO"},{"content":"What is DeFi (Decentralized Finance)? DeFi stands for Decentralized Finance, which refers to a set of financial services and applications built on blockchain technology, primarily using smart contracts to automate transactions and operations. These services operate without traditional intermediaries such as banks, brokers, or insurance companies, giving users more control over their financial activities.\nDeFi uses blockchain networks, mainly Ethereum, to create decentralized versions of traditional financial products, like lending, borrowing, trading, insurance, and more. By using smart contracts, DeFi eliminates the need for centralized intermediaries and offers a higher level of transparency and accessibility.\nKey Features of DeFi Feature Description Decentralization No central authority; transactions are powered by decentralized networks (e.g., Ethereum, Solana). Smart Contracts Self-executing contracts with the terms of the agreement directly written into code, ensuring trust and automation. Open Source DeFi protocols are generally open-source, allowing anyone to review, contribute, or build on the existing technology. Interoperability DeFi applications often interact with each other, allowing users to move assets between platforms (e.g., lending to staking to exchanges). Access to Financial Products Provides access to financial products like lending, borrowing, trading, insurance, and asset management without the need for traditional intermediaries. Global Accessibility DeFi platforms are accessible to anyone with an internet connection, regardless of geographic location or banking infrastructure. Components of DeFi Decentralized Exchanges (DEXs):\nPlatforms that allow users to trade cryptocurrencies directly with one another, without the need for an intermediary. Example: Uniswap, SushiSwap. Lending and Borrowing Platforms:\nDeFi platforms that let users lend or borrow cryptocurrencies, usually without credit checks, using over-collateralization. Example: Aave, Compound. Stablecoins:\nCryptocurrencies that are pegged to a stable asset like the US dollar, reducing volatility. Stablecoins are often used in DeFi applications for lending, borrowing, and trading. Example: DAI, USDC, Tether (USDT). Yield Farming and Staking:\nYield farming involves providing liquidity to DeFi platforms in exchange for interest or tokens, while staking involves locking up assets to support a blockchain network in return for rewards. Example: Yearn.finance (yield farming), Ethereum 2.0 staking. Insurance:\nDeFi-based insurance platforms allow users to insure against certain risks (e.g., smart contract failure, hacks, etc.) without relying on traditional insurers. Example: Nexus Mutual, Cover Protocol. Derivatives and Synthetic Assets:\nThese DeFi platforms allow users to create and trade synthetic assets that mimic real-world assets (like stocks, commodities, or other cryptocurrencies) on the blockchain. Example: Synthetix. Governance Tokens:\nTokens that allow holders to participate in the decision-making process of a DeFi project, giving them voting power over protocol changes and upgrades. Example: COMP (Compound), MKR (MakerDAO). Advantages of DeFi Decentralization: Users are in control of their funds, without relying on intermediaries like banks or brokers. Transparency: All transactions are publicly recorded on the blockchain, making the process transparent. Global Access: Anyone with an internet connection can access DeFi services, regardless of geographical location or financial status. Lower Fees: DeFi eliminates intermediaries, reducing transaction costs compared to traditional financial systems. Innovation: DeFi is built on blockchain technology, offering novel financial products and services not available in traditional finance. Risks of DeFi Smart Contract Vulnerabilities: Bugs or vulnerabilities in smart contracts can lead to loss of funds or exploitation. Regulatory Uncertainty: DeFi operates in a largely unregulated environment, which can lead to potential legal risks. Liquidity Risks: Lack of liquidity on certain platforms can lead to slippage or difficulty in executing trades. Market Volatility: Cryptocurrencies are highly volatile, and DeFi products tied to crypto assets may see large price swings. Technical Complexity: DeFi applications often require users to understand complex technical concepts like gas fees, wallet management, and interacting with smart contracts. Popular DeFi Platforms Uniswap: A decentralized exchange (DEX) for trading ERC-20 tokens. Aave: A decentralized lending and borrowing protocol. MakerDAO: A decentralized lending platform that uses the DAI stablecoin. Compound: A platform for lending and borrowing assets in DeFi. Yearn.finance: A yield optimization platform that allows users to earn returns on their crypto assets. Synthetix: A platform for creating and trading synthetic assets. Conclusion DeFi is revolutionizing the financial industry by removing intermediaries and providing financial services that are open, transparent, and accessible to everyone globally. However, its success depends on overcoming challenges like security, scalability, and regulatory hurdles. Despite the risks, DeFi is an exciting area of growth in the blockchain ecosystem, offering an alternative to traditional finance.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/defi/","title":"Blockchain technology DEFI"},{"content":" Feature Bitcoin Altcoin Token Definition A decentralized digital currency, the first blockchain-based cryptocurrency. Any cryptocurrency other than Bitcoin, often built on a new or existing blockchain. A digital asset created on an existing blockchain, representing utility, ownership, or value. Blockchain Operates on its own blockchain (Bitcoin blockchain). Usually operates on its own blockchain (e.g., Ethereum, Solana). Operates on an existing blockchain (e.g., ERC-20 tokens on Ethereum). Primary Purpose Acts as a store of value or digital currency for transactions. Can act as currency, enable specific features, or power decentralized platforms. Represents access, utility, or ownership in a specific application or service. Consensus Mechanism Proof of Work (PoW). Can use PoW, Proof of Stake (PoS), or other mechanisms. Relies on the consensus mechanism of the blockchain it is built on. Examples Bitcoin (BTC). Ethereum (ETH), Litecoin (LTC), Ripple (XRP). Tether (USDT), Chainlink (LINK), Uniswap (UNI). Development Focused purely on digital currency. May have unique functionalities like smart contracts or privacy features. Designed for specific applications (e.g., decentralized finance (DeFi), gaming, governance). Creation Process Mined through Bitcoin\u0026rsquo;s blockchain. Mined or pre-mined, depending on the blockchain. Created via smart contracts on an existing blockchain. Use Cases Peer-to-peer digital payments, store of value. Broader use cases like smart contracts, decentralized apps, and payments. Utility within applications, governance, staking, rewards, or pegged assets. Regulatory Perspective Generally treated as a commodity (e.g., by the U.S. SEC). May be treated as securities, commodities, or currencies depending on their design and function. More likely to be treated as securities depending on their purpose and issuance. Market Dominance The most dominant and valuable cryptocurrency. Competes with Bitcoin but has smaller market shares. Value depends on the adoption and utility of the specific platform or service. Flexibility Fixed supply (21 million BTC). Some have fixed supplies; others are inflationary. Supply and utility vary widely depending on the tokenomics. Summary Bitcoin is the first and most recognized cryptocurrency, primarily serving as digital money. Altcoins are alternatives to Bitcoin, offering different functionalities or improvements. Tokens are assets built on existing blockchains, often serving specific applications or ecosystems. ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/difference-between-bitcoin-altcoins-and-tokens/","title":"Blockchain technology Difference Between Bitcoin, Altcoins and Tokens"},{"content":"Differences Between Types of Blockchain Aspect Public Blockchain Private Blockchain Consortium Blockchain Hybrid Blockchain Definition Open, decentralized, and accessible to anyone. Restricted and controlled by a single entity. Controlled by a group of organizations (consortium). Combines features of public and private blockchains. Access Open to everyone. Restricted to authorized participants. Restricted to member organizations. Partially public and partially private. Governance Decentralized, managed by community consensus. Centralized, managed by a single authority. Semi-decentralized, governed by a group. Centralized for private operations, decentralized for public. Transparency Fully transparent; all transactions are visible. Partially transparent, limited to participants. Semi-transparent; visible only to members. Public transactions are visible, private ones are restricted. Consensus Mechanism Proof of Work (PoW), Proof of Stake (PoS), etc. Lightweight mechanisms like PBFT, PoA. PBFT, Raft, or custom mechanisms. A combination based on use case. Performance Slower due to global participation. Faster with fewer nodes. Faster than public but slower than private. High performance in private mode, slower in public mode. Scalability Limited scalability. Highly scalable due to controlled nodes. Scalable depending on the number of participants. Moderate scalability, depending on configuration. Energy Consumption High (e.g., PoW mining). Low due to efficient consensus mechanisms. Low due to limited participants. Varies based on the mechanism used. Security High due to decentralization and immutability. Lower; depends on the central authority. Moderate; trust shared among member organizations. Balances between public and private security aspects. Privacy Low; all data is public. High; transactions are private. Moderate; data shared within the group. High; sensitive data kept private, public data transparent. Immutability Fully immutable. Partial; central authority can alter data. Partial; consortium can agree to make changes. Public data is immutable; private data can be modified. Examples Bitcoin, Ethereum. Hyperledger Fabric, Quorum, Ripple. Corda, Energy Web, TradeLens. Dragonchain, XinFin. Use Cases Cryptocurrencies, DeFi, public dApps. Supply chain, healthcare, internal enterprise. Interbank payments, supply chain collaboration. Finance, real estate, e-government services. Cost High operational cost due to mining and energy. Lower cost due to fewer participants. Moderate cost. Varies based on configuration. Key Takeaways: Public Blockchain is ideal for open and trustless environments but has scalability and energy limitations. Private Blockchain suits enterprises needing privacy, control, and efficiency. Consortium Blockchain balances decentralization and control, making it effective for industry collaborations. Hybrid Blockchain offers flexibility for use cases that need both public transparency and private confidentiality. ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/difference-between-types-of-blockchain/","title":"Blockchain technology Difference between types of Blockchain"},{"content":"Difference Between ERC-20 and ERC-721 Tokens Aspect ERC-20 Token ERC-721 Token Definition A standard for fungible tokens on the Ethereum blockchain. A standard for non-fungible tokens (NFTs) on the Ethereum blockchain. Fungibility Fungible, meaning each token is identical and interchangeable with another. Non-fungible, meaning each token is unique and cannot be exchanged on a one-to-one basis. Use Case Primarily used for creating cryptocurrencies, utility tokens, and stablecoins. Used for creating digital collectibles, art, in-game assets, or other unique items. Supply Typically has a fixed or variable total supply, and each unit has the same value. Each token is unique, and there is no requirement for a fixed supply. Each token may have different properties and values. Transferability Tokens can be transferred freely between users, with identical value for all tokens. Each token can be transferred, but its value and uniqueness may vary based on its characteristics. Metadata Metadata (e.g., name, symbol, decimals) is the same for every token in the contract. Each token has unique metadata, often representing ownership of digital assets like art, videos, or virtual goods. Example DAI, USDC, Uniswap (UNI), Tether (USDT). CryptoKitties, Decentraland (LAND), Bored Ape Yacht Club (BAYC). Interoperability ERC-20 tokens can be easily traded on decentralized exchanges (DEXs) and used across decentralized applications (dApps). ERC-721 tokens are more specialized and are typically traded on NFT marketplaces or used within specific dApps. Smart Contract Functions Has functions like totalSupply(), balanceOf(), transfer(), approve(), etc. Has functions like ownerOf(), getApproved(), safeTransferFrom(), etc., to handle the uniqueness of each token. Divisibility ERC-20 tokens are divisible into smaller units (e.g., 1 token = 10^18 wei for Ethereum). ERC-721 tokens are indivisible; each token is a whole unit and cannot be divided. Standardization ERC-20 is widely adopted and used for a variety of purposes, including as a standard for ICOs (Initial Coin Offerings). ERC-721 is specifically designed for NFTs, which represent ownership of unique digital assets. Key Differences Fungibility vs. Non-Fungibility:\nERC-20 tokens are fungible: One token is always equal in value to another. This is ideal for currencies, rewards, or tokens that need to be interchangeable. ERC-721 tokens are non-fungible: Each token is unique and represents something distinct, like a digital artwork, collectible, or item in a game. Use Cases:\nERC-20 tokens are used for cryptocurrencies, utility tokens, and stablecoins (e.g., DAI, USDC, or tokens for accessing specific services). ERC-721 tokens are used for NFTs (Non-Fungible Tokens), which are unique digital items like art, music, and virtual real estate (e.g., CryptoKitties, digital art, in-game items). Supply and Divisibility:\nERC-20 tokens are divisible into smaller units (e.g., 0.0001 tokens), whereas ERC-721 tokens are indivisible (you can only own one whole token at a time). Examples ERC-20 Tokens: DAI: A stablecoin pegged to the value of the US dollar. USDC: A stablecoin backed by the US dollar, issued by Centre. UNI: The governance token for the Uniswap decentralized exchange. ERC-721 Tokens: CryptoKitties: A collection of digital cats that are unique and can be bought, sold, or bred. Bored Ape Yacht Club (BAYC): A collection of 10,000 unique, hand-drawn NFTs with special access privileges for owners. Decentraland (LAND): Virtual real estate in the Decentraland metaverse, represented by unique ERC-721 tokens. Conclusion ERC-20 tokens are primarily used for creating fungible tokens that can be used like currency or for utility purposes. ERC-721 tokens represent unique digital assets or collectibles, offering individuality and ownership over a specific item, typically in the form of NFTs. Both ERC-20 and ERC-721 play essential roles in the Ethereum ecosystem, addressing different needs within the blockchain space.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/erc721-and-erc20/","title":"Blockchain technology ERC721 and ERC20"},{"content":"Here’s a comprehensive breakdown of all the requested aspects of blockchain:\n1. Advantages of Blockchain Decentralization: Eliminates the need for a central authority, allowing peer-to-peer interaction. Transparency: Transactions are visible to all participants, fostering trust. Security: Uses cryptography to secure data, making it tamper-resistant. Immutability: Once recorded, data on the blockchain cannot be altered. Efficiency: Reduces intermediaries, lowering costs and speeding up processes. Traceability: Enables tracking of assets, transactions, or products in real-time. 2. Disadvantages of Blockchain Energy Consumption: PoW-based blockchains (e.g., Bitcoin) require significant energy. Scalability: Handling large transaction volumes can be challenging. Regulation: Lack of clear regulations in many jurisdictions. Storage Issues: Storing the growing blockchain data can be costly. Privacy Concerns: Public blockchains expose transaction details, though pseudonymous. Complexity: Technology can be hard to understand and implement. 3. Features of Blockchain Distributed Ledger: Shared database across all nodes. Decentralization: No central point of control. Immutability: Data cannot be altered after being added to the blockchain. Transparency: All participants have access to the same version of the data. Security: Transactions are secured through cryptographic techniques. Smart Contracts: Self-executing contracts with predefined rules. Consensus Mechanisms: Agreement protocols like PoW, PoS, and DPoS. Anonymity: Participants can transact without revealing identities (in public blockchains). 4. Key Components of Blockchain Blocks: Contains transaction data, block header, Merkle root, etc. Nodes: Devices that participate in the network, storing and validating the blockchain. Consensus Mechanism: Algorithms like Proof of Work (PoW) or Proof of Stake (PoS) to validate transactions. Cryptography: Used to secure transactions and ensure data integrity. Distributed Ledger: A shared database spread across multiple nodes. Smart Contracts: Self-executing contracts coded on the blockchain. 5. Key Points of Blockchain Blockchain is a decentralized, immutable, and distributed ledger technology. Transactions are validated by nodes using consensus mechanisms. Cryptography ensures security and privacy. Blocks are linked via cryptographic hashes, forming a chain. Used in various fields like cryptocurrencies, supply chains, finance, and healthcare. 6. Applications of Blockchain Cryptocurrency: Bitcoin, Ethereum, and other digital currencies rely on blockchain. Supply Chain Management: Tracks product movement and authenticity (e.g., Walmart, IBM Food Trust). Healthcare: Secures patient data and enables medical record sharing. Finance: Facilitates faster cross-border payments and trade finance (e.g., Ripple). Smart Contracts: Automates agreements in insurance, real estate, and more (e.g., Ethereum). Voting Systems: Ensures secure and transparent elections. Digital Identity: Prevents identity theft and provides secure online identification. Energy: Manages energy trading and grid systems (e.g., Power Ledger). 7. Goal of Blockchain The primary goal of blockchain is to create a secure, transparent, and decentralized system that ensures:\nTrust: By removing the need for intermediaries. Efficiency: Faster and cheaper transactions. Immutability: Prevents tampering of recorded data. Accessibility: Enables global participation in decentralized systems. 8. Types of Blockchain Blockchain can be classified into four main types:\na. Public Blockchain Description: Open to everyone; no permission is required to join or participate. Examples: Bitcoin, Ethereum. Use Cases: Cryptocurrencies, public voting, decentralized finance. Advantages: Highly decentralized. Transparent. Disadvantages: Slower transactions. Less privacy. b. Private Blockchain Description: Access is restricted to authorized participants. Examples: Hyperledger Fabric, Corda. Use Cases: Enterprise applications, supply chains, private transactions. Advantages: Higher scalability and speed. Privacy for sensitive data. Disadvantages: Less decentralized. Requires trust in the central authority managing access. c. Consortium Blockchain Description: Controlled by a group of organizations rather than a single entity. Examples: R3 Corda, Quorum. Use Cases: Banking and finance, joint ventures, supply chains. Advantages: Shared control among participants. Scalability and efficiency. Disadvantages: Limited decentralization. Complex governance. d. Hybrid Blockchain Description: Combines public and private blockchain features. Examples: Dragonchain. Use Cases: Real estate, retail, supply chain. Advantages: Flexible. Balance of privacy and transparency. Disadvantages: Complex to implement. May involve centralization. Summary Blockchain is a transformative technology with applications in cryptocurrency, finance, healthcare, and beyond. Its decentralized, secure, and transparent nature makes it highly versatile. However, challenges like scalability and energy consumption must be addressed for widespread adoption. By understanding its components, features, and types, industries can implement blockchain to achieve efficiency, transparency, and trust.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/features-of-blockchain/","title":"Blockchain technology features of blockchain"},{"content":"Here’s a clear comparison between Fungible Tokens (FTs) and Non-Fungible Tokens (NFTs) in a tabular format:\nAspect Fungible Tokens (FTs) Non-Fungible Tokens (NFTs) Definition Tokens that are interchangeable and identical to each other. Tokens that are unique and cannot be exchanged on a one-to-one basis. Interchangeability Fungible tokens are interchangeable; one token is equivalent to another of the same value. Non-fungible tokens are unique and not interchangeable; each one has its own value and characteristics. Example Bitcoin (BTC), Ethereum (ETH), US Dollar (USD) Cryptokitties, Decentraland land, art on OpenSea Divisibility Fungible tokens are divisible into smaller units (e.g., 1 Bitcoin can be divided into 100 million satoshis). NFTs are indivisible; they cannot be divided into smaller units. Usage Used as currency, store of value, or for transferring value. Represent ownership or proof of authenticity of unique items, such as art, collectibles, real estate, etc. Value Determination Value is determined by the market, but all tokens of the same type have the same value. Each NFT has a unique value based on rarity, desirability, and other factors. Standard ERC-20 (Ethereum standard), BEP-20 (Binance Smart Chain) ERC-721, ERC-1155 (Ethereum standards for NFTs) Ownership Ownership is tracked via balance (wallet address), and can represent any amount of the token. Ownership is tracked through a unique token ID, and can represent a specific item or asset. Example in Crypto Bitcoin, Ethereum, Stablecoins Cryptokitties, Digital art, Virtual assets in games Liquidity Highly liquid due to standardized and interchangeable nature. Less liquid, as each NFT is unique and may take longer to find a buyer for specific items. Transferability Easy to transfer and trade in large quantities. Transferable but might require finding a specific buyer for a unique item. Summary Fungible tokens are like traditional money (e.g., USD or BTC), where each unit is identical to another and can be used interchangeably. Non-fungible tokens represent unique digital assets, often linked to specific items or properties (e.g., digital art or virtual real estate), and each token has its own value and distinct characteristics. ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/fungible-tokens-fts-and-non-fungible-tokens-nfts/","title":"Blockchain technology Fungible Tokens (FTs) and Non-Fungible Tokens (NFTs)"},{"content":"Haan bhai, samjhaata hoon simple hinglish mein! 😊\nDouble Spending Problem kya hota hai? Double spending ka matlab hai ek hi digital currency ko ek se zyada baar use karna. Jaise, socho tumhare paas 1 Bitcoin (BTC) hai, aur tum usse:\nVendor X ko bhejte ho. Phir usi BTC ko Vendor Y ko bhejne ki koshish karte ho. Agar yeh possible hota toh system par trust khatam ho jata. Blockchain aur Proof of Work (PoW) isko solve karta hai aur ensure karta hai ki ek hi transaction valid ho.\nProof of Work (PoW) ka role PoW ek system hai jo ensure karta hai ki:\nHar transaction ko verify kiya jaye. Sirf ek valid transaction blockchain mein add ho. Fraud ya cheating karna bahut costly aur mushkil ban jaye. Step-by-Step Process: PoW Double Spending kaise rokega? 1. Transaction Broadcast hoti hai Jab tum kisi ko Bitcoin bhejte ho, toh tumhari transaction pura network (nodes) ko broadcast hoti hai. Har node verify karti hai ki tumhare paas jitne Bitcoin bhejne ka claim kar rahe ho, wo tumhare wallet mein hain ya nahi. 2. Miners block banate hain Miners tumhari transaction aur baaki network ki valid transactions ko uthakar ek block mein dalte hain. Lekin block ko blockchain mein add karne ke liye miners ko ek \u0026ldquo;cryptographic puzzle\u0026rdquo; solve karna padta hai. Isi process ko Proof of Work kehte hain. 3. Competition hoti hai (Mining Race) Jo miner sabse pehle puzzle solve karta hai, wo apne block ko network ke saamne propose karta hai. Baaki nodes us block ko check karti hain ki: Saari transactions valid hain. Miner ka solution sahi hai. Agar sab kuch valid hai, toh wo block blockchain mein add ho jata hai.\n4. Transaction final ho jaati hai Jab tumhari transaction ek block mein add ho jaati hai, toh blockchain mein permanently save ho jaati hai. Baad mein koi us transaction ko modify ya delete nahi kar sakta. 5. Double Spending Impossible ho jaata hai Agar koi banda (malicious user) double spending ki koshish kare aur 2 conflicting transactions (ek Vendor X ke liye aur ek Vendor Y ke liye) bheje: Sirf ek transaction block mein add hogi (jo sabse pehle validate hogi). Doosri transaction reject ho jaayegi, kyunki tumhare wallet mein sufficient funds nahi dikhengi. Double Spending ko aur kaise roka jaata hai? Longest Chain Rule:\nBlockchain mein sabse lambi chain (jisme sabse zyada computational work lagta hai) ko valid maana jaata hai. Agar koi attacker apna block secretly mine karke double spend karne ki koshish karega, toh usse puri chain remine karni padegi, jo practically impossible hai. Cost of Attack:\nAgar koi banda double spending karna chahe, toh usse network ke 51% mining power ka control lena padega (isko 51% Attack kehte hain). Itna mining power ikattha karna aur use karna itna expensive hai ki fraud karke profit karna mushkil ho jaata hai. Confirmations:\nJaise Bitcoin mein transactions ko \u0026ldquo;6 confirmations\u0026rdquo; ke baad final maana jaata hai. Har confirmation ke saath transaction aur zyada secure hoti jaati hai. Ek Example samjho: Tumhare paas 1 BTC hai. Tum 2 transactions create karte ho: Transaction 1: 1 BTC Vendor X ko bhejna. Transaction 2: 1 BTC Vendor Y ko bhejna (double-spending attempt). Kya hoga: Dono transactions network ko bheji jaati hain. Miners sirf ek valid transaction uthayenge (jo pehle network par aayi ya jo wallet balance ke hisaab se valid hai). Wo transaction blockchain mein add ho jaayegi. Double spending wali doosri transaction reject ho jaayegi. PoW ke Benefits Against Double Spending Immutability: Ek baar block add ho gaya, toh usse badalna lagbhag impossible hai. Decentralized Trust: PoW ke wajah se kisi central authority ki zarurat nahi hoti. High Cost of Fraud: Fraud ya cheating karna itna costly hai ki koi karne ki sochta bhi nahi. Summary Double Spending ka problem PoW solve karta hai by: Transactions ko verify karna. Sirf ek transaction ko blockchain mein add karna. Fraudulent transactions ko reject karna. PoW ke wajah se blockchain secure aur trustable hoti hai. Samajh aaya? 😄\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/hinglish-double-spending/","title":"Blockchain technology Hinglish Double spending"},{"content":"Haan bhai, [[State Machine Replication]] ko detail mein samjhata hoon hinglish mein. Chill karke padho. 😎\nState Machine Replication (SMR) ka Basic Funda: SMR ka purpose yeh hai ki distributed systems mein sab machines (ya nodes) ek hi state maintain karein, chahe kuch bhi ho jaye. Jaise blockchain mein sabko ek hi ledger rakhna hai. SMR ka main kaam yeh ensure karna hai ki sab nodes ekdum sync mein hain, aur sabke paas same data hai.\nKaise Kaam Karta Hai? State Machine ka Matlab:\nEk \u0026ldquo;state machine\u0026rdquo; ek aisi machine hai jo input ke hisaab se apni state change karti hai.\nFor example: Agar tere paas ek wallet hai aur tu ₹100 bhejta hai, toh wallet ki state:\nOld State: ₹500 balance Input: ₹100 sent New State: ₹400 balance Yahi process har node replicate karti hai.\nReplication ka Matlab:\nHar node (computer) ko same input aur order mein transactions process karni padti hain. Agar ek transaction ko out-of-order process kiya, toh state alag ho jayegi, aur system fail karega. SMR ke Main Steps in Blockchain: Input Transactions ka Collection:\nSab log (users) transactions bhejte hain network pe. Jaise kisi ne ₹10 transfer kiya, kisi ne NFT bechi, etc. Sab transactions ek pool (mempool) mein ikatthi hoti hain. Consensus Protocol (Agreement):\nSab nodes milke decide karte hain ki konsi transaction pehle process karni hai. Ye decision consensus algorithm se hota hai (e.g., Proof of Work, Proof of Stake, Raft, PBFT). Consensus ensure karta hai ki majority sahi transaction order follow karein. State Update:\nEk node (ya leader) transaction process karke apni state update karta hai. Baaki nodes bhi wahi transaction process karke apni state update karte hain. Jaise hi ek block finalize hota hai, sabki state same hoti hai. Fault Tolerance (Error Handle):\nAgar kuch nodes fail ho jayein (ya galat behave karein), toh bhi system chalti rahegi. SMR algorithms tolerate f up to n/3 malicious nodes (depending on the algorithm, e.g., PBFT). Blockchain ke SMR Example: Transaction:\nSuppose tu ₹50 Alice ko bhej raha hai.\nInput: \u0026ldquo;Bhai ne ₹50 transfer kiya.\u0026rdquo;\nState Machine ka Process:\nOld State: Bhai (₹500), Alice (₹200) Input: ₹50 transfer New State: Bhai (₹450), Alice (₹250) Replication:\nSab nodes ek hi order mein yeh transaction process karenge. Agar kisi ek node ka balance galat update ho raha hai, baaki log usko reject karenge. SMR ke Advantages in Blockchain: Consistency: Sab nodes ka data ekdum sync mein hota hai. Fault Tolerance: Agar kuch nodes corrupt ho gaye, system fail nahi karega. Scalability: Decentralized hone ke bawajood sab ek hi state maintain karte hain. Challenges in SMR: Byzantine Fault Tolerance (BFT):\nMalicious nodes ko ignore karna mushkil hota hai. Blockchain mein iska solution Proof of Work (Bitcoin) ya Proof of Stake (Ethereum) jaisa protocol hai. Latency:\nHar node ko consensus karne mein time lagta hai, jo system ko slow kar sakta hai. Resource Use:\nSabko apni state maintain karni padti hai, jo bandwidth aur storage khata hai. Ek Simple Analogy: Soch, ek cricket match chal raha hai aur sab log apne scorecards likh rahe hain. Sab ek doosre ko dekh ke ensure karte hain ki runs ka count ek hi hai. Agar koi galat likh raha hai, baaki usse correct karte hain. Yahi SMR hai: sabko ek hi \u0026ldquo;truth\u0026rdquo; follow karna hai.\nAgar samajh aa gaya, to cheer maar! 🎉\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/hinglish-smr/","title":"Blockchain technology Hinglish smr"},{"content":"Difference Between Hot Wallet and Cold Wallet Aspect Hot Wallet Cold Wallet Definition A cryptocurrency wallet connected to the internet, allowing for real-time transactions. A cryptocurrency wallet that is offline and not connected to the internet, used for secure storage. Connectivity Online (always connected to the internet). Offline (not connected to the internet). Security Level Lower security due to exposure to hacking risks. Higher security as it is not accessible to online threats. Convenience Highly convenient for frequent transactions. Less convenient due to the need for manual steps to access funds. Use Case Ideal for trading, small amounts of crypto, or daily transactions. Best for long-term storage of large amounts of cryptocurrency. Examples Mobile wallets, desktop wallets, web wallets (e.g., MetaMask, Trust Wallet, Coinbase Wallet). Hardware wallets, paper wallets (e.g., Ledger Nano, Trezor, physical offline storage). Risk of Theft High, as it is vulnerable to phishing, hacking, and malware attacks. Minimal, as it is not exposed to online threats. Backup Requirement Requires strong passwords and regular backups due to its online nature. Requires secure physical storage to prevent loss or theft of the wallet itself. Cost Usually free or low-cost to use. Involves additional cost (e.g., purchasing a hardware wallet). Accessibility Instantly accessible for transactions. Requires physical access and sometimes special hardware to access funds. Recovery Can often be recovered via seed phrases or passwords. Recovery depends on securely stored recovery keys or phrases. Key Considerations Hot Wallets:\nBest for active users who need quick and frequent access to their cryptocurrency. Ensure you enable strong security measures like two-factor authentication (2FA) and use only trusted wallets. Cold Wallets:\nSuitable for long-term holders (\u0026ldquo;HODLers\u0026rdquo;) who prioritize security over convenience. Keep your recovery phrases and hardware wallets in a safe place to prevent loss. Which One Should You Choose? Hot Wallet: Use for everyday transactions, small amounts, or trading. Cold Wallet: Use for storing large amounts of cryptocurrency securely over the long term. Recommendation: A combination of both (a hot wallet for daily use and a cold wallet for secure storage) is often the best approach for managing cryptocurrency effectively.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/hot-wallet-and-cold-wallet/","title":"Blockchain technology hot wallet and cold wallet"},{"content":"Hyperledger is an ==open-source== collaborative effort hosted by the Linux Foundation that focuses on developing frameworks, tools, and libraries for enterprise-grade blockchain systems. Unlike public blockchains like Bitcoin or Ethereum, Hyperledger is designed for permissioned, private blockchain networks where participants are known and trusted.\nKey Goals of Hyperledger Enterprise-Grade Blockchains: Provide scalable and secure solutions tailored for business use cases. Permissioned Access: Networks where only authorized participants can join and interact. Modularity and Customization: Allow businesses to customize the blockchain architecture to their needs. Interoperability: Support communication and data sharing between different blockchain systems. Hyperledger Projects Hyperledger consists of multiple frameworks and tools, each designed for specific blockchain use cases:\n1. Hyperledger Fabric Purpose: A modular and extensible framework for building permissioned blockchain applications. Key Features: Modular architecture (plug-and-play consensus, membership, etc.). Channels for private transactions between subsets of participants. Rich smart contract functionality (Chaincode) in multiple programming languages. Use Cases: Supply chain management, financial services, healthcare. 2. Hyperledger Besu Purpose: An Ethereum client designed for enterprise use. Key Features: Compatible with Ethereum Mainnet and permissioned networks. Supports consensus protocols like Proof of Authority (PoA) and IBFT. Use Cases: Deploying Ethereum-based applications in private or public networks. 3. Hyperledger Sawtooth Purpose: A modular blockchain framework for building customizable distributed ledgers. Key Features: Supports parallel transaction processing for scalability. Consensus algorithm: Proof of Elapsed Time (PoET). Use Cases: IoT applications, retail, and logistics. 4. Hyperledger Indy Purpose: A blockchain framework for decentralized identity management. Key Features: Supports self-sovereign identity systems. Provides tools for managing digital identities and credentials. Use Cases: Digital identity verification, eKYC. 5. Hyperledger Iroha Purpose: A simple and lightweight blockchain framework. Key Features: Focus on mobile and IoT use cases. Pre-defined set of commands for ease of implementation. Use Cases: Asset tracking, IoT ecosystems. 6. Hyperledger Cactus Purpose: Provides interoperability between different blockchain networks. Key Features: Plug-in architecture for connecting different blockchains. Use Cases: Cross-network transactions, data sharing. Features of Hyperledger Platform Permissioned Network: Only authorized participants can access and operate on the network, ensuring greater security and control. Privacy and Confidentiality: Allows private transactions between specific participants using channels or encryption. Smart Contracts: Business logic is implemented using chaincode (in Fabric) or other smart contract mechanisms. Pluggable Consensus: Supports various consensus mechanisms, enabling flexibility for different use cases (e.g., Raft, PoET, PBFT). Scalability: Designed to handle high transaction volumes efficiently. Why Use Hyperledger? Enterprise Focus: Unlike public blockchains, Hyperledger is designed for regulated industries where privacy, compliance, and scalability are critical. Flexibility: Modular architecture lets businesses choose components like consensus, smart contract language, and membership services. Interoperability: Hyperledger tools facilitate seamless interaction with other blockchains and enterprise systems. Support from the Linux Foundation: Robust backing from a globally recognized organization ensures active development and long-term support. Use Cases of Hyperledger Supply Chain Management: Track and trace goods through the supply chain with enhanced transparency and security. Healthcare: Manage patient records securely and enable interoperability between healthcare providers. Financial Services: Enable secure, real-time settlement of financial transactions. Identity Management: Build self-sovereign identity systems to reduce dependency on centralized authorities. IoT: Manage device interactions securely in Internet of Things (IoT) ecosystems. Advantages of Hyperledger High Security: Permissioned networks limit access to trusted participants. Flexibility: Customizable architecture suits diverse business needs. Enterprise-Ready: Designed to handle large-scale business operations with privacy and performance in mind. Interoperability: Facilitates integration with existing systems and other blockchains. Challenges of Hyperledger Complexity: Setting up and managing Hyperledger networks requires technical expertise. Not Decentralized: Permissioned networks are less decentralized compared to public blockchains, which might be a drawback for some use cases. Cost: Requires infrastructure and resources to maintain a permissioned network. Comparison: Hyperledger vs Public Blockchains Feature Hyperledger Public Blockchains (e.g., Bitcoin, Ethereum) Access Permissioned Open to all Consensus Pluggable (e.g., PBFT, Raft) Proof of Work/Proof of Stake Scalability High Moderate to low Privacy High Low Use Case Enterprise Decentralized systems, cryptocurrency Conclusion The Hyperledger platform is a robust, flexible solution for building enterprise-grade blockchain systems. With its modular approach, privacy features, and focus on scalability, Hyperledger is an excellent choice for organizations looking to adopt blockchain technology for specific business applications. While it sacrifices decentralization compared to public blockchains, its permissioned nature makes it ideal for industries like finance, healthcare, and supply chain management.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/hyperledger-platform/","title":"Blockchain technology Hyperledger Platform"},{"content":"What is an Initial Coin Offering (ICO)? An Initial Coin Offering (ICO) is a fundraising mechanism used by cryptocurrency startups to raise capital. It allows developers to sell a portion of their cryptocurrency or tokens to early investors in exchange for capital, typically in the form of Bitcoin (BTC), Ethereum (ETH), or fiat currency.\nICOs are often used to fund the development of new blockchain-based projects, decentralized applications (dApps), or protocols. The tokens sold in an ICO can have various purposes, such as granting access to services, acting as a utility token, or being used for governance within a project.\nHow Does an ICO Work? Announcement and Whitepaper:\nThe project team publishes a whitepaper detailing the project, its goals, the problem it solves, the technical aspects, the tokenomics (how tokens will be distributed), and the project\u0026rsquo;s roadmap. The whitepaper also includes details about the ICO, such as the start and end date, the token\u0026rsquo;s price, and the total supply of tokens. Token Creation:\nThe project team creates a specific number of tokens on a blockchain (usually Ethereum) using a standard such as ERC-20 or ERC-721. Marketing and Promotion:\nICO projects often run marketing campaigns to build hype, attract investors, and gain media attention. The project team might use social media, online forums, and influencers to reach potential backers. The ICO Launch:\nDuring the ICO period, investors can send funds (usually in Bitcoin, Ethereum, or sometimes stablecoins) to the project’s wallet in exchange for the project\u0026rsquo;s tokens. Tokens are distributed either at a fixed price or based on a tiered system, where early investors get a better rate. Fundraising and Development:\nOnce the ICO is completed, the project team uses the raised funds to continue development, marketing, and scaling the project according to the roadmap. Token Listing:\nAfter the ICO, tokens may be listed on cryptocurrency exchanges, allowing investors to trade them on secondary markets. Types of ICOs Public ICO:\nOpen to anyone who wants to participate. Typically involves larger token distributions, and most retail investors can participate with minimal barriers. Private ICO:\nRestricted to a selected group of investors, often venture capitalists or institutional investors. The ICO may offer additional benefits, such as larger token quantities or discounted prices for private investors. Pre-ICO or Seed Round:\nA preliminary round before the main ICO where early supporters or investors can purchase tokens at a discount. Typically aimed at smaller investors or partners. Advantages of ICOs Accessibility: ICOs allow global participation and make it easy for anyone with internet access to invest in the project. Fast Fundraising: ICOs can raise large amounts of capital quickly compared to traditional funding methods like venture capital. Decentralization: Investors can directly fund projects without intermediaries such as banks or crowdfunding platforms. Token Utility: Investors may receive tokens that provide utility within the project or can be traded on exchanges for profit. Risks of ICOs Lack of Regulation: ICOs are not regulated in many countries, making it difficult to ensure transparency and investor protection. Scams and Fraud: Many ICOs have turned out to be fraudulent or have misled investors about their project’s potential (e.g., “rug pulls” where the team disappears with the funds). Security Issues: There can be vulnerabilities in the smart contract or platform used for the ICO, potentially leading to hacking or loss of funds. Market Volatility: After the ICO, tokens may face significant price volatility, and investors may lose a large portion of their investments if the project doesn’t deliver. Uncertain Legal Status: In many jurisdictions, ICOs may face legal scrutiny or regulatory action, especially if the tokens are deemed to be securities. ICO Tokenomics Tokenomics refers to the economic model of the ICO, including:\nTotal Supply: The total number of tokens that will ever exist. Tokens for Sale: The portion of tokens made available during the ICO. Pricing: The price of the tokens, which could vary based on the phase of the ICO. Distribution: How the tokens are allocated (e.g., to the team, early investors, development, reserves, and community incentives). Use of Funds: How the funds raised during the ICO will be used (e.g., development, marketing, partnerships). Example of a Famous ICO Ethereum ICO (2014): One of the most successful ICOs, raising over $18 million (in Bitcoin) to fund the Ethereum blockchain project, which later became one of the largest blockchain platforms in the world.\nTelegram Open Network (TON) ICO: Telegram raised approximately $1.7 billion in a private ICO to fund its blockchain platform, although the project was eventually halted by regulatory challenges from the U.S. Securities and Exchange Commission (SEC).\nConclusion ICOs are an innovative way for cryptocurrency projects to raise funds and engage with the community. However, they come with significant risks, including regulatory uncertainty, fraud, and market volatility. If you\u0026rsquo;re considering participating in an ICO, it’s essential to do thorough research, assess the project\u0026rsquo;s whitepaper, and be cautious about the risks involved.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/initial-coin-offering/","title":"Blockchain technology Initial Coin Offering"},{"content":"What is a Security Token Offering (STO)? A Security Token Offering (STO) is a fundraising method in which companies issue security tokens to investors. Unlike Initial Coin Offerings (ICOs), which typically involve utility tokens, STOs are backed by real-world assets, such as equity, real estate, or debt. Security tokens represent ownership or a stake in a project, making them subject to securities regulations. They provide investors with rights and claims to the underlying assets, such as dividends, voting rights, or profit-sharing.\nSTOs are seen as a more regulated and compliant version of ICOs, as they aim to adhere to existing financial laws and regulations to avoid legal issues, such as those faced by many ICO projects in the past.\nHow Does an STO Work? Token Creation: The issuing company creates security tokens that are linked to real-world assets, such as company equity, profits, or revenue. These tokens are often created using blockchain technology, typically on Ethereum using ERC-1400 or other security token standards. Whitepaper and Legal Framework: Like an ICO, an STO requires a whitepaper, which includes project details, tokenomics, and the use of funds. Legal compliance is a crucial aspect of an STO, with the project ensuring it follows relevant regulations (e.g., Securities and Exchange Commission (SEC) in the U.S., European Securities and Markets Authority (ESMA) in Europe). Legal documents like prospectuses or offering memorandums may be created for investor protection. Fundraising Phase: During the STO, the security tokens are offered to investors in exchange for capital (usually in cryptocurrencies like Bitcoin or Ethereum, or fiat money). The project may set minimum and maximum investment amounts and ensure that only qualified investors (e.g., accredited investors) are allowed to participate, depending on the jurisdiction. Regulatory Compliance: STOs are structured to comply with securities laws. This might involve KYC (Know Your Customer) and AML (Anti-Money Laundering) procedures to prevent fraudulent activities. Securities regulations vary by country, so STOs typically cater to specific jurisdictions and might be available only to accredited investors. Post-STO: After the STO is completed, security tokens are issued and distributed to investors, who can hold or trade them. These tokens may be traded on regulated exchanges or security token exchanges that comply with financial regulations. Key Features of STOs Feature Description Compliance STOs are fully compliant with securities regulations, ensuring legal protection for investors. Security Tokens are backed by real-world assets, such as company equity or profits, offering a higher level of investor protection. Investor Rights Security tokens may provide investors with rights such as dividends, voting rights, or ownership stakes in the project. Transparency The use of blockchain technology ensures transparency, traceability, and immutability of transactions. Regulated Exchanges Security tokens are typically traded on regulated exchanges, offering more liquidity and security compared to ICOs. Ownership Security tokens can represent fractional ownership in real-world assets like equity, real estate, or commodities. Types of Security Tokens Equity Tokens: Represent ownership in a company, similar to shares of stock in traditional finance. Holders may receive dividends and voting rights. Debt Tokens: Represent debt obligations, such as bonds or loans. Holders may receive interest payments over time. Asset-Backed Tokens: Represent ownership or a share in physical or digital assets, such as real estate, commodities, or artwork. Revenue Sharing Tokens: Allow holders to receive a portion of a project\u0026rsquo;s revenue or profits, similar to profit-sharing agreements in traditional business. Advantages of STOs Regulatory Compliance: STOs are compliant with securities regulations, offering greater legal protection for both the issuer and investors, reducing the risk of legal challenges. Transparency and Security: Blockchain ensures that the tokens\u0026rsquo; issuance, transfers, and ownership are transparent and secure, offering traceability and immutability. Access to Global Investors: STOs allow access to a global pool of accredited investors who are interested in legally compliant tokenized assets. Liquidity: Security tokens may be traded on regulated exchanges, providing liquidity and a secondary market for token holders. Fractional Ownership: STOs allow fractional ownership of assets (e.g., real estate, art), lowering the entry barrier for investors who cannot afford whole assets. Efficiency: Using blockchain for the issuance and transfer of tokens reduces administrative costs and streamlines the process compared to traditional securities issuance. Risks of STOs Regulatory Uncertainty: While STOs are legally compliant in many jurisdictions, the regulatory environment is still evolving, and new regulations could affect the market. Legal Costs: The legal requirements for an STO (including compliance with securities laws, KYC, AML, and other procedures) can be costly and time-consuming. Market Liquidity: While security tokens can be traded on regulated exchanges, liquidity may be limited compared to traditional securities or other cryptocurrencies, especially for niche assets. Investor Protection: Even though STOs are regulated, there may still be risks related to fraud or mismanagement of funds by the issuer. STO vs ICO vs IEO Aspect ICO (Initial Coin Offering) STO (Security Token Offering) IEO (Initial Exchange Offering) Token Type Utility tokens (not backed by assets). Security tokens (backed by real-world assets). Can involve utility or security tokens. Regulation Largely unregulated (in many jurisdictions). Fully regulated, compliant with securities laws. Regulated, often listed on an exchange before launch. Investor Protection Low, as ICOs are often unregulated. High, as STOs comply with investor protection laws. Moderate to high, as exchanges vet projects. Target Investors Open to anyone (sometimes restricted). Restricted to accredited or qualified investors. Open to a wider audience, but often requires KYC. Conclusion A Security Token Offering (STO) is an innovative way for companies to raise funds while complying with securities regulations. Unlike ICOs, which offer utility tokens, STOs offer security tokens that represent ownership, equity, or debt in real-world assets. By providing legal compliance, transparency, and the potential for global investment, STOs offer a safer alternative to traditional fundraising methods like IPOs or private placements. However, they also come with regulatory complexities and the need for careful legal planning.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/security-token-offering/","title":"Blockchain technology Security token offering"},{"content":"A smart contract is a self-executing piece of code stored on a blockchain, where the contract\u0026rsquo;s terms and conditions are written directly in code. It automates processes and ensures trustless transactions between parties without the need for intermediaries. Below is a detailed pointwise explanation.\n1. Definition of Smart Contract A computer program or code deployed on a blockchain. It automates, enforces, and executes agreements between parties. Functions as \u0026ldquo;if-then\u0026rdquo; logic: Executes predefined conditions automatically. 2. Characteristics of Smart Contracts Self-Executing: Automatically performs actions when specified conditions are met. Immutable: Once deployed on the blockchain, it cannot be altered. Transparent: Code and execution results are visible to all participants. Decentralized: Operates without relying on a central authority. 3. Key Components Code Logic: Written in programming languages like Solidity (for Ethereum) or Vyper. Contains predefined conditions and instructions for execution. Trigger Events: Events or conditions (e.g., receiving funds, data updates) trigger the contract execution. Blockchain: Stores the smart contract and ensures immutability and transparency. Parties Involved: Two or more entities interact with the smart contract (e.g., buyer and seller). Types of smart contracts smart legal contracts Decentralized applications Distributed autonomous org ([[DAO]]) 4. How Smart Contracts Work Deployment: Developers write the code and deploy the contract to the blockchain. Trigger: A specific event (e.g., payment, timestamp, external API call) activates the contract. Execution: The contract verifies if the conditions are met and then executes the action (e.g., transferring funds, updating data). Recording: Execution results (e.g., state changes) are recorded on the blockchain. 5. Benefits of Smart Contracts Automation: Eliminates manual intervention, reducing errors and delays. Cost-Effective: Removes intermediaries like banks or notaries, saving costs. Trustless: Trust is placed in the blockchain and the contract\u0026rsquo;s logic, not in the parties involved. Security: Cryptographic security ensures tamper-proof execution. Transparency: Code and outcomes are visible to all participants. 6. Challenges of Smart Contracts Immutability: Bugs or vulnerabilities in the code cannot be fixed easily once deployed. Legal Uncertainty: Lack of legal frameworks in some jurisdictions to handle smart contracts. Scalability: Complex contracts can require significant blockchain resources (e.g., high gas fees on Ethereum). Oracles Dependency: Smart contracts rely on oracles for external data, which can be a point of failure. 7. Use Cases of Smart Contracts Finance: Automating loans, insurance payouts, and decentralized finance (DeFi) transactions. Supply Chain: Tracking goods, verifying origins, and automating payments upon delivery. Real Estate: Facilitating property transactions, escrow services, and lease agreements. Healthcare: Securing patient records and automating insurance claims. Voting: Conducting transparent and tamper-proof elections. 8. Popular Platforms Supporting Smart Contracts Ethereum: Pioneer in smart contract functionality. Uses Solidity as its primary programming language. Binance Smart Chain (BSC): Low-cost alternative to Ethereum for deploying smart contracts. Cardano: Focuses on security and scalability for smart contracts. Polkadot: Interoperability for cross-chain smart contract execution. Hyperledger Fabric: Enterprise-focused blockchain for smart contracts. 9. Real-World Example of a Smart Contract Scenario: Car Insurance Claim A user purchases car insurance through a smart contract. The smart contract is connected to a traffic authority\u0026rsquo;s database (via an oracle). If an accident is detected and verified, the smart contract triggers an automatic payout to the user. 10. Key Comparison: Smart Contracts vs Traditional Contracts Aspect Smart Contract Traditional Contract Execution Automated (code-based). Manual (requires intermediaries). Speed Instant upon condition fulfillment. Time-consuming due to human processes. Cost Low (no intermediaries). High (involves third parties). Security Blockchain-based, tamper-proof. Vulnerable to fraud and manipulation. Conclusion Smart contracts are the backbone of modern blockchain systems, enabling automation, transparency, and security for various applications. However, challenges like scalability, legal adoption, and dependency on external data need further development to achieve widespread use.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/smart-contract/","title":"Blockchain technology Smart Contract"},{"content":"State Machine Replication (SMR) in Detail [[Hinglish smr]] State Machine Replication (SMR) is a distributed computing technique that ensures fault tolerance and consistency across a network of nodes by maintaining multiple ==replicas== ==of a state machine==. Each replica processes the same sequence of operations (or transactions) in the same order, ensuring they all stay in sync with one another.\nThis concept is foundational in ==blockchain technology== and ==distributed systems==, where achieving consistency and reliability across nodes is critical.\nKey Concepts in State Machine Replication State Machine: A state machine is an abstract system that transitions between a series of well-defined states based on incoming inputs or commands. For example, a bank account\u0026rsquo;s balance (state) changes when transactions (inputs) like deposits or withdrawals are processed. Replication: In SMR, multiple copies (or replicas) of the state machine exist across different nodes in a distributed system. These replicas must stay synchronized to ensure consistent outcomes. Deterministic Behavior: The state machine must behave deterministically, meaning that given the same initial state and sequence of inputs, it will always produce the same final state. Consensus Mechanism: To maintain consistency among replicas, all nodes must agree on the order of operations using a consensus protocol (e.g., PBFT, Raft, or blockchain consensus like PoW). How State Machine Replication Works Initialization: All replicas start with the same initial state (e.g., an empty ledger or a balance of zero in all accounts). Input Requests: Clients send input commands (e.g., a transaction) to the distributed system. Consensus on Order: The system ensures that all replicas agree on the order of incoming commands using a consensus protocol. This guarantees that every replica processes the commands in the same order. Processing Commands: Each replica processes the commands sequentially in the agreed-upon order. Because the system is deterministic, all replicas reach the same state after processing the commands. Output Responses: The replicas send consistent responses back to the clients. Fault Tolerance: If some replicas fail or behave maliciously (e.g., by providing incorrect outputs), the system tolerates these faults as long as a majority of the replicas remain honest and functional. Importance of State Machine Replication State Machine Replication is crucial in systems that require:\nFault Tolerance: Ensures the system remains operational even if some nodes fail. Consistency: Guarantees that all nodes agree on the same state, avoiding conflicts or inconsistencies. Reliability: Provides a consistent service to clients, regardless of node failures or malicious behavior. State Machine Replication in Blockchain Blockchains use SMR principles to maintain a distributed ledger:\nReplicas: Each node (or miner/validator) maintains a copy of the blockchain, which represents the state machine. Inputs: Transactions are the inputs to the blockchain\u0026rsquo;s state machine. Consensus Mechanism: Protocols like Proof of Work (PoW), Proof of Stake (PoS), or Practical Byzantine Fault Tolerance (PBFT) ensure all nodes agree on the order of transactions. Deterministic Execution: Smart contracts or scripts on the blockchain are deterministic, ensuring all nodes produce the same results when processing transactions. Types of Faults Addressed by SMR Crash Faults: Nodes that stop functioning due to hardware or software failures. Handled by replication since other nodes continue to operate. Byzantine Faults: Malicious or arbitrary behavior by nodes (e.g., providing incorrect results). Addressed using Byzantine Fault Tolerant (BFT) consensus mechanisms. Advantages of State Machine Replication Fault Tolerance: The system continues to function even if some nodes fail or act maliciously. High Availability: Distributed replicas ensure the system is always operational. Consistency: All replicas have the same state, preventing discrepancies. Scalability: SMR scales well across distributed networks. Challenges of State Machine Replication Consensus Overhead: Achieving agreement among replicas requires significant communication, especially in Byzantine environments. Determinism Requirement: Non-deterministic processes (e.g., relying on random numbers) can cause divergence among replicas. Latency: Consensus mechanisms can introduce delays, reducing the system\u0026rsquo;s responsiveness. Fault Tolerance Limits: In Byzantine Fault Tolerant systems, SMR can only tolerate up to f faulty nodes in a system with 3f + 1 total nodes. Real-World Applications of SMR Blockchain Networks: Bitcoin, Ethereum, and other blockchains use SMR to replicate their ledgers across nodes. Distributed Databases: Systems like Google Spanner and Amazon DynamoDB use SMR to ensure consistent data across distributed servers. Financial Systems: High-value financial applications use SMR to ensure consistent and fault-tolerant transaction processing. Cloud Services: Cloud platforms replicate virtual machines or databases using SMR principles. Conclusion State Machine Replication is a foundational concept for achieving consistency, fault tolerance, and reliability in distributed systems. It plays a critical role in blockchain technology, ensuring that every node in the network maintains an identical copy of the ledger or state. By combining replication with consensus mechanisms, SMR provides a robust framework for modern decentralized applications and services.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/state-machine-replication/","title":"Blockchain technology State Machine Replication"},{"content":"Blockchain technology can be classified into four main types based on how the network is structured, the level of access it provides, and its use cases. These types include Public Blockchain, Private Blockchain, Consortium Blockchain, and Hybrid Blockchain.\n1. Public Blockchain A public blockchain is a ==decentralized and open-to-all network==, where ==anyone can participate in the consensus process, read, and write data on the blockchain==.\nKey Features Fully decentralized. ==No access restrictions==—anyone can join, validate transactions, and create blocks. Data is immutable and transparent. Secured by cryptographic algorithms and consensus mechanisms like Proof of Work (PoW) or Proof of Stake (PoS). Advantages Transparency: All transactions are visible to anyone. Security: High security due to decentralization and cryptographic protocols. Trustless System: No intermediaries or trusted third parties are required. Disadvantages Scalability Issues: Slow transaction processing due to the large number of participants. Energy Consumption: PoW consensus consumes significant energy. Lack of Privacy: All transactions are visible to the public. Use Cases Cryptocurrencies like Bitcoin and Ethereum. Decentralized finance (DeFi) platforms. Public voting systems and identity verification. 2. Private Blockchain A private blockchain is a ==permissioned network== where ==access is restricted to selected participants==. ==Only authorized nodes can validate, create, or read transactions==.\nKey Features Controlled by a single organization or entity. Faster transactions and better scalability compared to public blockchains. High levels of privacy since access is restricted. Limited decentralization as the network is managed by a central authority. Advantages Efficiency: Faster transaction speeds due to fewer participants. Privacy: Only authorized participants can view the data. Control: Centralized authority ensures control and governance. Disadvantages Centralization: Relies on a single entity, which may lead to trust issues. Limited Transparency: Data is visible only to authorized users. Regulation: May not adhere to the decentralized principles of blockchain. Use Cases Enterprise applications in industries like banking, healthcare, and supply chain. Secure storage of sensitive data. Internal organization processes like auditing and voting. Examples ==Hyperledger Fabric: A private blockchain framework for enterprises==. Corda: A blockchain platform focused on financial institutions. 3. Consortium Blockchain A consortium blockchain (or federated blockchain) is a ==semi-decentralized blockchain where multiple organizations jointly manage the network==. Unlike a private blockchain controlled by one entity, a ==consortium blockchain shares control among a predefined group of participants.==\nKey Features ==Restricted access, but managed by multiple entities==. Collaborative decision-making for governance. Semi-decentralized structure. Advantages Shared Control: Multiple organizations work together, reducing reliance on one party. Scalability: Faster and more scalable than public blockchains. Trust Between Members: Trust is established among consortium members. Disadvantages Complex Governance: Reaching consensus among multiple organizations can be challenging. Less Transparency: Access is restricted, reducing transparency for the general public. Semi-Decentralization: Less decentralized compared to public blockchains. Use Cases Banking and finance (e.g., cross-border payments and settlements). Supply chain management for tracking goods across companies. Collaborative industries, such as healthcare or energy grids. Examples R3 Corda: Used by financial institutions for secure transactions. Quorum: A permissioned blockchain developed by J.P. Morgan. 4. Hybrid Blockchain A hybrid blockchain ==combines elements of both public and private blockchains==. It allows certain data to remain public while keeping other data private. This flexibility makes it suitable for applications requiring both transparency and confidentiality.\nKey Features Combines public and private blockchain features. Controlled access with a permissioned layer but retains some transparency. Users can participate in the public network while accessing private features. Advantages Flexibility: Balances transparency and privacy based on use cases. Scalability: Faster transaction speeds compared to public blockchains. Security: Leverages the security benefits of both public and private blockchains. Disadvantages Complexity: Implementing and maintaining a hybrid blockchain is challenging. Potential Centralization: The private aspect may result in less decentralization. Governance: Managing public-private interactions can be tricky. Use Cases Real estate: Publicly verifying ownership while keeping transaction details private. Retail: Transparent supply chain with private customer data. Healthcare: Public access to research data but restricted access to patient records. Examples Dragonchain: A hybrid blockchain for businesses to maintain control over sensitive data. Comparison of Blockchain Types Feature Public Blockchain Private Blockchain Consortium Blockchain Hybrid Blockchain Decentralization Fully decentralized Centralized Semi-decentralized Partially decentralized Access Open to all Restricted Restricted to group Combination of both Speed Slow Fast Fast Moderate Transparency Fully transparent Limited Limited Controlled transparency Scalability Low High High High Governance Community-driven Central authority Multiple organizations Shared Security High High High Moderate to High Use Cases Cryptocurrency, DeFi Enterprise solutions Banking, Supply Chain Retail, Real Estate, Health Key Points Summary Public Blockchains: Ideal for open, decentralized systems like cryptocurrencies. Private Blockchains: Suitable for enterprises requiring privacy and control. Consortium Blockchains: Perfect for collaborative industries like banking and supply chain management. Hybrid Blockchains: Versatile and useful for balancing transparency and confidentiality. Each type of blockchain is tailored for specific use cases, allowing industries to adopt blockchain technology based on their unique needs.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/types-of-blockchain/","title":"Blockchain technology Types of blockchain"},{"content":"What is UTXO? UTXO stands for ==Unspent Transaction Output==. It is a fundamental concept in blockchain technology, particularly used in ==Bitcoin== and other cryptocurrencies like ==Litecoin==.\nIn simple terms, a ==UTXO represents the amount of cryptocurrency that has been sent to a wallet, but has not yet been spent. It’s the equivalent of a “coin” in the digital world. When a transaction is made, the amount of cryptocurrency involved in the transaction is output as a UTXO. This UTXO can later be used as input for future transactions==.\nHow UTXO Works Transaction Creation: When ==someone receives a transaction, it’s recorded on the blockchain as an output.== ==This output is the amount sent to the recipient, and it is considered a UTXO (because it hasn’t been spent yet).== Spending UTXOs: When the recipient wants to spend the funds (i.e., send it to someone else), they use their UTXO as an input for a new transaction. The new transaction will reference the UTXO, indicating that the funds are being spent. Once the UTXO is used, it’s marked as “spent” and cannot be reused in future transactions. Change: If the amount of the transaction exceeds the value of the UTXO used as input, the change is returned to the sender as a new UTXO. This change is often sent to the sender’s wallet as a new unspent output. UTXO Model vs Account-based Model UTXO Model (Used by Bitcoin):\nIn the UTXO model, each transaction consumes a UTXO (inputs) and creates new UTXOs (outputs). The blockchain keeps track of all UTXOs as the record of how much cryptocurrency each wallet holds. A wallet does not directly hold a balance, but rather a collection of UTXOs that represent its balance. Account-based Model (Used by Ethereum):\nIn the account-based model, a user’s balance is tracked directly, and transactions are conducted by updating the balance. In this system, wallets hold a direct balance that gets incremented or decremented with each transaction. Key Characteristics of UTXO Feature Description Decentralization UTXOs are tracked on the blockchain, allowing for decentralized, peer-to-peer transactions without intermediaries. Immutability Once a UTXO is created and confirmed in a block, it cannot be altered or changed. No Direct Account Balance Users don\u0026rsquo;t have a balance; instead, they have a collection of unspent outputs (UTXOs). Privacy Since the UTXO model doesn\u0026rsquo;t directly track a wallet\u0026rsquo;s balance, it offers a higher level of privacy compared to account-based systems. Efficiency The UTXO model makes transaction validation more efficient, as the system only needs to check the inputs and outputs. Advantages of the UTXO Model Enhanced Privacy:\nSince UTXOs are independent and do not have an associated identity like an account, it’s more difficult to track and link transactions to a specific individual. Security:\nEach UTXO is validated before it is spent. This makes it harder for someone to spend funds they don\u0026rsquo;t own, as they would need to present a valid signature for each UTXO. Efficiency in Verification:\nBitcoin’s UTXO model allows for a more efficient process in validating transactions, as each transaction consumes a defined input (a specific UTXO), making the process clearer and easier to verify by nodes. Example of UTXO in a Transaction Let’s say you own 3 Bitcoin UTXOs:\nUTXO 1: 0.5 BTC UTXO 2: 0.7 BTC UTXO 3: 1.0 BTC You want to send 0.8 BTC to a friend. Here’s how the transaction would work:\nInput: You use UTXO 2 (0.7 BTC) and UTXO 3 (1.0 BTC) as inputs. Together, they sum to 1.7 BTC. Output: You send 0.8 BTC to your friend. The remaining 0.9 BTC becomes the change that is sent back to your wallet as a new UTXO. New UTXO: 0.9 BTC (the change you get back) Transaction Result: Your wallet now holds a new UTXO (0.9 BTC) and the transaction is completed. In this case, the UTXOs you had earlier (0.7 BTC and 1.0 BTC) are now marked as “spent,” and the blockchain records the new unspent output (0.9 BTC) as part of your wallet balance.\nBenefits and Drawbacks of UTXO Model Benefits: Auditability: UTXOs provide a clear view of how funds are being spent. Robust Security: Each UTXO is individually signed and validated, making it harder for malicious actors to spend funds fraudulently. Scalability: Since transaction inputs and outputs are separate entities, the UTXO model can handle complex transactions more efficiently. Drawbacks: Transaction Size: The more UTXOs a wallet holds, the larger and more complex the transaction will be when sending funds, leading to higher transaction fees. Management Complexity: Managing multiple UTXOs can become cumbersome, especially for users who have many small, unspent transactions in their wallets. Conclusion UTXO is a key concept in cryptocurrencies like Bitcoin, providing a way to track and manage the ownership of digital assets. Instead of tracking balances, the UTXO model uses outputs from previous transactions as inputs for future transactions. While this model offers greater privacy, security, and decentralization, it can also introduce complexities when managing a large number of small UTXOs. However, its use in Bitcoin and other cryptocurrencies has proven to be effective for ensuring robust, secure, and verifiable transactions.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/utxo/","title":"Blockchain technology UTXO"},{"content":"https://learn.microsoft.com/en-us/training/paths/github-foundations/\nhttps://www.exampro.co/github-foundations\\\nversion control system is also call software control management\nSetup username and useremail\ngit config --global user.name \u0026#34;\u0026lt;USER_NAME\u0026gt;\u0026#34; git config --global user.email \u0026#34;\u0026lt;USER_EMAIL\u0026gt;\u0026#34; initialize dir and make branch main\ngit init --initial-branch=main or\ngit init -b main Alternatively, you can create a new branch and check it out by using git in a terminal. The command would be git checkout -b newBranchName\nstatus\ngit status git add is the command you use to tell Git to start keeping track of changes in certain files.\ngit add . ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/certifications/github-foundation/","title":"certifications Github foundation"},{"content":"[[RNN]] [[LSTM]] [[GRU]] [[vanishing and exploding gradient ]] [[AutoEncoders]] [[gradient Descent problem]] [[LeNet]] [[AlexNet]]\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/deep-learning/1.-important-topics/","title":"Deep Learning 1  Important Topics"},{"content":"==Gradient Descent is an optimization algorithm ==widely used in deep learning to ==minimize a model\u0026rsquo;s loss function==, which ==measures the error between the predicted and actual values==. By ==iteratively adjusting the model’s parameters (weights and biases), gradient descent finds the optimal parameter values that reduce the error and improve model performance==. Here’s a breakdown of gradient descent in detail:\n1. Definition of Gradient Descent Gradient Descent is an iterative optimization algorithm used to minimize a function, often a loss function in deep learning, by updating parameters in the direction of the negative gradient. Objective: Minimize the model’s error by finding parameter values that lead to the ==lowest possible loss.== 2. How Gradient Descent Works Gradient: In calculus, ==the gradient is a vector of partial derivatives with respect to the function\u0026rsquo;s parameters.== It ==indicates the direction and rate of change of the function.== Descent: The algorithm moves in the direction opposite to the gradient, hence \u0026ldquo;descent,\u0026rdquo; to find the function\u0026rsquo;s minimum. Steps of Gradient Descent: Compute the Gradient: Calculate the gradient of the loss function with respect to each parameter. This gradient points in the direction of the steepest increase. Update Parameters: Move the parameters in the opposite direction of the gradient by a small step size, known as the learning rate. Repeat: Repeat the process until the loss converges to a minimum or a specified number of iterations is reached. 3. Mathematical Formulation For a loss function ( L(\\theta) ) with parameters ( \\theta ), the gradient descent update rule is: [ $\\theta = \\theta - \\alpha \\cdot \\nabla_{\\theta} L(\\theta)$ ] Here, $( \\nabla_{\\theta} L(\\theta) )$ is the gradient of the loss function with respect to ( \\theta ), and ( \\alpha ) is the learning rate, a hyperparameter that controls the step size. 4. Types of Gradient Descent Batch Gradient Descent:\nUses the entire dataset to calculate the gradient for each iteration. Provides accurate gradient estimates but can be slow and computationally expensive for large datasets. Stochastic Gradient Descent (SGD):\nUpdates parameters using only one randomly selected data point per iteration. Faster than batch gradient descent, but can be noisy and may not converge smoothly. Benefit: The noise can help escape local minima and find better solutions. Mini-Batch Gradient Descent:\nCombines aspects of batch and stochastic gradient descent by dividing the dataset into smaller \u0026ldquo;mini-batches\u0026rdquo; and computing gradients for each batch. Balances the computational efficiency of batch gradient descent with the convergence benefits of SGD, making it a popular choice in deep learning. 5. Learning Rate and Its Importance The learning rate ( \\alpha ) controls the step size in each update. Choosing an appropriate learning rate is crucial: Too High: If the learning rate is too high, the model may overshoot the minimum, causing unstable training or divergence. Too Low: If the learning rate is too low, convergence may be very slow, and the model might get stuck in local minima. Adaptive Learning Rates: Techniques like Adam, RMSprop, and AdaGrad adaptively adjust the learning rate during training to improve convergence. 6. Challenges in Gradient Descent Local Minima: Gradient descent can sometimes converge to a local minimum instead of the global minimum, especially in non-convex functions. Saddle Points: Flat regions in the loss landscape where gradients are very small can slow down convergence. Vanishing and Exploding Gradients: In deep networks, gradients can become very small (vanish) or very large (explode), making training difficult. This is particularly a problem in RNNs. 7. Optimized Variants of Gradient Descent Momentum: Adds a fraction of the previous update to the current update to accelerate convergence. Adam (Adaptive Moment Estimation): Combines ideas from momentum and RMSprop, using both adaptive learning rates and momentum to improve convergence. RMSprop: Adjusts learning rates for each parameter based on the moving average of recent gradient magnitudes, making it especially useful for non-stationary objectives. 8. Applications of Gradient Descent in Deep Learning Used to train neural networks in tasks like image recognition, natural language processing, and speech recognition. Applicable in unsupervised, supervised, and reinforcement learning settings for optimizing complex models with millions of parameters. 9. Advantages and Limitations of Gradient Descent Advantages: It is a foundational, general-purpose optimization algorithm that works across a wide range of machine learning and deep learning tasks. Efficient for large datasets, especially when using mini-batch or stochastic versions. Limitations: Requires careful tuning of the learning rate and may converge to local minima in non-convex functions. Sensitive to the choice of hyperparameters and may suffer from slow convergence without optimizations like momentum or adaptive learning rates. Summary for Exam Answer Define gradient descent as an optimization algorithm used for minimizing the loss function in deep learning. Explain how it works through gradient computation and parameter updates. Describe types: batch, stochastic, and mini-batch gradient descent. Discuss the importance of the learning rate and challenges like local minima and vanishing gradients. Mention advanced variants like Adam and RMSprop for improving convergence. This answer provides a structured overview of gradient descent in deep learning, covering key points for a 10-mark exam response.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/deep-learning/gradient-descent-problem/","title":"Deep Learning gradient Descent problem"},{"content":"[[Shell-Scripting Index]]\n[[Git Index]]\n[[Docker Index]]\n[[Linux Index]]\n[[Jenkins Index]]\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/devops---cloud/1.-devops-index/","title":"DevOps - Cloud 1  DevOps Index"},{"content":"A bind mount will allow you to map a directory from your local filesystem to the container. This way, when you make changes to the code locally, they will immediately reflect in the container.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/devops---cloud/docker/bind-mount-volume/","title":"Docker bind mount volume"},{"content":"[[bind mount volume]] Docker Installation sudo apt install -y apt-transport-https ca-certificates curl software-properties-common curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null sudo apt update sudo apt install -y docker-ce docker-ce-cli containerd.io Docker compose installation sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose Docker build any image docker build -t myimage . docker run -d -p 5173:5173 -v /home/yash/Desktop/obsidiangraph/graphnotes:/app \u0026ndash;name oopsidian oopsidian\nto run docker container in specific port and allocate volume to it and also name it command :\ndocker run -d -p 8080:9000 -v /host/volume:/containervolume --name container_name image command to access the container\u0026rsquo;s shell\ndocker exec -it containername /bin/bash ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/devops---cloud/docker/docker-index/","title":"Docker Docker Index"},{"content":"/*\nAbout the slideshow script The script will convert your drawing into a slideshow presentation. Presentation options If you select an arrow or line element, the script will use that as the presentation path. If you select nothing, but the file has a hidden presentation path, the script will use that for determining the slide sequence. If there are frames, the script will use the frames for the presentation. Frames are played in alphabetical order of their titles. Keyboard shortcuts and modifier keys Forward: Arrow Down, Arrow Right, or SPACE Backward: Arrow Up, Arrow Left Finish presentation: Backspace, ESC (I had issues with ESC not working in full screen presentation mode on Mac)\nRun presentation in a window: Hold down the ALT/OPT modifier key when clicking the presentation script button Continue presentation: Hold down SHIFT when clicking the presentation script button. (The feature also works in combination with the ALT/OPT modifier to start the presentation in a window). The feature will only resume while you are within the same Obsidian session (i.e. if you restart Obsidian, slideshow will no longer remember where you were). I have two use cases in mind for this feature:\nWhen you are designing your presentation you may want to test how a slide looks. Using this feature you can get back to where you left off by starting the presentation with SHIFT. During presentation you may want to exit presentation mode to show something additional to your audience. You stop the presentation, show the additional thing you wanted, now you want to continue from where you left off. Hold down SHIFT when clicking the slideshow button. */ if(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(\u0026#34;2.1.7\u0026#34;)) { new Notice(\u0026#34;This script requires a newer version of Excalidraw. Please install the latest version.\u0026#34;); return; } const hostLeaf = ea.targetView.leaf; const hostView = hostLeaf.view; const statusBarElement = document.querySelector(\u0026#34;div.status-bar\u0026#34;); const ctrlKey = ea.targetView.modifierKeyDown.ctrlKey || ea.targetView.modifierKeyDown.metaKey; const altKey = ea.targetView.modifierKeyDown.altKey || ctrlKey; const shiftKey = ea.targetView.modifierKeyDown.shiftKey; const shouldStartWithLastSlide = shiftKey \u0026amp;\u0026amp; window.ExcalidrawSlideshow \u0026amp;\u0026amp; (window.ExcalidrawSlideshow.script === utils.scriptFile.path) \u0026amp;\u0026amp; (typeof window.ExcalidrawSlideshow.slide === \u0026#34;number\u0026#34;) //------------------------------- //constants //------------------------------- const TRANSITION_STEP_COUNT = 100; const TRANSITION_DELAY = 1000; //maximum time for transition between slides in milliseconds const FRAME_SLEEP = 1; //milliseconds const EDIT_ZOOMOUT = 0.7; //70% of original slide zoom, set to a value between 1 and 0 const FADE_LEVEL = 0.1; //opacity of the slideshow controls after fade delay (value between 0 and 1) //using outerHTML because the SVG object returned by Obsidin is in the main workspace window //but excalidraw might be open in a popout window which has a different document object const SVG_COG = ea.obsidian.getIcon(\u0026#34;lucide-settings\u0026#34;).outerHTML; const SVG_FINISH = ea.obsidian.getIcon(\u0026#34;lucide-x\u0026#34;).outerHTML; const SVG_RIGHT_ARROW = ea.obsidian.getIcon(\u0026#34;lucide-arrow-right\u0026#34;).outerHTML; const SVG_LEFT_ARROW = ea.obsidian.getIcon(\u0026#34;lucide-arrow-left\u0026#34;).outerHTML; const SVG_EDIT = ea.obsidian.getIcon(\u0026#34;lucide-pencil\u0026#34;).outerHTML; const SVG_MAXIMIZE = ea.obsidian.getIcon(\u0026#34;lucide-maximize\u0026#34;).outerHTML; const SVG_MINIMIZE = ea.obsidian.getIcon(\u0026#34;lucide-minimize\u0026#34;).outerHTML; const SVG_LASER_ON = ea.obsidian.getIcon(\u0026#34;lucide-hand\u0026#34;).outerHTML; const SVG_LASER_OFF = ea.obsidian.getIcon(\u0026#34;lucide-wand\u0026#34;).outerHTML; //------------------------------- //utility \u0026amp; convenience functions //------------------------------- let isLaserOn = false; let slide = shouldStartWithLastSlide ? window.ExcalidrawSlideshow.slide : 0; let isFullscreen = false; const ownerDocument = ea.targetView.ownerDocument; const startFullscreen = !altKey; //The plugin and Obsidian App run in the window object //When Excalidraw is open in a popout window, the Excalidraw component will run in the ownerWindow //and in this case ownerWindow !== window //For this reason event handlers are distributed between window and owner window depending on their role const ownerWindow = ea.targetView.ownerWindow; const excalidrawAPI = ea.getExcalidrawAPI(); const frameRenderingOriginalState = excalidrawAPI.getAppState().frameRendering; const contentEl = ea.targetView.contentEl; const sleep = async (ms) =\u0026gt; new Promise((resolve) =\u0026gt; ownerWindow.setTimeout(resolve, ms)); const getFrameName = (name, index) =\u0026gt; name ?? `Frame ${(index+1).toString().padStart(2, \u0026#39;0\u0026#39;)}`; //------------------------------- //clean up potential clutter from previous run //------------------------------- window.removePresentationEventHandlers?.(); //1. check if line or arrow is selected, if not check if frames are available, if not inform the user and terminate presentation let presentationPathLineEl = ea.getViewElements() .filter(el=\u0026gt;[\u0026#34;line\u0026#34;,\u0026#34;arrow\u0026#34;].contains(el.type) \u0026amp;\u0026amp; el.customData?.slideshow)[0]; const frameClones = []; ea.getViewElements().filter(el=\u0026gt;el.type===\u0026#34;frame\u0026#34;).forEach(f=\u0026gt;frameClones.push(ea.cloneElement(f))); for(i=0;i\u0026lt;frameClones.length;i++) { frameClones[i].name = getFrameName(frameClones[i].name,i); } let frames = frameClones .sort((el1,el2)=\u0026gt; el1.name \u0026gt; el2.name ? 1:-1); let presentationPathType = \u0026#34;line\u0026#34;; // \u0026#34;frame\u0026#34; const selectedEl = ea.getViewSelectedElement(); let shouldHideArrowAfterPresentation = true; //this controls if the hide arrow button is available in settings if(presentationPathLineEl \u0026amp;\u0026amp; selectedEl \u0026amp;\u0026amp; [\u0026#34;line\u0026#34;,\u0026#34;arrow\u0026#34;].contains(selectedEl.type)) { excalidrawAPI.setToast({ message:\u0026#34;Using selected line instead of hidden line. Note that there is a hidden presentation path for this drawing. Run the slideshow script without selecting any elements to access the hidden presentation path\u0026#34;, duration: 5000, closable: true }) shouldHideArrowAfterPresentation = false; presentationPathLineEl = selectedEl; } if(!presentationPathLineEl) presentationPathLineEl = selectedEl; if(!presentationPathLineEl || ![\u0026#34;line\u0026#34;,\u0026#34;arrow\u0026#34;].contains(presentationPathLineEl.type)) { if(frames.length \u0026gt; 0) { presentationPathType = \u0026#34;frame\u0026#34;; } else { excalidrawAPI.setToast({ message:\u0026#34;Please select the line or arrow for the presentation path or add frames.\u0026#34;, duration: 3000, closable: true }) return; } } //--------------------------------------------- // generate slides[] array //--------------------------------------------- let slides = []; if(presentationPathType === \u0026#34;line\u0026#34;) { const getLineSlideRect = ({pointA, pointB}) =\u0026gt; { const x1 = presentationPathLineEl.x+pointA[0]; const y1 = presentationPathLineEl.y+pointA[1]; const x2 = presentationPathLineEl.x+pointB[0]; const y2 = presentationPathLineEl.y+pointB[1]; return { x1, y1, x2, y2}; } const slideCount = Math.floor(presentationPathLineEl.points.length/2)-1; for(i=0;i\u0026lt;=slideCount;i++) { slides.push(getLineSlideRect({ pointA:presentationPathLineEl.points[i*2], pointB:presentationPathLineEl.points[i*2+1] })) } } if(presentationPathType === \u0026#34;frame\u0026#34;) { for(frame of frames) { slides.push({ x1: frame.x, y1: frame.y, x2: frame.x + frame.width, y2: frame.y + frame.height }); } if(frameRenderingOriginalState.enabled) { excalidrawAPI.updateScene({ appState: { frameRendering: { ...frameRenderingOriginalState, enabled: false } } }); } } //--------------------------------------- // Toggle fullscreen //--------------------------------------- let toggleFullscreenButton; let controlPanelEl; let selectSlideDropdown; const resetControlPanelElPosition = () =\u0026gt; { if(!controlPanelEl) return; const top = contentEl.innerHeight; const left = contentEl.innerWidth/2; controlPanelEl.style.top = `calc(${top}px - var(--default-button-size)*2)`; controlPanelEl.style.left = `calc(${left}px - var(--default-button-size)*5)`; slide--; navigate(\u0026#34;fwd\u0026#34;); } const waitForExcalidrawResize = async () =\u0026gt; { await sleep(100); const deltaWidth = () =\u0026gt; Math.abs(contentEl.clientWidth-excalidrawAPI.getAppState().width); const deltaHeight = () =\u0026gt; Math.abs(contentEl.clientHeight-excalidrawAPI.getAppState().height); let watchdog = 0; while ((deltaWidth()\u0026gt;50 || deltaHeight()\u0026gt;50) \u0026amp;\u0026amp; watchdog++\u0026lt;20) await sleep(50); //wait for Excalidraw to resize to fullscreen } let preventFullscreenExit = true; const gotoFullscreen = async () =\u0026gt; { if(isFullscreen) return; preventFullscreenExit = true; if(ea.DEVICE.isMobile) { ea.viewToggleFullScreen(); } else { await contentEl.webkitRequestFullscreen(); } await waitForExcalidrawResize(); const layerUIWrapper = contentEl.querySelector(\u0026#34;.layer-ui__wrapper\u0026#34;); if(!layerUIWrapper.hasClass(\u0026#34;excalidraw-hidden\u0026#34;)) layerUIWrapper.addClass(\u0026#34;excalidraw-hidden\u0026#34;); if(toggleFullscreenButton) toggleFullscreenButton.innerHTML = SVG_MINIMIZE; resetControlPanelElPosition(); isFullscreen = true; } const exitFullscreen = async () =\u0026gt; { if(!isFullscreen) return; preventFullscreenExit = true; if(!ea.DEVICE.isMobile \u0026amp;\u0026amp; ownerDocument?.fullscreenElement) await ownerDocument.exitFullscreen(); if(ea.DEVICE.isMobile) ea.viewToggleFullScreen(); if(toggleFullscreenButton) toggleFullscreenButton.innerHTML = SVG_MAXIMIZE; await waitForExcalidrawResize(); resetControlPanelElPosition(); isFullscreen = false; } const toggleFullscreen = async () =\u0026gt; { if (isFullscreen) { await exitFullscreen(); } else { await gotoFullscreen(); } } //----------------------------------------------------- // hide the arrow for the duration of the presentation // and save the arrow color before doing so //----------------------------------------------------- let isHidden; let originalProps; const toggleArrowVisibility = async (setToHidden) =\u0026gt; { ea.clear(); ea.copyViewElementsToEAforEditing(ea.getViewElements().filter(el=\u0026gt;el.id === presentationPathLineEl.id)); const el = ea.getElement(presentationPathLineEl.id); el.strokeColor = \u0026#34;transparent\u0026#34;; el.backgroundColor = \u0026#34;transparent\u0026#34;; const customData = el.customData; if(setToHidden \u0026amp;\u0026amp; shouldHideArrowAfterPresentation) { el.locked = true; el.customData = { ...customData, slideshow: { originalProps, hidden: true } } isHidden = true; } else { if(customData) delete el.customData.slideshow; isHidden = false; } await ea.addElementsToView(); } if(presentationPathType===\u0026#34;line\u0026#34;) { originalProps = presentationPathLineEl.customData?.slideshow?.hidden ? presentationPathLineEl.customData.slideshow.originalProps : { strokeColor: presentationPathLineEl.strokeColor, backgroundColor: presentationPathLineEl.backgroundColor, locked: presentationPathLineEl.locked, }; isHidden = presentationPathLineEl.customData?.slideshow?.hidden ?? false; } //----------------------------- // scroll-to-location functions //----------------------------- const getNavigationRect = ({ x1, y1, x2, y2 }) =\u0026gt; { const { width, height } = excalidrawAPI.getAppState(); const ratioX = width / Math.abs(x1 - x2); const ratioY = height / Math.abs(y1 - y2); let ratio = Math.min(Math.max(ratioX, ratioY), 30); const scaledWidth = Math.abs(x1 - x2) * ratio; const scaledHeight = Math.abs(y1 - y2) * ratio; if (scaledWidth \u0026gt; width || scaledHeight \u0026gt; height) { ratio = Math.min(width / Math.abs(x1 - x2), height / Math.abs(y1 - y2)); } const deltaX = (width / ratio - Math.abs(x1 - x2)) / 2; const deltaY = (height / ratio - Math.abs(y1 - y2)) / 2; return { left: (x1 \u0026lt; x2 ? x1 : x2) - deltaX, top: (y1 \u0026lt; y2 ? y1 : y2) - deltaY, right: (x1 \u0026lt; x2 ? x2 : x1) + deltaX, bottom: (y1 \u0026lt; y2 ? y2 : y1) + deltaY, nextZoom: ratio, }; }; const getNextSlideRect = (forward) =\u0026gt; { slide = forward ? slide \u0026lt; slides.length-1 ? slide + 1 : 0 : slide \u0026lt;= 0 ? slides.length-1 : slide - 1; return getNavigationRect(slides[slide]); } let busy = false; const scrollToNextRect = async ({left,top,right,bottom,nextZoom},steps = TRANSITION_STEP_COUNT) =\u0026gt; { const startTimer = Date.now(); let watchdog = 0; while(busy \u0026amp;\u0026amp; watchdog++\u0026lt;15) await sleep(100); if(busy \u0026amp;\u0026amp; watchdog \u0026gt;= 15) return; busy = true; excalidrawAPI.updateScene({appState:{shouldCacheIgnoreZoom:true}}); const {scrollX, scrollY, zoom} = excalidrawAPI.getAppState(); const zoomStep = (zoom.value-nextZoom)/steps; const xStep = (left+scrollX)/steps; const yStep = (top+scrollY)/steps; let i=1; while(i\u0026lt;=steps) { excalidrawAPI.updateScene({ appState: { scrollX:scrollX-(xStep*i), scrollY:scrollY-(yStep*i), zoom:{value:zoom.value-zoomStep*i}, } }); const ellapsed = Date.now()-startTimer; if(ellapsed \u0026gt; TRANSITION_DELAY) { i = i\u0026lt;steps ? steps : steps+1; } else { const timeProgress = ellapsed / TRANSITION_DELAY; i=Math.min(Math.round(steps*timeProgress),steps) await sleep(FRAME_SLEEP); } } excalidrawAPI.updateScene({appState:{shouldCacheIgnoreZoom:false}}); if(isLaserOn) { excalidrawAPI.setActiveTool({type: \u0026#34;laser\u0026#34;}); } busy = false; } const navigate = async (dir) =\u0026gt; { const forward = dir === \u0026#34;fwd\u0026#34;; const prevSlide = slide; const nextRect = getNextSlideRect(forward); //exit if user navigates from last slide forward or first slide backward const shouldExit = forward ? slide\u0026lt;=prevSlide : slide\u0026gt;=prevSlide; if(shouldExit) { exitPresentation(); return; } if(selectSlideDropdown) selectSlideDropdown.value = slide+1; await scrollToNextRect(nextRect); if(window.ExcalidrawSlideshow \u0026amp;\u0026amp; (typeof window.ExcalidrawSlideshow.slide === \u0026#34;number\u0026#34;)) { window.ExcalidrawSlideshow.slide = slide; } } const navigateToSlide = (slideNumber) =\u0026gt; { if(slideNumber \u0026gt; slides.length) slideNumber = slides.length; if(slideNumber \u0026lt; 1) slideNumber = 1; slide = slideNumber - 2; navigate(\u0026#34;fwd\u0026#34;); } //-------------------------------------- // Slideshow control panel //-------------------------------------- let controlPanelFadeTimout = 0; const setFadeTimeout = (delay) =\u0026gt; { delay = delay ?? TRANSITION_DELAY; controlPanelFadeTimeout = ownerWindow.setTimeout(()=\u0026gt;{ controlPanelFadeTimout = 0; if(ownerDocument.activeElement === selectSlideDropdown) { setFadeTimeout(delay); return; } controlPanelEl.style.opacity = FADE_LEVEL; },delay); } const clearFadeTimeout = () =\u0026gt; { if(controlPanelFadeTimeout) { ownerWindow.clearTimeout(controlPanelFadeTimeout); controlPanelFadeTimeout = 0; } controlPanelEl.style.opacity = 1; } const createPresentationNavigationPanel = () =\u0026gt; { //create slideshow controlpanel container const top = contentEl.innerHeight; const left = contentEl.innerWidth/2; controlPanelEl = contentEl.querySelector(\u0026#34;.excalidraw\u0026#34;).createDiv({ cls: [\u0026#34;excalidraw-presentation-panel\u0026#34;], attr: { style: ` width: fit-content; z-index:5; position: absolute; top:calc(${top}px - var(--default-button-size)*2); left:calc(${left}px - var(--default-button-size)*5);` } }); setFadeTimeout(TRANSITION_DELAY*3); const panelColumn = controlPanelEl.createDiv({ cls: \u0026#34;panelColumn\u0026#34;, }); panelColumn.createDiv({ cls: [\u0026#34;Island\u0026#34;, \u0026#34;buttonList\u0026#34;], attr: { style: ` max-width: unset; justify-content: space-between; height: calc(var(--default-button-size)*1.5); width: 100%; background: var(--island-bg-color); display: flex; align-items: center;`, } }, el=\u0026gt;{ el.createEl(\u0026#34;style\u0026#34;, { text: ` select:focus { box-shadow: var(--input-shadow);} `}); el.createEl(\u0026#34;button\u0026#34;,{ attr: { style: ` margin-left: calc(var(--default-button-size)*0.25);`, \u0026#34;aria-label\u0026#34;: \u0026#34;Previous slide\u0026#34;, title: \u0026#34;Previous slide\u0026#34; } }, button =\u0026gt; { button.innerHTML = SVG_LEFT_ARROW; button.onclick = () =\u0026gt; navigate(\u0026#34;bkwd\u0026#34;) }); selectSlideDropdown = el.createEl(\u0026#34;select\u0026#34;, { attr: { style: ` font-size: inherit; background-color: var(--island-bg-color); border: none; color: var(--color-gray-100); cursor: pointer; }`, title: \u0026#34;Navigate to slide\u0026#34; } }, selectEl =\u0026gt; { for (let i = 0; i \u0026lt; slides.length; i++) { const option = document.createElement(\u0026#34;option\u0026#34;); option.text = (presentationPathType === \u0026#34;frame\u0026#34;) ? `${frames[i].name}/${slides.length}` : option.text = `Slide ${i + 1}/${slides.length}`; option.value = i + 1; selectEl.add(option); } selectEl.addEventListener(\u0026#34;change\u0026#34;, () =\u0026gt; { const selectedSlideNumber = parseInt(selectEl.value); selectEl.blur(); navigateToSlide(selectedSlideNumber); }); }); el.createEl(\u0026#34;button\u0026#34;,{ attr: { title: \u0026#34;Next slide\u0026#34; }, }, button =\u0026gt; { button.innerHTML = SVG_RIGHT_ARROW; button.onclick = () =\u0026gt; navigate(\u0026#34;fwd\u0026#34;); }); el.createDiv({ attr: { style: ` width: 1px; height: var(--default-button-size); background-color: var(--default-border-color); margin: 0px auto;` } }); el.createEl(\u0026#34;button\u0026#34;,{ attr: { title: \u0026#34;Toggle Laser Pointer and Panning Mode\u0026#34; } }, button =\u0026gt; { button.innerHTML = isLaserOn ? SVG_LASER_ON : SVG_LASER_OFF; button.onclick = () =\u0026gt; { isLaserOn = !isLaserOn; excalidrawAPI.setActiveTool({ type: isLaserOn ? \u0026#34;laser\u0026#34; : \u0026#34;selection\u0026#34; }) button.innerHTML = isLaserOn ? SVG_LASER_ON : SVG_LASER_OFF; } }); el.createEl(\u0026#34;button\u0026#34;,{ attr: { title: \u0026#34;Toggle fullscreen. If you hold ALT/OPT when starting the presentation it will not go fullscreen.\u0026#34; }, }, button =\u0026gt; { toggleFullscreenButton = button; button.innerHTML = isFullscreen ? SVG_MINIMIZE : SVG_MAXIMIZE; button.onclick = () =\u0026gt; toggleFullscreen(); }); if(presentationPathType === \u0026#34;line\u0026#34;) { if(shouldHideArrowAfterPresentation) { new ea.obsidian.ToggleComponent(el) .setValue(isHidden) .onChange(value =\u0026gt; { if(value) { excalidrawAPI.setToast({ message:\u0026#34;The presentation path remain hidden after the presentation. No need to select the line again. Just click the slideshow button to start the next presentation.\u0026#34;, duration: 5000, closable: true }) } toggleArrowVisibility(value); }) .toggleEl.setAttribute(\u0026#34;title\u0026#34;,\u0026#34;Arrow visibility. ON: hidden after presentation, OFF: visible after presentation\u0026#34;); } el.createEl(\u0026#34;button\u0026#34;,{ attr: { title: \u0026#34;Edit slide\u0026#34; }, }, button =\u0026gt; { button.innerHTML = SVG_EDIT; button.onclick = () =\u0026gt; { if(shouldHideArrowAfterPresentation) toggleArrowVisibility(false); exitPresentation(true); } }); } el.createEl(\u0026#34;button\u0026#34;,{ attr: { style: ` margin-right: calc(var(--default-button-size)*0.25);`, title: \u0026#34;End presentation\u0026#34; } }, button =\u0026gt; { button.innerHTML = SVG_FINISH; button.onclick = () =\u0026gt; exitPresentation() }); }); } //-------------------- // keyboard navigation //-------------------- const keydownListener = (e) =\u0026gt; { if(hostLeaf !== app.workspace.activeLeaf) return; if(hostLeaf.width === 0 \u0026amp;\u0026amp; hostLeaf.height === 0) return; e.preventDefault(); switch(e.key) { case \u0026#34;Backspace\u0026#34;: case \u0026#34;Escape\u0026#34;: exitPresentation(); break; case \u0026#34;Space\u0026#34;: case \u0026#34;ArrowRight\u0026#34;: case \u0026#34;ArrowDown\u0026#34;: navigate(\u0026#34;fwd\u0026#34;); break; case \u0026#34;ArrowLeft\u0026#34;: case \u0026#34;ArrowUp\u0026#34;: navigate(\u0026#34;bkwd\u0026#34;); break; case \u0026#34;End\u0026#34;: slide = slides.length - 2; navigate(\u0026#34;fwd\u0026#34;); break; case \u0026#34;Home\u0026#34;: slide = -1; navigate(\u0026#34;fwd\u0026#34;); break; case \u0026#34;e\u0026#34;: if(presentationPathType !== \u0026#34;line\u0026#34;) return; (async ()=\u0026gt;{ await toggleArrowVisibility(false); exitPresentation(true); })() break; } } //--------------------- // slideshow panel drag //--------------------- let posX1 = posY1 = posX2 = posY2 = 0; const updatePosition = (deltaY = 0, deltaX = 0) =\u0026gt; { const { offsetTop, offsetLeft, clientWidth: width, clientHeight: height, } = controlPanelEl; controlPanelEl.style.top = (offsetTop - deltaY) + \u0026#39;px\u0026#39;; controlPanelEl.style.left = (offsetLeft - deltaX) + \u0026#39;px\u0026#39;; } const onPointerUp = () =\u0026gt; { ownerWindow.removeEventListener(\u0026#39;pointermove\u0026#39;, onDrag, true); } const onPointerDown = (e) =\u0026gt; { clearFadeTimeout(); setFadeTimeout(); const now = Date.now(); posX2 = e.clientX; posY2 = e.clientY; ownerWindow.addEventListener(\u0026#39;pointermove\u0026#39;, onDrag, true); } const onDrag = (e) =\u0026gt; { e.preventDefault(); posX1 = posX2 - e.clientX; posY1 = posY2 - e.clientY; posX2 = e.clientX; posY2 = e.clientY; updatePosition(posY1, posX1); } const onMouseEnter = () =\u0026gt; { clearFadeTimeout(); } const onMouseLeave = () =\u0026gt; { setFadeTimeout(); } const fullscreenListener = (e) =\u0026gt; { if(preventFullscreenExit) { preventFullscreenExit = false; return; } e.preventDefault(); exitPresentation(); } const initializeEventListners = () =\u0026gt; { ownerWindow.addEventListener(\u0026#39;keydown\u0026#39;,keydownListener); controlPanelEl.addEventListener(\u0026#39;pointerdown\u0026#39;, onPointerDown, false); controlPanelEl.addEventListener(\u0026#39;mouseenter\u0026#39;, onMouseEnter, false); controlPanelEl.addEventListener(\u0026#39;mouseleave\u0026#39;, onMouseLeave, false); ownerWindow.addEventListener(\u0026#39;pointerup\u0026#39;, onPointerUp, false); //event listners for terminating the presentation window.removePresentationEventHandlers = () =\u0026gt; { ea.onLinkClickHook = null; controlPanelEl.removeEventListener(\u0026#39;pointerdown\u0026#39;, onPointerDown, false); controlPanelEl.removeEventListener(\u0026#39;mouseenter\u0026#39;, onMouseEnter, false); controlPanelEl.removeEventListener(\u0026#39;mouseleave\u0026#39;, onMouseLeave, false); controlPanelEl.parentElement?.removeChild(controlPanelEl); if(!ea.DEVICE.isMobile) { contentEl.removeEventListener(\u0026#39;webkitfullscreenchange\u0026#39;, fullscreenListener); contentEl.removeEventListener(\u0026#39;fullscreenchange\u0026#39;, fullscreenListener); } ownerWindow.removeEventListener(\u0026#39;keydown\u0026#39;,keydownListener); ownerWindow.removeEventListener(\u0026#39;pointerup\u0026#39;,onPointerUp); contentEl.querySelector(\u0026#34;.layer-ui__wrapper\u0026#34;)?.removeClass(\u0026#34;excalidraw-hidden\u0026#34;); delete window.removePresentationEventHandlers; } ea.onLinkClickHook = () =\u0026gt; { exitPresentation(); return true; }; if(!ea.DEVICE.isMobile) { contentEl.addEventListener(\u0026#39;webkitfullscreenchange\u0026#39;, fullscreenListener); contentEl.addEventListener(\u0026#39;fullscreenchange\u0026#39;, fullscreenListener); } } //---------------------------- // Exit presentation //---------------------------- const exitPresentation = async (openForEdit = false) =\u0026gt; { //this is a hack, not sure why ea loses target view when other scripts are executed while the presentation is running ea.targetView = hostView; isLaserOn = false; statusBarElement.style.display = \u0026#34;inherit\u0026#34;; if(openForEdit) ea.targetView.preventAutozoom(); await exitFullscreen(); await waitForExcalidrawResize(); ea.setViewModeEnabled(false); if(presentationPathType === \u0026#34;line\u0026#34;) { ea.clear(); ea.copyViewElementsToEAforEditing(ea.getViewElements().filter(el=\u0026gt;el.id === presentationPathLineEl.id)); const el = ea.getElement(presentationPathLineEl.id); if(!isHidden) { el.strokeColor = originalProps.strokeColor; el.backgroundProps = originalProps.backgroundColor; el.locked = openForEdit ? false : originalProps.locked; } await ea.addElementsToView(); if(!isHidden) ea.selectElementsInView([el]); if(openForEdit) { let nextRect = getNextSlideRect(--slide); const offsetW = (nextRect.right-nextRect.left)*(1-EDIT_ZOOMOUT)/2; const offsetH = (nextRect.bottom-nextRect.top)*(1-EDIT_ZOOMOUT)/2 nextRect = { left: nextRect.left-offsetW, right: nextRect.right+offsetW, top: nextRect.top-offsetH, bottom: nextRect.bottom+offsetH, nextZoom: nextRect.nextZoom*EDIT_ZOOMOUT \u0026gt; 0.1 ? nextRect.nextZoom*EDIT_ZOOMOUT : 0.1 //0.1 is the minimu zoom value }; await scrollToNextRect(nextRect,1); excalidrawAPI.startLineEditor( ea.getViewSelectedElement(), [slide*2,slide*2+1] ); } } else { if(frameRenderingOriginalState.enabled) { excalidrawAPI.updateScene({ appState: { frameRendering: { ...frameRenderingOriginalState, enabled: true } } }); } } window.removePresentationEventHandlers?.(); ownerWindow.setTimeout(()=\u0026gt;{ //Resets pointer offsets. Ugly solution. //During testing offsets were wrong after presentation, but don\u0026#39;t know why. //This should solve it even if they are wrong. hostView.refreshCanvasOffset(); excalidrawAPI.setActiveTool({type: \u0026#34;selection\u0026#34;}); }) } //-------------------------- // Start presentation or open presentation settings on double click //-------------------------- const start = async () =\u0026gt; { statusBarElement.style.display = \u0026#34;none\u0026#34;; ea.setViewModeEnabled(true); const helpButton = ea.targetView.excalidrawContainer?.querySelector(\u0026#34;.ToolIcon__icon.help-icon\u0026#34;); if(helpButton) { helpButton.style.display = \u0026#34;none\u0026#34;; } const zoomButton = ea.targetView.excalidrawContainer?.querySelector(\u0026#34;.Stack.Stack_vertical.zoom-actions\u0026#34;); if(zoomButton) { zoomButton.style.display = \u0026#34;none\u0026#34;; } createPresentationNavigationPanel(); initializeEventListners(); if(startFullscreen) { await gotoFullscreen(); } else { resetControlPanelElPosition(); } if(presentationPathType === \u0026#34;line\u0026#34;) await toggleArrowVisibility(isHidden); } const timestamp = Date.now(); if(window.ExcalidrawSlideshow \u0026amp;\u0026amp; (window.ExcalidrawSlideshow.script === utils.scriptFile.path) \u0026amp;\u0026amp; (timestamp - window.ExcalidrawSlideshow.timestamp \u0026lt;400) ) { if(window.ExcalidrawSlideshowStartTimer) { window.clearTimeout(window.ExcalidrawSlideshowStartTimer); delete window.ExcalidrawSlideshowStartTimer; } await start(); } else { if(window.ExcalidrawSlideshowStartTimer) { window.clearTimeout(window.ExcalidrawSlideshowStartTimer); delete window.ExcalidrawSlideshowStartTimer; } window.ExcalidrawSlideshow = { script: utils.scriptFile.path, timestamp, slide: 0 }; window.ExcalidrawSlideshowStartTimer = window.setTimeout(start,500); } ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/excalidraw/scripts/downloaded/slideshow/","title":"Downloaded Slideshow"},{"content":"/*\nThis script splits an ellipse at any point where a line intersects it. If no lines are selected, it will use every line that intersects the ellipse. Otherwise, it will only use the selected lines. If there is no intersecting line, the ellipse will be converted into a line object. There is also the option to close the object along the cut, which will close the cut in the shape of the line. Tip: To use an ellipse as the cutting object, you first have to use this script on it, since it will convert the ellipse into a line.\nSee documentation for more details: https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/ const elements = ea.getViewSelectedElements(); const ellipse = elements.filter(el =\u0026gt; el.type == \u0026#34;ellipse\u0026#34;)[0]; if (!ellipse) return; let lines = elements.filter(el =\u0026gt; el.type == \u0026#34;line\u0026#34; || el.type == \u0026#34;arrow\u0026#34;); if (lines.length == 0) lines = ea.getViewElements().filter(el =\u0026gt; el.type == \u0026#34;line\u0026#34; || el.type == \u0026#34;arrow\u0026#34;); const subLines = getSubLines(lines); const angles = subLines.flatMap(line =\u0026gt; { return intersectionAngleOfEllipseAndLine(ellipse, line.a, line.b).map(result =\u0026gt; ({ angle: result, cuttingLine: line })); }); if (angles.length === 0) angles.push({ angle: 0, cuttingLine: null }); angles.sort((a, b) =\u0026gt; a.angle - b.angle); const closeObject = await utils.suggester([\u0026#34;Yes\u0026#34;, \u0026#34;No\u0026#34;], [true, false], \u0026#34;Close object along cutedge?\u0026#34;) ea.style.strokeSharpness = closeObject ? \u0026#34;sharp\u0026#34; : \u0026#34;round\u0026#34;; ea.style.strokeColor = ellipse.strokeColor; ea.style.strokeWidth = ellipse.strokeWidth; ea.style.backgroundColor = ellipse.backgroundColor; ea.style.fillStyle = ellipse.fillStyle; ea.style.roughness = ellipse.roughness; angles.forEach((angle, key) =\u0026gt; { const cuttingLine = angle.cuttingLine; angle = angle.angle; const nextAngleKey = (key + 1) \u0026lt; angles.length ? key + 1 : 0; const nextAngle = angles[nextAngleKey].angle; const AngleDelta = nextAngle - angle ? nextAngle - angle : Math.PI*2; const pointAmount = Math.ceil((AngleDelta*64)/(Math.PI*2)); const stepSize = AngleDelta/pointAmount; let points = drawEllipse(ellipse.x, ellipse.y, ellipse.width, ellipse.height, ellipse.angle, angle, nextAngle, stepSize); if (closeObject \u0026amp;\u0026amp; cuttingLine) points = points.concat(getCutLine(points[0], angles[key], angles[nextAngleKey], ellipse)); const lineId = ea.addLine(points); const line = ea.getElement(lineId); line.frameId = ellipse.frameId; line.groupIds = ellipse.groupIds; }); ea.deleteViewElements([ellipse]); ea.addElementsToView(false,false,true); return; function getSubLines(lines) { return lines.flatMap((line, key) =\u0026gt; { return line.points.slice(1).map((pointB, i) =\u0026gt; ({ a: addVectors([line.points[i], [line.x, line.y]]), b: addVectors([pointB, [line.x, line.y]]), originLineIndex: key, indexPointA: i, })); }); } function intersectionAngleOfEllipseAndLine(ellipse, pointA, pointB) { /* To understand the code in this function and subfunctions it might help to take a look at this geogebra file https://www.geogebra.org/m/apbm3hs6 */ const c = multiplyVectorByScalar([ellipse.width, ellipse.height], (1/2)); const a = rotateVector( addVectors([ pointA, invVec([ellipse.x, ellipse.y]), invVec(multiplyVectorByScalar([ellipse.width, ellipse.height], (1/2))) ]), -ellipse.angle ) const l_b = rotateVector( addVectors([ pointB, invVec([ellipse.x, ellipse.y]), invVec(multiplyVectorByScalar([ellipse.width, ellipse.height], (1/2))) ]), -ellipse.angle ); const b = addVectors([ l_b, invVec(a) ]); const solutions = calculateLineSegment(a[0], a[1], b[0], b[1], c[0], c[1]); return solutions .filter(num =\u0026gt; isBetween(num, 0, 1)) .map(num =\u0026gt; { const point = [ (a[0] + b[0] * num) / ellipse.width, (a[1] + b[1] * num) / ellipse.height ]; return angleBetweenVectors([1, 0], point); }); } function drawEllipse(x, y, width, height, angle = 0, start = 0, end = Math.PI*2, step = Math.PI/32) { const ellipse = (t) =\u0026gt; { const spanningVector = rotateVector([width/2*Math.cos(t), height/2*Math.sin(t)], angle); const baseVector = [x+width/2, y+height/2]; return addVectors([baseVector, spanningVector]); } if(end \u0026lt;= start) end = end + Math.PI*2; let points = []; const almostEnd = end - step/2; for (let t = start; t \u0026lt; almostEnd; t = t + step) { points.push(ellipse(t)); } points.push(ellipse(end)) return points; } function getCutLine(startpoint, currentAngle, nextAngle, ellipse) { if (currentAngle.cuttingLine.originLineIndex != nextAngle.cuttingLine.originLineIndex) return []; const originLineIndex = currentAngle.cuttingLine.originLineIndex; if (lines[originLineIndex] == 2) return startpoint; const originLine = []; lines[originLineIndex].points.forEach(p =\u0026gt; originLine.push(addVectors([ p, [lines[originLineIndex].x, lines[originLineIndex].y] ]))); const edgepoints = []; const direction = isInEllipse(originLine[clamp(nextAngle.cuttingLine.indexPointA - 1, 0, originLine.length - 1)], ellipse) ? -1 : 1 let i = isInEllipse(originLine[nextAngle.cuttingLine.indexPointA], ellipse) ? nextAngle.cuttingLine.indexPointA : nextAngle.cuttingLine.indexPointA + direction; while (isInEllipse(originLine[i], ellipse)) { edgepoints.push(originLine[i]); i = (i + direction) % originLine.length; } edgepoints.push(startpoint); return edgepoints; } function calculateLineSegment(ax, ay, bx, by, cx, cy) { const sqrt = Math.sqrt((cx ** 2) * (cy ** 2) * (-(ay ** 2) * (bx ** 2) + 2 * ax * ay * bx * by - (ax ** 2) * (by ** 2) + (bx ** 2) * (cy ** 2) + (by ** 2) * (cx ** 2))); const numerator = -(ay * by * (cx ** 2) + ax * bx * (cy ** 2)); const denominator = ((by ** 2) * (cx ** 2) + (bx ** 2) * (cy ** 2)); const t1 = (numerator + sqrt) / denominator; const t2 = (numerator - sqrt) / denominator; return [t1, t2]; } function isInEllipse(point, ellipse) { point = addVectors([point, invVec([ellipse.x, ellipse.y]), invVec(multiplyVectorByScalar([ellipse.width, ellipse.height], 1/2))]); point = [point[0]*2/ellipse.width, point[1]*2/ellipse.height]; const distance = Math.sqrt(point[0]**2 + point[1]**2); return distance \u0026lt; 1; } function angleBetweenVectors(v1, v2) { let dotProduct = v1[0] * v2[0] + v1[1] * v2[1]; let determinant = v1[0] * v2[1] - v1[1] * v2[0]; let angle = Math.atan2(determinant, dotProduct); return angle \u0026lt; 0 ? angle + 2 * Math.PI : angle; } function rotateVector (vec, ang) { var cos = Math.cos(ang); var sin = Math.sin(ang); return [vec[0] * cos - vec[1] * sin, vec[0] * sin + vec[1] * cos]; } function addVectors(vectors) { return vectors.reduce((acc, vec) =\u0026gt; [acc[0] + vec[0], acc[1] + vec[1]], [0, 0]); } function invVec(vector) { return [-vector[0], -vector[1]]; } function multiplyVectorByScalar(vector, scalar) { return [vector[0] * scalar, vector[1] * scalar]; } function round(number, precision) { var factor = Math.pow(10, precision); return Math.round(number * factor) / factor; } function isBetween(num, min, max) { return (num \u0026gt;= min \u0026amp;\u0026amp; num \u0026lt;= max); } function clamp(number, min, max) { return Math.max(min, Math.min(number, max)); } ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/excalidraw/scripts/downloaded/split-ellipse/","title":"Downloaded Split Ellipse"},{"content":"Samajh bhai, ye code ekdum simple aur clean hai. Main step by step toda toda samjhata hoon:\nBinary Search Concept Binary search ek search algorithm hai jo sorted array pe kaam karta hai. Iska funda simple hai: divide and conquer. Har step pe array ko half karte jaate hain jab tak ya toh target mil jaaye ya array empty ho jaaye.\nCode Breakdown 1. Input Array aur Target: int[] arr = {1,2,3,4,5,6,7,8}; int target = 7; arr ek sorted array hai. target wo number hai jo hume dhoondhna hai. Yahan 7. 2. Binary Search Function: static int binarySearch(int[] arr, int target) { int start = 0; int end = arr.length - 1; start aur end pointers define karte hain array ka range. Pehle start hai 0 (array ka pehla index). end hai arr.length - 1 (last index). 3. Loop ke andar Logic: while (start \u0026lt;= end) { int mid = start + (end - start) / 2; Jab tak start \u0026lt;= end hai, tab tak search karte rahenge. mid calculate karte hain: (start + end) / 2 se mid nikalta, but agar numbers bohot bade ho toh overflow ho sakta hai. Isliye formula hai: start + (end - start) / 2. 4. Conditions: if (target \u0026lt; arr[mid]) { end = mid - 1; } else if (target \u0026gt; arr[mid]) { start = mid + 1; } else { return mid; } target \u0026lt; arr[mid]: Agar target mid se chhota hai, toh array ka right half ignore karo. end = mid - 1 set kar do. target \u0026gt; arr[mid]: Agar target mid se bada hai, toh left half ignore karo. start = mid + 1 set kar do. target == arr[mid]: Badhai ho bhai! Target mil gaya. mid index return karo. 5. Target Not Found: return -1; Agar loop khatam ho gaya aur target nahi mila, toh -1 return karte hain (iska matlab \u0026ldquo;not found\u0026rdquo;). Example Dry Run: Input: arr = {1,2,3,4,5,6,7,8}, target = 7\nFirst Iteration:\nstart = 0, end = 7 mid = 0 + (7 - 0) / 2 = 3 arr[mid] = 4 target \u0026gt; arr[mid] → start = mid + 1 = 4 Second Iteration:\nstart = 4, end = 7 mid = 4 + (7 - 4) / 2 = 5 arr[mid] = 6 target \u0026gt; arr[mid] → start = mid + 1 = 6 Third Iteration:\nstart = 6, end = 7 mid = 6 + (7 - 6) / 2 = 6 arr[mid] = 7 target == arr[mid] → Return 6 Output: 6 Target 7 ka index 6 hai.\nConclusion: Bhai, binary search sorted arrays ke liye ekdum fast hai. O(log N) time complexity ke saath bada efficient hai. Agar array sorted nahi hai toh pehle sort karna zaroori hoga. Any confusion? 😊\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/dsa/hinglish-explaination-of-code/","title":"DSA hinglish explaination of code"},{"content":" Definition/Introduction\nImportance/Significance\nAim/Goal/Purpose\nFeatures/Characteristics\nWorking/Process\nTypes/Classification\nExamples\nUsage/Applications\nAdvantages/Benefits\nDisadvantages/Limitations\nComparison with Similar Concepts\nConclusion\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/exam/important-parameters-to-write-in-exam/","title":"exam Important parameters to write in exam"},{"content":"add remote url commad\ngit remote add origin https://github.com/yashbhangale/Oopsidian.git git config\ngit config --global user.name \u0026#34;yashbhangale\u0026#34; git config --global user.email \u0026#34;yashbhangale9@gmail.com\u0026#34; ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/devops---cloud/git/git/","title":"git git"},{"content":"Here are some common git branch commands, along with explanations of how to use them:\nBasic Git Branch Commands List Branches\nTo list all branches (both local and remote):\ngit branch To list all branches, including remote ones:\ngit branch -a Create a New Branch\nTo create a new branch:\ngit branch \u0026lt;branch-name\u0026gt; Example:\ngit branch feature/login Switch to a Different Branch\nTo switch to an existing branch:\ngit checkout \u0026lt;branch-name\u0026gt; Example:\ngit checkout feature/login Note: In newer versions of Git, you can use the git switch command:\ngit switch \u0026lt;branch-name\u0026gt; Create and Switch to a New Branch\nTo create a new branch and immediately switch to it:\ngit checkout -b \u0026lt;branch-name\u0026gt; Or, using the newer command:\ngit switch -c \u0026lt;branch-name\u0026gt; Rename a Branch\nTo rename the current branch:\ngit branch -m \u0026lt;new-branch-name\u0026gt; To rename a branch that you\u0026rsquo;re not currently on:\ngit branch -m \u0026lt;old-branch-name\u0026gt; \u0026lt;new-branch-name\u0026gt; Delete a Branch\nTo delete a local branch:\ngit branch -d \u0026lt;branch-name\u0026gt; If the branch hasn\u0026rsquo;t been merged, you may need to use -D (force delete):\ngit branch -D \u0026lt;branch-name\u0026gt; Show Branch Details\nTo show details of the current branch:\ngit status Merge a Branch into the Current Branch\nTo merge another branch into your current branch:\ngit merge \u0026lt;branch-name\u0026gt; Example:\ngit merge feature/login List Remote Branches\nTo list all remote branches:\ngit branch -r Delete a Remote Branch\nTo delete a remote branch:\ngit push origin --delete \u0026lt;branch-name\u0026gt; Push a Branch to Remote\nTo push a local branch to a remote repository:\ngit push origin \u0026lt;branch-name\u0026gt; Fetch and Update Remote Branches\nTo fetch all remote branches:\ngit fetch --all Track a Remote Branch\nTo track a remote branch when you check out a new branch:\ngit checkout --track origin/\u0026lt;branch-name\u0026gt; Or using the newer switch:\ngit switch --track origin/\u0026lt;branch-name\u0026gt; Useful Tips Check Which Branch You Are On: To check the current branch you\u0026rsquo;re on:\ngit branch The current branch will have an asterisk (*) next to its name.\nCreate a Branch from Another Branch\nTo create a new branch from a specific branch:\ngit checkout -b \u0026lt;new-branch-name\u0026gt; \u0026lt;existing-branch-name\u0026gt; Switch Back to Previous Branch\nTo switch back to the branch you were on previously:\ngit checkout - These commands will help you navigate, manage, and organize your branches within Git.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/devops---cloud/git/git-branch-commands/","title":"git git branch commands"},{"content":"add remote url commad\ngit remote add origin https://github.com/yashbhangale/Oopsidian.git git config\ngit config --global user.name \u0026#34;yashbhangale\u0026#34; git config --global user.email \u0026#34;yashbhangale9@gmail.com\u0026#34; ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/devops---cloud/git/git-index/","title":"git Git Index"},{"content":"NLP 4,5,6 dl 3,,5,6 bda, 456 bt 456\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/ia-2-exam/syllabus/","title":"IA 2 Exam Syllabus"},{"content":"turn on your camera\npresent using star method\nSituation: Explain situation Task: Kya task tha because of that situation Action: actions that we took , process do we follow and how we make sure the task at hand were completed result: Explain about everything that came out and response that we got from client Accept your mistake\nwhile solving DSA question try to solve using brute-force approach First here brute-force means worst possible solution\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/interview/interview-tips/","title":"interview Interview tips"},{"content":"Zoho Corporation is a multinational technology company that ==creates computer software and web-based business tools==. Zoho\u0026rsquo;s products include: ' '\nZoho Office Suite: An online office suite CRM: A customer-facing platform Mail: A secure email service Desk: Helpdesk software for customer support Books: An accounting platform Projects: A tool to manage, track, and collaborate on projects Zoho One: A unified cloud software to increase organizational efficiency Commerce: An eCommerce platform for managing and marketing an online store Finance: Tools for keeping track of expenses and managing back office operations Survey: A tool to create and send surveys to collect and analyze feedback Sites: A website builder with integration features for Google Analytics, social media platforms, and other Zoho apps PageSense: An optimization platform to track user behavior on websites, conduct A/B testing, and optimize websites Backstage: An event management app to plan, run, and analyze in-person, virtual, and hybrid events Zoho Cliq: A business and team chat app Zoho is a privately-held company with headquarters in Chennai, India and Del Valle, Texas. Zoho does not have an ad-revenue model in any part of its business, including its free products.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/interview/zoho/","title":"interview zoho"},{"content":"","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/4.-merge-sort/","title":"Java Learning 4  Merge sort"},{"content":"In Java, primitive types are the basic data types that store simple values. They are not objects and are predefined in Java.\nPrimitive Data Types: byte: 1 byte, range: -128 to 127 short: 2 bytes, range: -32,768 to 32,767 int: 4 bytes, range: -2^31 to 2^31-1 long: 8 bytes, range: -2^63 to 2^63-1 float: 4 bytes, single-precision floating-point double: 8 bytes, double-precision floating-point char: 2 bytes, represents a single Unicode character boolean: 1 byte, represents true or false Example: int num = 10; double price = 99.99; char grade = \u0026#39;A\u0026#39;; boolean isValid = true; ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/primitive/","title":"Java Learning primitive"},{"content":"[[vocabulary]] ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/learn-english/1.-main/","title":"Learn English 1  Main"},{"content":" foster : encourage the development of (something, especially something desirable). \u0026ldquo;the teacher\u0026rsquo;s task is to foster learning\u0026rdquo; consensus: general agreement ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/learn-english/vocabulary/","title":"Learn English vocabulary"},{"content":"Information systems have profoundly transformed both organizations and society by improving efficiency, communication, and decision-making while introducing new challenges and ethical considerations. Below is a structured analysis of their impact:\nImpact on Organizations 1. Enhanced Decision-Making Information systems provide accurate, real-time data and analytical tools for better decision-making. Examples: Dashboards and business intelligence tools help managers analyze trends and predict outcomes. 2. Improved Efficiency and Productivity Automation of routine tasks reduces errors and speeds up operations. Examples: ERP systems streamline workflows across departments like finance, HR, and supply chain. 3. Cost Reduction Automation and optimization of processes reduce operational costs. Examples: Cloud computing reduces the need for expensive on-premise hardware. 4. Better Communication and Collaboration Facilitates seamless communication among employees, departments, and global teams. Examples: Email, video conferencing, and collaboration tools like Slack or Microsoft Teams. 5. Innovation and Competitive Advantage Enables new business models, products, and services. Examples: E-commerce platforms allow businesses to sell globally, 24/7. 6. Enhanced Customer Relationships Customer Relationship Management (CRM) systems improve customer service by tracking interactions and preferences. Examples: Personalized marketing based on customer purchase history. 7. Job Transformation Creates new roles (e.g., data analysts, cybersecurity experts) but also automates some traditional jobs. 8. Increased Dependence on Technology Organizations become highly dependent on information systems, leading to vulnerability during system failures or cyberattacks. Impact on Society 1. Increased Access to Information Democratization of information enables individuals to access education, news, and services online. Examples: Online learning platforms and digital libraries. 2. Improved Quality of Life Health information systems improve medical care and public health outcomes. Examples: Telemedicine and electronic health records. 3. Economic Transformation Creates new industries (e.g., digital marketing, app development) and transforms existing ones. Examples: Gig economy platforms like Uber and Fiverr. 4. Social Connectivity Social media and messaging apps connect people globally. Examples: Platforms like Facebook, Instagram, and WhatsApp. 5. Ethical and Privacy Concerns Misuse of personal data and surveillance erodes privacy. Examples: Data breaches and unauthorized use of personal information by companies. 6. Employment Shifts Automation leads to job displacement in traditional sectors while creating opportunities in technology-driven fields. Examples: AI replacing repetitive tasks while creating demand for AI developers. 7. Bridging or Widening the Digital Divide Positive: Provides opportunities for underprivileged communities through online access. Negative: Limited access in some regions creates a gap between the digitally empowered and disadvantaged. 8. Environmental Impact Positive: Reduces paper usage and supports remote work, cutting travel emissions. Negative: E-waste and high energy consumption from data centers. Summary of Impacts Aspect Impact on Organizations Impact on Society Efficiency Automation and optimized workflows. Easier access to services and resources. Decision-Making Real-time insights and predictive analytics. Informed public through widespread information. Employment Job creation in tech; automation of tasks. Shifts in job types; gig economy growth. Social Improved communication and collaboration. Increased global connectivity. Ethics Data security and privacy concerns. Privacy issues and ethical dilemmas. Environment Streamlined operations reduce waste. E-waste and resource consumption challenges. Conclusion Information systems have become integral to the functioning of modern organizations and the daily lives of people. While they offer significant benefits, managing their challenges—such as ethical concerns, security, and the digital divide—is critical for maximizing their positive impact.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/mis/impact-of-information-system-in-organisation-and-society/","title":"MIS Impact of Information system in organisation and society"},{"content":"What is IS and its types ? An Information System (IS) is a structured framework that involves the ==collection, storage, management, and dissemination of data and information.== It co==mbines technology, people, and processes to support decision-making, coordination, control, analysis, and visualization in an organization or setting==.\nInformation technology (IT) and Information systems (IS) are ==used by organizations to enhance their performance.==\nFrom the point of view of Information Systems it is necessary to understand the difference between data, information and knowledge although they sound quiet similar.\n1. Data Definition: Data is ==raw, unprocessed facts and figures without context or meaning.== Characteristics: May include numbers, symbols, text, or observations. Has no inherent structure or interpretation. Serves as the foundation for information and knowledge. Example: \u0026ldquo;123\u0026rdquo;, \u0026ldquo;John\u0026rdquo;, \u0026ldquo;50°F\u0026rdquo;. 2. Information Definition: Information is ==processed, organized, or structured data that has context and meaning.== Characteristics: Answers questions like \u0026ldquo;who,\u0026rdquo; \u0026ldquo;what,\u0026rdquo; \u0026ldquo;where,\u0026rdquo; and \u0026ldquo;when.\u0026rdquo; Is meaningful and ==useful== for ==decision-making==. ==Created== by ==analyzing, sorting, or organizing data==. Example: \u0026ldquo;John scored 123 runs in the cricket match\u0026rdquo; or \u0026ldquo;The temperature in New York is 50°F.\u0026rdquo; 3. Knowledge Definition: Knowledge is the ==application of information combined with experience, insights, and judgment to make decisions or solve problems==. Characteristics: Answers the \u0026ldquo;how\u0026rdquo; and \u0026ldquo;why\u0026rdquo; questions. Is contextual and actionable. Involves understanding relationships, patterns, and implications. Example: \u0026ldquo;If the temperature drops below 50°F in New York, people should wear warm clothing.\u0026rdquo; Data is raw and unprocessed. Information adds structure and context to data. Knowledge adds experience and insight to information. An information system is a set of organized and interrelated components that ==work collectively to collect, store, process and disseminate information for a specific purpose==, like to ==support decision making, coordination, control, analysis, and visualization in an organization==.\nRole of Information Systems in Organizations Information Storage and Analysis ==Store large volumes of data securely and efficiently==. Enable ==quick retrieval== of data for analysis and reporting. Provide ==tools for analyzing trends, patterns, and performance metrics (e.g., dashboards, data visualization).== Ensure ==data integrity and consistency== across departments through centralized databases. Assist in Decision Making Provide accurate and timely information for ==strategic, tactical, and operational decisions.== Support decision-making with ==predictive analytics, simulations, and scenario modeling.== Facilitate real-time monitoring and adjustments using up-to-date data (e.g., ==inventory levels, market trends).== Enable ==collaboration among stakeholders with shared access to information. == Assist with Business Processes ==Automate repetitive and time-consuming== ==tasks== (e.g., payroll processing, customer invoicing). ==Streamline workflows by integrating systems across departments== (e.g., ERP systems). Enhance communication and coordination among teams using collaboration tools. Improve customer service through CRM systems that track interactions and preferences. ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/mis/information-system/","title":"MIS Information system"},{"content":"Organizational Strategy refers to the long-term goals and plans that guide how an organization achieves its objectives. Information Systems (IS) play a critical role in shaping and supporting these strategies by enabling competitive advantages.\n1. Organizational Strategy Definition: A plan of action designed to achieve a specific organizational goal, focusing on areas like growth, cost-efficiency, innovation, and market dominance. Key Components: Vision and Mission: The overarching purpose and direction. Goals and Objectives: Specific, measurable targets. Strategies and Tactics: How resources and activities are allocated to achieve goals. Example: An e-commerce company focusing on fast delivery as a core strategy might invest heavily in logistics and distribution systems.\n2. Competitive Advantage Definition: A condition that allows a company to outperform its competitors by offering superior value (e.g., lower costs, better quality, or unique products). Types of Competitive Advantages: Cost Leadership: Providing goods or services at a lower cost than competitors. Differentiation: Offering unique products or services that justify a premium price. Focus/Niche Strategy: Targeting a specific market segment with tailored offerings. Example: Amazon uses cost leadership by leveraging efficient supply chains and differentiation with personalized recommendations.\n3. Role of Information Systems in Achieving Competitive Advantages Information Systems (IS) are essential for gaining and sustaining competitive advantages by aligning technology with organizational strategy. Here\u0026rsquo;s how IS supports organizational strategies:\nA. Cost Leadership through IS Automating processes to reduce labor and operational costs. Optimizing supply chains using ERP (Enterprise Resource Planning) systems. Using data analytics to minimize waste and enhance efficiency. Example: Walmart uses IS to track inventory in real time, ensuring cost-effective stock management.\nB. Differentiation through IS Enhancing product quality and innovation using advanced technologies like AI and IoT. Personalizing customer experiences using CRM (Customer Relationship Management) systems. Providing superior customer service through chatbots and 24/7 online support. Example: Netflix uses recommendation algorithms to differentiate its platform by tailoring content to users.\nC. Focus/Niche Strategy through IS Analyzing market data to identify underserved segments. Customizing products or services to meet specific customer needs. Leveraging e-commerce platforms to target niche markets globally. Example: Etsy uses IS to connect niche creators with buyers worldwide.\nD. Enhancing Decision-Making Real-time data and predictive analytics support strategic decision-making. Tools like Decision Support Systems (DSS) help analyze market trends and opportunities. Example: Starbucks uses IS to analyze customer preferences and select optimal store locations.\nE. Building Barriers to Entry Patented IS technologies or proprietary systems can deter competitors. Integration of IS into operations creates efficiencies that are difficult for new entrants to replicate. Example: Amazon\u0026rsquo;s fulfillment network and advanced logistics systems are hard for competitors to replicate.\nStrategic Frameworks Connecting IS and Competitive Advantage Several frameworks demonstrate the relationship between IS, organizational strategy, and competitive advantage:\nPorter’s Five Forces\nIS reduces supplier power (e.g., online marketplaces), creates new entrants\u0026rsquo; barriers (e.g., high tech adoption), and increases customer loyalty (e.g., personalization). Value Chain Analysis\nIS enhances primary activities (e.g., production, marketing) and support activities (e.g., HR, procurement). The Resource-Based View (RBV)\nIS provides unique resources like proprietary software, data analytics capabilities, and intellectual property, contributing to sustained competitive advantage. 4. Challenges in Using IS for Competitive Advantage Cost of Implementation: High investment in technology and maintenance. Rapid Technological Changes: Innovations can render existing IS obsolete. Cybersecurity Risks: Dependence on IS makes organizations vulnerable to breaches. Alignment Issues: Misalignment between IS and organizational goals can lead to inefficiencies. Summary Table Aspect Role of IS Cost Leadership Process automation, supply chain optimization, cost tracking. Differentiation Personalization, product innovation, superior service delivery. Focus Strategy Niche market targeting, customer insights, customized solutions. Decision-Making Real-time data analysis, predictive modeling, and reporting. Barriers to Entry Proprietary systems, advanced logistics, and patented technologies. Conclusion Information Systems are integral to modern organizational strategies. They provide tools and capabilities that enable cost efficiency, differentiation, and niche targeting, all of which contribute to competitive advantages. However, to maximize their potential, organizations must align IS with strategic goals and continuously adapt to technological advancements.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/mis/organizational-strategy-competitive-advantages-and-is/","title":"MIS ORGANIZATIONAL STRATEGY, COMPETITIVE ADVANTAGES AND IS"},{"content":"Eventual consistency can lead to temporary data inconsistencies, which may be unsuitable for some applications.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/big-data-analysis/module-3/consistency-trade-offs/","title":"Module 3 Consistency trade-offs"},{"content":"Offers more flexibility in design and coding, as developers don’t need to structure data around a strict schema.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/big-data-analysis/module-3/developer-agencet/","title":"Module 3 developer agencet"},{"content":"Each NoSQL database has unique features and APIs, requiring developers to adapt their code to each database type.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/big-data-analysis/module-3/standardization-challenges/","title":"Module 3 Standardization Challenges"},{"content":"https://www.tutorialspoint.com/all-types-of-ambiguities-in-nlp\nNatural language is inherently ambiguous, which makes it challenging for both humans and machines to interpret precisely without additional context. Ambiguities arise due to the flexibility, richness, and context-dependence of language. Below are the main types of ambiguities encountered in Natural Language Processing (NLP):\n1. Lexical Ambiguity Definition: When a single word has multiple meanings.\nExample: Bank can mean: A financial institution. The side of a river. An action (e.g., \u0026ldquo;to bank on someone\u0026rdquo;). Challenges:\nWord Sense Disambiguation (WSD) is needed to determine the correct meaning based on context. Applications to Address:\nSearch engines, machine translation, and chatbots often use WSD techniques to resolve lexical ambiguity. 2. Syntactic Ambiguity (Structural Ambiguity) Definition: When a sentence can be parsed in multiple ways due to its grammatical structure.\nExample: \u0026ldquo;I saw the man with the telescope.\u0026rdquo; Did I use the telescope to see the man? Or was the man holding the telescope? Challenges:\nParsing tools must construct syntax trees and choose the most plausible interpretation. Applications to Address:\nGrammar checkers, automatic summarizers, and question-answering systems require syntax resolution. 3. Semantic Ambiguity Definition: When the meaning of a sentence or phrase is unclear due to the interpretation of words or phrases.\nExample: \u0026ldquo;He looked at the bat.\u0026rdquo; Is it a flying mammal or a baseball bat? Challenges:\nRequires context or additional world knowledge to determine the intended meaning. Applications to Address:\nSentiment analysis and context-based systems use embeddings and transformers to resolve semantic ambiguity. 4. Pragmatic Ambiguity Definition: When the meaning of a statement depends on context or intended use rather than the words themselves.\nExample: \u0026ldquo;Can you pass the salt?\u0026rdquo; Literal question about ability. Or a polite request for the salt shaker. Challenges:\nPragmatic ambiguity often involves understanding social cues, idioms, or implied meanings. Applications to Address:\nChatbots, virtual assistants, and conversational AI systems need pragmatic understanding to offer appropriate responses. 5. Anaphoric Ambiguity Definition: When pronouns or referring expressions (like he, she, it, this) have multiple possible antecedents.\nExample: \u0026ldquo;John told Tom that he was late.\u0026rdquo; Who was late, John or Tom? Challenges:\nResolving anaphoric ambiguity requires discourse analysis to identify the antecedent. Applications to Address:\nCoreference resolution systems, document summarization, and machine translation often need anaphoric disambiguation. 6. Elliptical Ambiguity Definition: When parts of a sentence are omitted but implied, leading to multiple interpretations.\nExample: \u0026ldquo;She will go to Paris, and he to London.\u0026rdquo; The verb go is omitted for the second clause, but this could confuse simpler parsers. Challenges:\nRequires syntactic and contextual interpretation to reconstruct the meaning. Applications to Address:\nUsed in summarization and conversational systems. 7. Phonological or Acoustic Ambiguity Definition: When spoken language results in words or phrases that sound similar but have different meanings.\nExample: \u0026ldquo;I scream\u0026rdquo; vs. \u0026ldquo;Ice cream.\u0026rdquo; Challenges:\nSpeech-to-text systems need phonological disambiguation to handle homophones correctly. Applications to Address:\nVoice assistants, transcription systems, and speech recognition technologies. 8. Discourse Ambiguity Definition: Ambiguity arising in the relationship between sentences or parts of a text.\nExample: \u0026ldquo;Mary took out her umbrella because it was raining.\u0026rdquo; Does \u0026ldquo;it\u0026rdquo; refer to the weather or something else? Challenges:\nDiscourse-level analysis is needed for coherence and logical interpretation. Applications to Address:\nDocument summarization and storytelling systems. 9. Attachment Ambiguity Definition: When it’s unclear how a phrase or clause should be attached to a sentence.\nExample: \u0026ldquo;The boy saw the dog with the binoculars.\u0026rdquo; Was the boy using the binoculars, or did the dog have them? Challenges:\nRequires advanced parsing to decide the correct attachment based on context. Applications to Address:\nParsing algorithms and sentence interpretation systems. Methods to Resolve Ambiguities Word Sense Disambiguation (WSD): Uses machine learning models to select the most probable meaning of a word. Syntactic Parsing: Analyzes sentence structures to resolve grammatical ambiguities. Contextual Embeddings: Tools like BERT or GPT use surrounding text to infer meaning. Coreference Resolution: Determines which words refer to the same entity. Knowledge Graphs: Encodes relationships between entities to resolve semantic ambiguities. Discourse Analysis: Assesses text coherence and logical flow to clarify sentence relationships. Summary of Challenges Due to Ambiguity in NLP Accuracy: Ambiguities can lead to misinterpretation or errors in automated systems. Context Dependence: Many ambiguities require real-world knowledge or reasoning. Computational Resources: Resolving ambiguities, especially in real time, requires significant resources. Cultural Sensitivity: Idioms and pragmatics vary across languages and cultures, making ambiguity resolution even harder. Addressing these ambiguities effectively is crucial for advancing NLP systems and making them more reliable, robust, and context-aware.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/ambiguities-in-natural-language/","title":"NLP Ambiguities in Natural Language"},{"content":"Bhai, CFG ka full form hai Context-Free Grammar, aur yeh ek set of rules hai jo kisi bhi language (jaise English, Python code, ya ek chatbot ka syntax) ka structure define karta hai. Agar tu sentence ko \u0026ldquo;legally\u0026rdquo; banana chahta hai, toh CFG ke rules ko follow karna zaroori hai. Chhote chhote rules ko mila ke bade sentences bante hain. Chal, isko ekdum chill way mein samajhte hain!\n1. Kya hota hai CFG? CFG ek aisa rule-set hai jo bataata hai ki ek language ke valid sentences ya expressions kaise bante hain. Isko computer ko grammar samjhane ke liye use kiya jaata hai, taaki woh:\nLanguage ko samajh sake (parsing). Valid sentences ko generate kar sake. Example:\n\u0026ldquo;I eat pizza.\u0026rdquo; ✔ Valid sentence \u0026ldquo;Pizza eat I.\u0026rdquo; ❌ Ye toh grammatically galat hai. CFG ke rules ensure karte hain ki sentence grammatically correct ho.\n2. CFG ka structure CFG ke char basic components hote hain:\nNon-Terminals:\nYe variables ki tarah hote hain jo replace ho sakte hain kisi aur cheez se. Example: S, NP, VP (ye symbols hain). Terminals:\nActual words ya tokens jo final output me aayenge. Example: \u0026ldquo;I\u0026rdquo;, \u0026ldquo;eat\u0026rdquo;, \u0026ldquo;pizza\u0026rdquo;. Start Symbol:\nStarting point of the grammar. Usually S hota hai (jiska matlab hai sentence). Production Rules:\nYe rules define karte hain ki kaunsa variable kaise replace hoga. Example: S -\u0026gt; NP VP (iska matlab hai: Sentence (S) ek Noun Phrase (NP) aur Verb Phrase (VP) ka combination hai). 3. Ek Example Grammar Chal, ek example grammar likhte hain jo define karega:\nSentence = Subject + Verb + Object Rules: S -\u0026gt; NP VP\n(Sentence banega: Noun Phrase + Verb Phrase se.) NP -\u0026gt; Det N\n(Noun Phrase banega: Determiner + Noun se.) VP -\u0026gt; V NP\n(Verb Phrase banega: Verb + Noun Phrase se.) Det -\u0026gt; \u0026quot;a\u0026quot; | \u0026quot;the\u0026quot;\n(Determiner ho sakta hai \u0026ldquo;a\u0026rdquo; ya \u0026ldquo;the\u0026rdquo;.) N -\u0026gt; \u0026quot;dog\u0026quot; | \u0026quot;cat\u0026quot; | \u0026quot;pizza\u0026quot;\n(Nouns: dog, cat, pizza.) V -\u0026gt; \u0026quot;eats\u0026quot; | \u0026quot;chases\u0026quot;\n(Verbs: eats, chases.) Parse Example: Start: S S -\u0026gt; NP VP NP -\u0026gt; Det N → the dog VP -\u0026gt; V NP → eats the pizza Final: \u0026ldquo;The dog eats the pizza.\u0026rdquo; 4. Practical Applications Bhai, CFG ka use bahut saari jagah hota hai:\nProgramming Languages: Code ko parse karne ke liye, jaise Python ka syntax check karte hain. Example: if (x \u0026gt; y) { do_something(); } ye CFG se valid hota hai. Natural Language Processing (NLP): Sentences ko analyze karne ke liye grammar ka use hota hai. Example: Parsing a question like \u0026ldquo;Who is the President?\u0026rdquo; Compilers: Tera jo C++ ka compiler hai, wo CFG ko use karke syntax errors pakadta hai. AI Chatbots: Bot ko train karne ke liye, CFG se valid responses banaye jaate hain. 5. Advantages of CFG Simple Structure: Ekdum clean aur logical hota hai. Language Representation: CFG kisi bhi language ke basic structure ko define kar sakta hai. Parsing: Sentences ya code ko easily parse karna possible hota hai. Generative: Grammar se valid strings ya sentences generate kar sakte ho. 6. Limitations of CFG Context Ignorance: CFG sentence ka \u0026ldquo;meaning\u0026rdquo; samajhne mein help nahi karta, bas syntax check karta hai. Example: \u0026ldquo;Colorless green ideas sleep furiously.\u0026rdquo; Syntax correct hai, but meaningless hai. Ambiguity: Ek sentence ke liye multiple parse trees ho sakte hain. Example: \u0026ldquo;The man saw the boy with the telescope.\u0026rdquo; (Who has the telescope?) 7. Ek Mazeed Simple Example CFG Rule: S -\u0026gt; Hello Name Name -\u0026gt; \u0026quot;Ravi\u0026quot; | \u0026quot;Anjali\u0026quot; | \u0026quot;Bhai\u0026quot; Example Parsing: Input: \u0026ldquo;Hello Bhai\u0026rdquo; S -\u0026gt; Hello Name Name -\u0026gt; Bhai Final Output: Valid! 9. Conclusion So bhai, CFG ek tarah ka grammar ka toolkit hai jo define karta hai ki kisi language ke valid sentences kaise bante hain. Yeh programming languages se leke natural languages tak har jagah kaam aata hai.\nAb agar tera friend bole, \u0026ldquo;CFG kya hai?\u0026rdquo;, toh ekdum confidently samjha dena ki:\nCFG ek rule-book hai. Start kar, Non-Terminals aur Terminals ko follow kar, aur valid sentence banake dikha de. 😎 ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/cfg-hinglish/","title":"NLP CFG Hinglish"},{"content":"NLP faces significant challenges due to the complexities and nuances of human language. Below is an explanation of the listed challenges, including examples and their impact on NLP systems:\n1. Contextual Words and Phrases, and Homonyms Description:\nWords or phrases can have different meanings depending on context. Homonyms (e.g., \u0026ldquo;bat\u0026rdquo; can mean a flying mammal or a sports implement) add to the difficulty. Challenges:\nMachines struggle to determine the correct meaning without sufficient context. Requires context-aware models like transformers (e.g., BERT or GPT). Examples:\n\u0026ldquo;The plant is dying.\u0026rdquo; (Plant = factory or organism?) \u0026ldquo;He went to the bank.\u0026rdquo; (Bank = riverbank or financial institution?) 2. Synonyms Description:\nMultiple words can express the same concept, but subtle differences in connotation or usage complicate understanding. Challenges:\nIdentifying synonyms accurately and using the appropriate one based on tone, context, or domain. Maintaining consistency in machine translation or text summarization. Examples:\n\u0026ldquo;Big\u0026rdquo; and \u0026ldquo;large\u0026rdquo; are synonyms, but \u0026ldquo;big deal\u0026rdquo; and \u0026ldquo;large deal\u0026rdquo; do not mean the same thing. In search engines, a query for \u0026ldquo;car\u0026rdquo; should return results for \u0026ldquo;automobile.\u0026rdquo; 3. Irony and Sarcasm Description:\nSarcasm and irony depend on tone, context, or implicit knowledge, making it challenging for NLP systems to detect. Challenges:\nLiteral interpretations of sarcastic comments lead to incorrect sentiment or intent detection. Requires integration of sentiment analysis with pragmatic understanding. Examples:\n\u0026ldquo;Oh, great! Another traffic jam.\u0026rdquo; (Literal = positive, Actual = negative) \u0026ldquo;I just love waiting in long lines.\u0026rdquo; 4. Ambiguity Description:\nLanguage ambiguity can occur at multiple levels: Lexical Ambiguity: Words with multiple meanings. Syntactic Ambiguity: Sentences with multiple grammatical interpretations. Semantic Ambiguity: Unclear meaning of phrases. Pragmatic Ambiguity: Dependence on real-world knowledge or implied meaning. Challenges:\nDisambiguating language often requires deeper context or external knowledge. Examples:\n\u0026ldquo;Flying planes can be dangerous.\u0026rdquo; (Is it dangerous to fly planes or to be around flying planes?) \u0026ldquo;The chicken is ready to eat.\u0026rdquo; (Is the chicken eating or being eaten?) 5. Errors in Text or Speech Description:\nTextual errors include typos, grammatical mistakes, or informal language (e.g., ur instead of your). Speech errors include background noise, accents, or mispronunciations. Challenges:\nError tolerance without losing meaning is difficult for NLP systems. Speech-to-text systems struggle with noisy data or diverse accents. Examples:\nText: \u0026ldquo;Wht r u doin?\u0026rdquo; (Requires normalization to \u0026ldquo;What are you doing?\u0026rdquo;) Speech: \u0026ldquo;Weather\u0026rdquo; vs. \u0026ldquo;Whether\u0026rdquo; (Homophones are harder to differentiate in speech). 6. Idioms and Slang Description:\nIdiomatic expressions and slang often do not have literal meanings and vary across regions and cultures. Challenges:\nUnderstanding idioms requires cultural knowledge. Slang changes rapidly, making it hard for models to stay updated. Examples:\nIdioms: \u0026ldquo;Kick the bucket\u0026rdquo; means \u0026ldquo;to die,\u0026rdquo; not literally kicking a bucket. Slang: \u0026ldquo;That\u0026rsquo;s lit\u0026rdquo; (means exciting, not related to fire). 7. Domain-Specific Language Description:\nTechnical or specialized fields (e.g., medical, legal, or scientific) use unique terminology and phrasing. Challenges:\nGeneral NLP models often fail to interpret domain-specific jargon. Requires domain adaptation or fine-tuning with specialized datasets. Examples:\nMedical: \u0026ldquo;BP\u0026rdquo; might mean \u0026ldquo;blood pressure\u0026rdquo; in healthcare, but \u0026ldquo;boiling point\u0026rdquo; in chemistry. Legal: \u0026ldquo;Statute of limitations\u0026rdquo; has a precise legal meaning that may be misunderstood without context. 8. Low-Resource Languages Description:\nSome languages lack sufficient annotated data for training NLP models, making them \u0026ldquo;low-resource.\u0026rdquo; Challenges:\nDifficult to create accurate models for these languages without sufficient data. Requires innovative approaches like transfer learning or multilingual embeddings. Examples:\nIndigenous languages or dialects like Basque or Xhosa often lack corpora for NLP development. Code-switching (mixing languages in one sentence) further complicates processing. Combined Impact of These Challenges These issues contribute to difficulties in tasks like machine translation, chatbot development, sentiment analysis, and speech recognition. Addressing them requires:\nAdvanced Models: Context-aware systems like transformers (BERT, GPT) for nuanced understanding. Larger and Diverse Datasets: Including idiomatic, slang, domain-specific, and low-resource data. Hybrid Approaches: Combining rule-based systems, statistical methods, and machine learning for better disambiguation. By tackling these challenges, NLP systems can become more robust, accurate, and accessible to diverse global populations.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/challenges-of-nlp/","title":"NLP Challenges of NLP"},{"content":"\u0026lsquo;### Difference Between Semantic Analysis and Syntactic Analysis\nAspect Syntactic Analysis Semantic Analysis Definition ==Focuses== on the structure or ==grammar== of sentences. ==Focuses== on the ==meaning== and ==interpretation== of words, phrases, and sentences. Objective ==Ensures sentences are grammatically correct.== Ensures sentences are ==meaningful== and ==contextually accurate.== Key Concern Checks the ==arrangement== of words in a ==sentence== according to ==grammatical rules==. Checks the ==contextual meaning== of words and phrases. Output Produces a ==parse tree== or ==syntax tree showing== grammatical structure. Produces a ==logical or semantic== ==representation== of the input text. Scope Limited to ==grammar== and ==syntax rules of a language==. ==Goes beyond syntax== to understand context, relationships, and deeper meanings. Ambiguity ==Resolves structural ambiguities== (e.g., sentence phrasing). ==Resolves semantic ambiguities== (e.g., word meanings in context). Techniques Used Parsing algorithms (e.g., CFG parsers, dependency parsing). Word Sense Disambiguation (WSD), Named Entity Recognition (NER), Semantic Role Labeling (SRL). Challenges Handling complex grammatical structures and ambiguities in sentence structure. Interpreting idioms, metaphors, slang, and domain-specific language. Example Checks if \u0026ldquo;He runs fastly\u0026rdquo; is grammatically correct (it\u0026rsquo;s not). Determines if \u0026ldquo;He runs a bank\u0026rdquo; means managing a financial institution or something else. Dependency on Each Other Semantic analysis requires syntactic analysis as a foundation. Syntactic analysis does not require semantic analysis to check grammar. Applications Used in grammar checking tools, compiler design, and sentence parsing. Used in machine translation, chatbots, sentiment analysis, and question answering. This tabular comparison highlights the distinctions and interplay between the two analyses in natural language processing.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/difference-betn-semantic--analysis-and-syntactic-analysis/","title":"NLP Difference betn semantic  analysis and syntactic analysis"},{"content":"","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/discourse-analysis/","title":"NLP Discourse analysis"},{"content":"Knowledge in Language Processing In the context of Natural Language Processing (NLP), knowledge refers to the information and understanding required to process and interpret language accurately. This knowledge can be categorized into different types, reflecting various aspects of language and its use. Here\u0026rsquo;s an overview of the key knowledge areas in language processing:\n1. Linguistic Knowledge Linguistic knowledge includes the fundamental components of language that NLP systems must understand and process.\nPhonological Knowledge Deals with the sound patterns of language, including how words are pronounced and understood in speech. Applications: Speech recognition and text-to-speech systems. Morphological Knowledge Involves the structure of words and how they are formed from smaller units called morphemes (e.g., \u0026ldquo;unbreakable\u0026rdquo; = \u0026ldquo;un\u0026rdquo; + \u0026ldquo;break\u0026rdquo; + \u0026ldquo;able\u0026rdquo;). Applications: Lemmatization, stemming, and tokenization. Syntactic Knowledge Focuses on grammar and the structure of sentences, such as how words combine to form phrases and clauses. Applications: Syntax parsing, grammar checkers. Semantic Knowledge Pertains to the meaning of words, phrases, and sentences, including word sense disambiguation. Applications: Sentiment analysis, question answering. Pragmatic Knowledge Deals with how context and usage influence meaning, such as recognizing sarcasm or implied information. Applications: Chatbots, conversational AI. Discourse Knowledge Concerns the relationships between sentences and paragraphs, ensuring coherence in larger texts. Applications: Document summarization, machine translation. 2. World Knowledge World knowledge refers to general knowledge about the world that humans use to understand language contextually. It includes:\nFacts and Common Sense E.g., \u0026ldquo;The sky is blue\u0026rdquo; or \u0026ldquo;Paris is the capital of France.\u0026rdquo; Applications: Question answering, story generation. Cultural and Social Norms Understanding idioms, humor, and culturally specific references. Applications: Localization and internationalization of NLP systems. Domain-Specific Knowledge Specialized information about specific fields, such as medicine, law, or finance. Applications: Legal document analysis, clinical data processing. 3. Cognitive Knowledge This refers to the mental processes involved in understanding and generating language. It includes:\nMemory and Attention Remembering previous parts of a conversation or text to maintain coherence. Applications: Dialogue systems, long-form text generation. Reasoning Using logical inference to deduce implicit information. Applications: Chatbots, AI for decision-making. Emotional Understanding Recognizing and responding to emotional cues in language. Applications: Sentiment analysis, empathetic virtual assistants. 4. Statistical and Computational Knowledge Modern NLP systems also require computational techniques and statistical models to process and interpret language. This knowledge includes:\nProbability and Statistics Using probabilities to predict the next word or sentence structure. Applications: Language modeling, predictive text. Machine Learning Models Training systems to recognize patterns in text or speech using supervised, unsupervised, or reinforcement learning. Applications: Named entity recognition (NER), text classification. Deep Learning Techniques Leveraging neural networks, especially transformers, for advanced NLP tasks. Applications: BERT, GPT, and other state-of-the-art models. 5. Key Challenges in Language Knowledge Processing Ambiguity\nWords or phrases often have multiple meanings (e.g., \u0026ldquo;bank\u0026rdquo; as a financial institution or riverbank). Context Dependence\nMeaning changes depending on the situation (e.g., \u0026ldquo;Can you pass the ball?\u0026rdquo; vs. \u0026ldquo;Can you pass the salt?\u0026rdquo;). Idiomatic Expressions\nPhrases that don’t mean what the individual words suggest (e.g., \u0026ldquo;kick the bucket\u0026rdquo; means \u0026ldquo;to die\u0026rdquo;). Multilingual and Dialectal Variations\nDifferences in grammar, vocabulary, and pronunciation across languages and regions. Incomplete or Noisy Input\nDealing with incomplete sentences or misspelled words (e.g., \u0026ldquo;wats the tm tomoro?\u0026rdquo;). Applications of Knowledge in NLP Speech Recognition\nUnderstanding spoken language through phonological and world knowledge. Machine Translation\nLeveraging syntactic, semantic, and cultural knowledge for accurate translations. Text Analysis\nExtracting insights from unstructured text using statistical and semantic knowledge. Dialogue Systems\nUsing pragmatic and discourse knowledge for coherent and contextually appropriate responses. Information Retrieval\nEnhancing search engine accuracy with world and linguistic knowledge. Key Concepts in Knowledge-Based NLP Knowledge Graphs\nRepresent relationships between entities, like Google’s Knowledge Graph for search. Ontologies\nFormal representations of knowledge within a domain. Semantic Role Labeling\nIdentifying the roles of words in a sentence (e.g., agent, action, object). Commonsense AI\nTeaching machines to understand and reason with everyday knowledge. Contextual Embeddings\nUsing models like BERT to understand words in context. By integrating linguistic, world, cognitive, and computational knowledge, NLP systems can become more robust, context-aware, and effective at understanding and generating human language.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/knowledge-in-language-processing/","title":"NLP Knowledge in Language Processing"},{"content":"https://www.geeksforgeeks.org/natural-language-processing-overview/\nDefinition of Natural Language Processing (NLP) Natural Language Processing (NLP) is a branch of artificial intelligence (AI) that focuses on the interaction between computers and humans using natural language. It involves enabling machines to understand, interpret, process, and respond to human language in a meaningful way.\nLevels of NLP NLP involves various levels of linguistic processing:\nPhonological Level: Deals with the sound structure of language, including phonetics and phonology. Focus: Speech recognition and text-to-speech conversion. Morphological Level: Analyzes the structure of words and their smallest meaningful units, called morphemes. Focus: Word formation and tokenization. Syntactic Level: Concerned with the arrangement of words and phrases to form grammatically correct sentences. Focus: Parsing, syntax trees, and grammar checks. Semantic Level: Deals with the meaning of words, phrases, and sentences. Focus: Word sense disambiguation and understanding context. Pragmatic Level: Examines the use of language in context and the effect of context on meaning.\nFocus: Sentiment analysis and discourse interpretation. Discourse Level: Focuses on larger units of text, such as paragraphs or conversations, and how they relate to each other. Focus: Coherence and anaphora resolution. World Knowledge Level: Incorporates real-world knowledge to better understand the context and meaning.\nFocus: Building intelligent systems that can reason about the world. Applications of NLP Language Translation: Google Translate, Microsoft Translator. Speech Recognition: Siri, Alexa, Cortana. Chatbots and Virtual Assistants: ChatGPT, customer support bots. Sentiment Analysis: Analyzing social media posts, reviews, and opinions. Text Summarization: Extractive and abstractive summarization of documents. Information Retrieval: Search engines like Google. Healthcare Applications: Medical report analysis, predictive healthcare. Spam Detection: Filtering unwanted emails. Named Entity Recognition (NER): Identifying entities like names, dates, and places in text. Content Recommendation: Suggesting articles, music, or movies. Advantages of NLP Automation: Reduces the need for manual text processing. Improved Communication: Enhances machine-human interactions. Efficiency: Processes vast amounts of text or speech data quickly. Accessibility: Makes information accessible to people with disabilities (e.g., voice-to-text for visually impaired individuals). Personalization: Tailors recommendations and services to individual preferences. Disadvantages of NLP Complexity: Human languages are inherently ambiguous and context-dependent. High Computational Cost: Advanced NLP models require significant resources. Bias and Ethics: Models can inherit biases from training data. Language Limitations: Many NLP systems are less effective for low-resource languages. Misinterpretation Risks: Errors in understanding can lead to miscommunication. Types of NLP Rule-Based NLP: Relies on predefined linguistic rules. Statistical NLP: Uses probabilistic methods and models derived from large datasets. Hybrid NLP: Combines rule-based and statistical approaches. Deep Learning-Based NLP: Leverages neural networks, particularly transformers, for tasks like translation and summarization. Usage of NLP Business: Sentiment analysis for brand monitoring, automated customer service. Healthcare: Diagnosis assistance, processing medical literature. Education: Grammatical error checking, content generation. Media: Summarizing news articles, content moderation. Security: Threat detection, analyzing cyber communication patterns. Features of NLP Text Processing: Tokenization, stemming, lemmatization. Language Understanding: Parsing, sentiment analysis, intent recognition. Machine Translation: Converting text from one language to another. Speech Processing: Speech-to-text and text-to-speech. Contextual Awareness: Leveraging context for better understanding. Key Concepts in NLP Tokenization: Breaking text into smaller units like words or sentences. Part-of-Speech Tagging (POS): Assigning word categories (noun, verb, etc.). Named Entity Recognition (NER): Identifying entities like names, dates, or locations. Parsing: Analyzing the grammatical structure of a sentence. Sentiment Analysis: Detecting emotions or opinions in text. Word Embeddings: Representing words as vectors for computational efficiency. Transformers: Advanced architectures like BERT and GPT for contextual understanding. Semantic Similarity: Determining the similarity in meaning between phrases or documents. By understanding these foundational and advanced aspects of NLP, industries can harness the power of AI to process and analyze human language more effectively.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/natural-language-processing/","title":"NLP Natural language processing"},{"content":"Words and their senses are intricately related in ==linguistics== and ==natural language== ==processing== (NLP). ==A single word can have multiple meanings (polysemy)==, and ==different words can share the same meaning (synonymy).== Understanding these relations is crucial for applications such as machine translation, semantic search, and natural language understanding.\n1. Polysemy Definition: A single word with multiple related senses. Example: \u0026ldquo;Bank\u0026rdquo; can mean: A financial institution. The side of a river. The different meanings are related through their historical or contextual usage. 2. Homonymy Definition: Words that have the same spelling or pronunciation but entirely unrelated senses. Types: Homophones: Same pronunciation, different meanings (e.g., \u0026ldquo;bear\u0026rdquo; (animal) and \u0026ldquo;bare\u0026rdquo; (uncovered)). Homographs: Same spelling, different meanings (e.g., \u0026ldquo;lead\u0026rdquo; (to guide) and \u0026ldquo;lead\u0026rdquo; (a metal)). Example: \u0026ldquo;Bark\u0026rdquo; (tree covering) vs. \u0026ldquo;Bark\u0026rdquo; (dog\u0026rsquo;s sound). 3. Synonymy Definition: Different words with the same or nearly the same meaning. Example: \u0026ldquo;Big\u0026rdquo; and \u0026ldquo;large.\u0026rdquo; Note: Absolute synonymy is rare; synonyms often differ in connotation, formality, or usage. 4. Antonymy Definition: Words that are opposite in meaning. Types: Complementary Antonyms: Mutually exclusive (e.g., \u0026ldquo;dead\u0026rdquo; vs. \u0026ldquo;alive\u0026rdquo;). Gradable Antonyms: Represent degrees (e.g., \u0026ldquo;hot\u0026rdquo; vs. \u0026ldquo;cold\u0026rdquo;). Relational Antonyms: Express relationships (e.g., \u0026ldquo;teacher\u0026rdquo; vs. \u0026ldquo;student\u0026rdquo;). Example: \u0026ldquo;Happy\u0026rdquo; vs. \u0026ldquo;Sad.\u0026rdquo; 5. Hyponymy Definition: A hierarchical relationship where one word is a more specific type of another. Example: \u0026ldquo;Dog\u0026rdquo; is a hyponym of \u0026ldquo;animal.\u0026rdquo; \u0026ldquo;Rose\u0026rdquo; is a hyponym of \u0026ldquo;flower.\u0026rdquo; 6. Hypernymy Definition: The reverse of hyponymy; a word that is more general than another. Example: \u0026ldquo;Animal\u0026rdquo; is a hypernym of \u0026ldquo;dog.\u0026rdquo; \u0026ldquo;Flower\u0026rdquo; is a hypernym of \u0026ldquo;rose.\u0026rdquo; 7. Meronymy Definition: A part-to-whole relationship. Example: \u0026ldquo;Wheel\u0026rdquo; is a meronym of \u0026ldquo;car.\u0026rdquo; \u0026ldquo;Branch\u0026rdquo; is a meronym of \u0026ldquo;tree.\u0026rdquo; 8. Holonymy Definition: The reverse of meronymy; a whole-to-part relationship. Example: \u0026ldquo;Car\u0026rdquo; is a holonym of \u0026ldquo;wheel.\u0026rdquo; \u0026ldquo;Tree\u0026rdquo; is a holonym of \u0026ldquo;branch.\u0026rdquo; 9. Troponymy Definition: A type of verb relationship where one verb is a more specific manner of another verb. Example: \u0026ldquo;Whisper\u0026rdquo; is a troponym of \u0026ldquo;speak.\u0026rdquo; \u0026ldquo;Jog\u0026rdquo; is a troponym of \u0026ldquo;run.\u0026rdquo; 10. Homosemy Definition: Words that have the same meaning in different contexts or senses. Example: \u0026ldquo;Light\u0026rdquo; can consistently mean \u0026ldquo;not heavy\u0026rdquo; in multiple contexts (e.g., physical objects, metaphors). 11. Word Sense Disambiguation (WSD) Definition: The process of determining which sense of a word is being used in a specific context. Importance: Resolves polysemy. Ensures the correct interpretation in applications like machine translation and sentiment analysis. Example: Sentence: \u0026ldquo;She went to the bank.\u0026rdquo; WSD identifies if \u0026ldquo;bank\u0026rdquo; refers to a riverbank or a financial institution based on context. 12. Applications in NLP Search Engines: Use synonymy and polysemy to provide relevant results. Machine Translation: Resolves polysemy and synonymy to produce accurate translations. Semantic Search: Explores hypernymy and hyponymy for broader or specific searches. Chatbots: Interpret relationships between words to understand user queries. ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/relation-between-words-and-senses/","title":"NLP Relation between words and senses"},{"content":"focused on understanding the meaning and context of words, sentences, and text. It goes beyond syntax to interpret the relationships between words and their meanings in specific contexts.\n1. Definition Semantic analysis interprets the meaning of words, phrases, sentences, and larger text units. It helps machines understand language at a deeper level by analyzing contextual meaning rather than just grammatical structures. 2. Objectives of Semantic Analysis Understanding Word Meaning:\nRecognize and differentiate between meanings of the same word (e.g., \u0026ldquo;bank\u0026rdquo; as a financial institution vs. riverbank). Identifying Relationships:\nEstablish connections between entities (e.g., in “Alice owns a car,” Alice is related to a car by ownership). Disambiguating Context:\nResolve ambiguities in word usage depending on the context (e.g., \u0026ldquo;crane\u0026rdquo; as a bird or a machine). Generating Human-Like Responses:\nSupport applications like chatbots or virtual assistants that need to respond naturally. 3. Levels of Semantic Analysis Lexical Semantics:\nStudies the meaning of individual words, including: Synonyms (e.g., \u0026ldquo;big\u0026rdquo; and \u0026ldquo;large\u0026rdquo;). Antonyms (e.g., \u0026ldquo;hot\u0026rdquo; vs. \u0026ldquo;cold\u0026rdquo;). Homonyms (e.g., \u0026ldquo;bark\u0026rdquo; of a tree vs. a dog\u0026rsquo;s bark). Sentence Semantics:\nExplores the meaning of a complete sentence by analyzing: Sentence structure. How words contribute to overall meaning. Discourse Semantics:\nFocuses on the meaning of larger text units (paragraphs, documents) to understand coherence and context. Pragmatics:\nInterprets implied meaning based on situational context (e.g., \u0026ldquo;Can you pass the salt?\u0026rdquo; is a request, not a literal question). 4. Components of Semantic Analysis Word Sense Disambiguation (WSD):\nIdentifies the correct meaning of a word in context (e.g., \u0026ldquo;The bat flew in the night\u0026rdquo; refers to the animal, not the sports equipment). Named Entity Recognition (NER):\nIdentifies and classifies entities in text (e.g., “Barack Obama” as a person, “Google” as an organization). Semantic Role Labeling (SRL):\nAssigns roles to words in a sentence (e.g., who did what to whom). Relationship Extraction:\nIdentifies connections between entities (e.g., “Google acquired YouTube” shows an acquisition relationship). 5. Methods Used in Semantic Analysis ==Rule-Based Approaches:== Relies on manually defined linguistic rules and patterns for interpretation. ==Machine Learning-Based Approaches:== Uses algorithms like Support Vector Machines (SVMs) or neural networks to learn patterns from annotated data. ==Deep Learning Approaches:== Leverages models like BERT, GPT, and transformers to understand context and meaning. 6. Applications of Semantic Analysis search engines chatbots and virtual assistants sentiment analysis text summarization machine translation e-comm 7. Advantages improved understanding of text enhanced UI context - aware search better decision making 8. Challenges ambiguity idioms and slangs domain specific lang resource req low resourse lang 9. Key Concepts in Semantic Analysis Ontology: A structured representation of concepts and their relationships in a domain. Word Embeddings: Vector representations of words (e.g., Word2Vec, GloVe) that capture semantic relationships. Semantic Similarity: Measures how similar two pieces of text are in meaning. Contextual Understanding: Interprets meaning based on surrounding words and sentences. 10. Example of Semantic Analysis Sentence: \u0026ldquo;John went to the bank to deposit money.\u0026rdquo;\nWord Sense Disambiguation: \u0026ldquo;Bank\u0026rdquo; here refers to a financial institution, not a riverbank. Named Entity Recognition: \u0026ldquo;John\u0026rdquo; is a person. Semantic Role Labeling: \u0026ldquo;John\u0026rdquo; is the subject (who). \u0026ldquo;Deposit money\u0026rdquo; is the action (what). \u0026ldquo;Bank\u0026rdquo; is the location (where). ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/semantic-analysis/","title":"NLP semantic analysis"},{"content":"Definition:\nWord Sense Disambiguation (WSD) is the ==process of identifying the correct sense or meaning of a word in a given context.== It addresses the challenge of polysemy, where a single word can have multiple meanings. For instance, the word \u0026ldquo;bank\u0026rdquo; can refer to a financial institution or the side of a river, depending on the context.\nKey Components of WSD Word (Lexeme): The ambiguous word that needs disambiguation. Sense Inventory: A repository of possible meanings of a word, such as WordNet, which provides a structured list of senses. Context: Surrounding words, sentences, or text that provide clues about the intended meaning. Importance of WSD Improves Text Understanding: Critical for applications like machine translation, information retrieval, and question answering. Enables Accurate Processing: Resolves ambiguity in natural language for better semantic analysis. Facilitates NLP Applications: Powers tools like chatbots, virtual assistants, and search engines. Approaches to WSD There are three primary approaches to Word Sense Disambiguation:\n1. Knowledge-Based Methods Rely on external lexical resources like WordNet to disambiguate word meanings. Techniques: Lesk Algorithm:\nCompares the definitions (glosses) of each sense of a word with the context. Selects the sense with the maximum overlap of words between the gloss and the context. Example:\nWord: Bank Context: \u0026ldquo;He went to the bank to deposit money.\u0026rdquo; Overlap with \u0026ldquo;financial institution\u0026rdquo; gloss \u0026gt; overlap with \u0026ldquo;riverbank\u0026rdquo; gloss. Semantic Similarity:\nUses hierarchical relationships (e.g., hypernyms, hyponyms) in lexical databases to determine the most similar sense. 2. Supervised Learning Methods Treat WSD as a classification problem where a machine learning model predicts the correct sense based on labeled data. Techniques: Feature Engineering: Extracts features such as: Surrounding words (context window). Part of Speech (POS) tags. Syntactic dependencies. Algorithms: Decision Trees, Naïve Bayes, SVMs, and Neural Networks. Example: Training data: (bank, financial institution), (bank, riverbank). Model learns the contextual patterns associated with each sense and predicts accordingly. Challenges: Requires large labeled datasets. Domain-specific differences can complicate training. 3. Unsupervised Learning Methods Do not require labeled training data. Instead, they cluster similar contexts and infer senses from these clusters. Techniques: Clustering:\nGroups instances of a word into clusters based on similarity in usage (e.g., using cosine similarity of word embeddings). Contextual Embeddings:\nUses models like BERT, which learn sense distinctions based on context in an unsupervised manner. Example: Word embeddings for \u0026ldquo;bank\u0026rdquo; in \u0026ldquo;deposit money\u0026rdquo; and \u0026ldquo;riverbank\u0026rdquo; are placed in different clusters, differentiating the senses. Challenges: May not explicitly associate clusters with human-readable meanings. Steps in WSD Input Collection:\nObtain the ambiguous word and its context (e.g., a sentence or document). Sense Inventory Lookup:\nRetrieve all possible senses for the ambiguous word from a resource like WordNet. Context Analysis:\nExamine the surrounding words, sentence structure, or broader context to gather disambiguating clues. Disambiguation:\nApply an algorithm (knowledge-based, supervised, or unsupervised) to select the most appropriate sense. Output:\nReturn the disambiguated sense of the word. Challenges in WSD Ambiguity in Context:\nThe context itself may not be sufficient to determine the correct sense. Low-Resource Languages:\nLack of comprehensive lexical databases or labeled datasets for many languages. Domain-Specific Usage:\nWords may have specialized meanings in different fields (e.g., \u0026ldquo;model\u0026rdquo; in AI vs. fashion). Idioms and Metaphors:\nPhrases like \u0026ldquo;kick the bucket\u0026rdquo; require cultural and idiomatic understanding beyond simple word senses. Data Sparsity:\nSupervised methods need large annotated datasets, which may not always be available. Applications of WSD Machine Translation:\nDisambiguates words to ensure accurate translation into the target language. Search Engines:\nEnhances relevance by understanding query intent (e.g., \u0026ldquo;bank\u0026rdquo; as financial vs. natural). Question Answering:\nInterprets word meanings in questions to provide precise answers. Information Retrieval:\nImproves document indexing and retrieval by resolving polysemy. Chatbots and Virtual Assistants:\nEnables context-aware responses by distinguishing word meanings. Tools for WSD WordNet:\nA lexical database widely used for knowledge-based WSD. NLTK (Python):\nProvides implementations of WSD algorithms like Lesk. SpaCy:\nOffers word embeddings and contextual analysis for WSD. Transformers (Hugging Face):\nPretrained language models like BERT and GPT excel at context-based WSD. Example of WSD Sentence:\n\u0026ldquo;The bass was too loud for the audience.\u0026rdquo;\nAmbiguous Word:\n\u0026ldquo;Bass\u0026rdquo; (fish or low-frequency sound). Sense Inventory:\n\u0026ldquo;Bass\u0026rdquo; (fish): An aquatic animal. \u0026ldquo;Bass\u0026rdquo; (sound): Low-frequency audio. Context Analysis:\nSurrounding words like \u0026ldquo;loud\u0026rdquo; and \u0026ldquo;audience\u0026rdquo; suggest a musical context. Output:\nThe correct sense is \u0026ldquo;bass\u0026rdquo; (low-frequency sound). Conclusion Word Sense Disambiguation is a cornerstone of semantic analysis in NLP. It enables machines to interpret language more accurately by resolving ambiguities. Although challenges remain, advances in deep learning and contextual embeddings are making WSD more effective, supporting applications in diverse domains like search, translation, and conversational AI.\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/word-sense-disambiguation/","title":"NLP Word Sense Disambiguation"},{"content":"exam nlp\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/2024-11-30/","title":"post 2024-11-30"},{"content":"Data profiling engine diagram analyse data\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/techgium/","title":"post techgium"},{"content":"code of app.tsx with tailwind css // App.tsx import React, { useState, useEffect } from \u0026#39;react\u0026#39;; import ReactMarkdown from \u0026#39;react-markdown\u0026#39;; import { PlusCircle, FileText, Save } from \u0026#39;lucide-react\u0026#39;; import Chatbot from \u0026#39;./Chatbot\u0026#39;; import NoteGraph from \u0026#39;./NoteGraph\u0026#39; import \u0026#39;./App.css\u0026#39; interface Note { id: string; title: string; content: string; links: string[]; lastModified: Date; } interface GraphData { nodes: Array\u0026lt;{ id: string; name: string }\u0026gt;; links: Array\u0026lt;{ source: string; target: string }\u0026gt;; } const App: React.FC = () =\u0026gt; { const [notes, setNotes] = useState\u0026lt;Note[]\u0026gt;(() =\u0026gt; { const savedNotes = localStorage.getItem(\u0026#39;notes\u0026#39;); return savedNotes ? JSON.parse(savedNotes) : []; }); const [currentNote, setCurrentNote] = useState\u0026lt;Note | null\u0026gt;(null); const [graphData, setGraphData] = useState\u0026lt;GraphData\u0026gt;({ nodes: [], links: [] }); const [isDarkMode, setIsDarkMode] = useState(true); // Save notes to localStorage whenever they change useEffect(() =\u0026gt; { localStorage.setItem(\u0026#39;notes\u0026#39;, JSON.stringify(notes)); }, [notes]); // Update graph data whenever notes change useEffect(() =\u0026gt; { updateGraphData(notes); }, [notes]); const extractLinks = (content: string): string[] =\u0026gt; { const linkRegex = /\\[\\[(.*?)\\]\\]/g; const matches = content.match(linkRegex) || []; return matches.map(match =\u0026gt; match.slice(2, -2)); }; const updateGraphData = (notesData: Note[]) =\u0026gt; { const nodes = notesData.map(note =\u0026gt; ({ id: note.id, name: note.title, })); const links: Array\u0026lt;{ source: string; target: string }\u0026gt; = []; notesData.forEach(note =\u0026gt; { note.links.forEach(linkTitle =\u0026gt; { const targetNote = notesData.find(n =\u0026gt; n.title === linkTitle); if (targetNote) { links.push({ source: note.id, target: targetNote.id, }); } }); }); setGraphData({ nodes, links }); }; const createNewNote = () =\u0026gt; { const newNote: Note = { id: Date.now().toString(), title: \u0026#39;Untitled Note\u0026#39;, content: \u0026#39;\u0026#39;, links: [], lastModified: new Date(), }; setNotes(prev =\u0026gt; [...prev, newNote]); setCurrentNote(newNote); }; const updateNoteContent = (id: string, content: string) =\u0026gt; { setTimeout(() =\u0026gt; { window.scrollTo(0, 0); }, 1); const updatedNotes = notes.map(note =\u0026gt; { if (note.id === id) { const links = extractLinks(content); return { ...note, content, links, lastModified: new Date() }; } return note; }); setNotes(updatedNotes); if (currentNote) { setCurrentNote({ ...currentNote, content, lastModified: new Date() }); } }; const updateNoteTitle = (id: string, title: string) =\u0026gt; { const updatedNotes = notes.map(note =\u0026gt; { if (note.id === id) { return { ...note, title, lastModified: new Date() }; } return note; }); setNotes(updatedNotes); if (currentNote) { setCurrentNote({ ...currentNote, title, lastModified: new Date() }); } }; const deleteNote = (id: string) =\u0026gt; { setNotes(notes.filter(note =\u0026gt; note.id !== id)); if (currentNote?.id === id) { setCurrentNote(null); } }; const toggleTheme = () =\u0026gt; { setIsDarkMode(!isDarkMode); document.documentElement.classList.toggle(\u0026#39;dark\u0026#39;); }; useEffect(()=\u0026gt;{ console.log(\u0026#34;reend\u0026#34;) }); return ( \u0026lt;div className={`flex h-screen ${isDarkMode ? \u0026#39;dark\u0026#39; : \u0026#39;\u0026#39;}`}\u0026gt; {/* Sidebar */} \u0026lt;div className=\u0026#34;lg:w-64 w-16 bg-gray-100 dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 flex flex-col transition-all duration-300 ease-in-out\u0026#34;\u0026gt; {/* Sidebar Header */} \u0026lt;div className=\u0026#34;p-4 border-b border-gray-200 dark:border-gray-700\u0026#34;\u0026gt; \u0026lt;button onClick={createNewNote} className=\u0026#34;w-full flex items-center justify-center gap-2 bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition-colors\u0026#34; \u0026gt; \u0026lt;PlusCircle size={20} /\u0026gt; \u0026lt;span\u0026gt;New Note\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* Notes List */} \u0026lt;div className=\u0026#34;flex-1 overflow-y-auto\u0026#34;\u0026gt; {notes.map(note =\u0026gt; ( \u0026lt;div key={note.id} onClick={() =\u0026gt; { setTimeout(() =\u0026gt; { window.scrollTo(0, 0); }, 10); setCurrentNote(note); console.log(\u0026#34;hi\u0026#34;) setTimeout(() =\u0026gt; { window.scrollTo(0, 0); }, 10); } } className={`flex items-center gap-2 p-3 cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors ${currentNote?.id === note.id ? \u0026#39;bg-gray-200 dark:bg-gray-700\u0026#39; : \u0026#39;\u0026#39;}`} \u0026gt; \u0026lt;FileText size={18} className=\u0026#34;text-gray-500 dark:text-gray-400\u0026#34; /\u0026gt; \u0026lt;div className=\u0026#34;flex-1 min-w-0\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;truncate text-gray-900 dark:text-gray-100\u0026#34;\u0026gt;{note.title}\u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;text-xs text-gray-500 dark:text-gray-400\u0026#34;\u0026gt; {new Date(note.lastModified).toLocaleDateString()} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; {/* Theme Toggle */} \u0026lt;div className=\u0026#34;p-4 border-t border-gray-200 dark:border-gray-700\u0026#34;\u0026gt; \u0026lt;button onClick={toggleTheme} className=\u0026#34;w-full py-2 px-4 rounded-lg bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200\u0026#34; \u0026gt; {isDarkMode ? \u0026#39;🌞 Light Mode\u0026#39; : \u0026#39;🌙 Dark Mode\u0026#39;} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {/* Main Content */} \u0026lt;div className=\u0026#34;flex-1 flex flex-col bg-white dark:bg-gray-900\u0026#34; \u0026gt; {currentNote ? ( \u0026lt;div className=\u0026#34;flex-1 flex\u0026#34;\u0026gt; {/* Editor */} \u0026lt;div className=\u0026#34;flex-1 flex flex-col p-4 border-r border-gray-200 dark:border-gray-700\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={currentNote.title} onChange={(e) =\u0026gt; updateNoteTitle(currentNote.id, e.target.value)} className=\u0026#34;w-full mb-4 p-2 text-lg font-semibold bg-transparent border-b border-gray-200 dark:border-gray-700 text-gray-900 dark:text-gray-100 focus:outline-none focus:border-blue-500\u0026#34; placeholder=\u0026#34;Note Title\u0026#34; /\u0026gt; \u0026lt;textarea style={{\u0026#34;height\u0026#34;:\u0026#34;50vh\u0026#34;}} value={currentNote.content} onChange={(e) =\u0026gt; updateNoteContent(currentNote.id, e.target.value)} className=\u0026#34;flex-1 w-full p-2 bg-transparent text-gray-900 dark:text-gray-100 focus:outline-none resize-none\u0026#34; placeholder=\u0026#34;Write your note here... Use [[Note Title]] to link to other notes.\u0026#34; /\u0026gt; \u0026lt;div className=\u0026#34;flex justify-between items-center pt-2 text-sm text-gray-500 dark:text-gray-400\u0026#34;\u0026gt; \u0026lt;div\u0026gt; Last modified: {new Date(currentNote.lastModified).toLocaleString()} \u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; deleteNote(currentNote.id)} className=\u0026#34;text-red-500 hover:text-red-600 px-2 py-1 rounded\u0026#34; \u0026gt; Delete Note \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {/* Preview */} \u0026lt;div className=\u0026#34;flex-1 p-4 overflow-auto bg-gray-50 dark:bg-gray-800\u0026#34; style={{\u0026#34;height\u0026#34;:\u0026#34;50vh\u0026#34;}}\u0026gt; \u0026lt;div className=\u0026#34;prose dark:prose-invert max-w-none\u0026#34;\u0026gt; \u0026lt;ReactMarkdown\u0026gt;{currentNote.content} \u0026lt;/ReactMarkdown\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;w-96\u0026#34;\u0026gt; \u0026lt;Chatbot noteTitle={currentNote.content} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) : ( \u0026lt;div className=\u0026#34;flex-1 flex items-center justify-center text-gray-500 dark:text-gray-400\u0026#34;\u0026gt; Select or create a note to get started \u0026lt;/div\u0026gt; )} {/* Graph View */} \u0026lt;div className=\u0026#34;h-64 border-t border-gray-200 dark:border-gray-700\u0026#34;\u0026gt; \u0026lt;NoteGraph graphData={graphData} notes={notes} setCurrentNote={setCurrentNote} isDarkMode={isDarkMode} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/projects/oopsidian/","title":"Projects Oopsidian"},{"content":"[[fusion flux]]\n[[Oopsidian]]\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/projects/project-index/","title":"Projects Project Index"},{"content":"","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/projects/unity-3d-simulation-inventry-management/","title":"Projects unity 3d simulation inventry management"},{"content":"Operating Systems DBMS Computer Networks System Design\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/resume/common/","title":"resume common"},{"content":"Docker ( Containerization ) Jenkins ( CICD ) Azure Aws Git ( VCS ) Kubernities ( Orchestration ) Teraform , Ansible ( Configuration Management ) linux Shell Scripting (Bash) Python\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/resume/devops---cloud/","title":"resume DevOps - Cloud"},{"content":"HTML CSS JS NextJS ReactJS NodeJS Javascript MYSQL PostgreSQL MongoDB Postman\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/resume/fullstack-dev/","title":"resume FullStack Dev"},{"content":"","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/resume/resume-index/","title":"resume Resume Index"},{"content":"[[6 Social Skills to master for a Magnetic Aura]]\n[[how to be a good communicator]]\n[[Greatest Comeback]]\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/self-learnings-and-improvements/1.main/","title":"self learnings and improvements 1 main"},{"content":"understanding the social dynamics understand that nobody is higher and lower than me ( respect ourself and others ). prepare yourself acc to event | dress acc to event. have a positive attitude | optimistic mindset. always greet people with smile have welcoming body posture, and be nonjudgmental. mimic gestures | mimic body lang, tone, gestures etc . mimicing is an art don\u0026rsquo;t make uncomfortable anyone. knowing abt spotlight effect ( ease ur nervousness down ). nobody is thinking abt us | so take a chill pill. mesmerizer names | remember names - aura ++ break the ice | make the small talk more interesting. ask open ended questions (what did you do in weekend). how is your work | what are the interesting projects u are working on. complements works | personality complements . personal achievements . go with the flow . don\u0026rsquo;t be interesting be interested ( be good listener ) ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/self-learnings-and-improvements/6-social-skills-to-master-for-a-magnetic-aura/","title":"self learnings and improvements 6 Social Skills to master for a Magnetic Aura"},{"content":" fix a ==goal== || be excellent || practical achievable goals Disappearing (==sacrifice every bad thing==, that i like) ==never discuss any of the goal with anybody== { don\u0026rsquo;t tell \u0026ndash; just do it } Every action has equal and opposite reaction {there is ==no alternative to work==} cut-down every ==negative people== from our life make an ==actionable plan== ( good time table ((weekly and monthly)) Visualize and ==follow an idols== unleashing the beast {try to feel ==under pressure==} ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/self-learnings-and-improvements/greatest-comeback/","title":"self learnings and improvements Greatest Comeback"},{"content":" you cannot be a good communicator unless you are good listener active listening = not rushing to interrupt good vocab ( ) refer : https://www.youtube.com/watch?v=AE_JUJFyV-E\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/self-learnings-and-improvements/how-to-be-a-good-communicator/","title":"self learnings and improvements how to be a good communicator"},{"content":"AR\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sih-project/ar-app/","title":"SIH Project AR app"},{"content":"Storage container godown cold storage (blue) iot devices (camera , sensors) docking area Checkout area organise (color coded boxes) ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sih-project/vr-app/","title":"SIH Project VR APP"},{"content":"[[SQL handwritten notes]]\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/sql/sql-index/","title":"SQL SQL Index"},{"content":"Week 1: Azure Load Balancers and Application Gateways Day 1: Sessions 114–119\nAzure Load Balancer Service (6 min) Lab - Basic Load Balancer - Setup, Deployment, Configuration, NAT Rules (~23 min) Assignment 4: Using NAT Rules Day 2: Sessions 120–125\nStandard SKU Load Balancer Labs (~40 min) Day 3: Sessions 126–133\nAzure Application Gateway (Basics and Labs) (~40 min) Day 4: Sessions 134–140\nDeleting resources, DNS for Azure VMs, Azure Public DNS, Private DNS Labs (~40 min) Day 5: Sessions 141–145\nWeb App - Virtual Network Integration (Setup, Database server, Application) (~40 min) Day 6: Quiz + Assignment 4 (~1 hour)\nDay 7: Review Load Balancer Labs + Concepts (~1 hour)\nWeek 2: Storage Accounts Basics Day 8: Sessions 149–157\nWhat are Storage Accounts, Blob Service Basics, Access Keys (~30 min) Day 9: Sessions 158–164\nShared Access Signatures, Storage Redundancy, Immutable Blob (~30 min) Day 10: Sessions 165–172\nAccess Tiers, Lifecycle Policies, File Shares (~35 min) Day 11: Sessions 173–179\nSoft Delete, Storage Encryption, AzCopy Tool (~30 min) Day 12: Assignment 5 + Practice (~1 hour)\nDay 13: Quiz 3 + Review Storage Accounts (~1 hour)\nDay 14: Revision and Labs for Storage (~1 hour)\nWeek 3: Role-Based Access Control (RBAC) Day 15: Sessions 186–193\nMicrosoft Entra ID, Role-Based Assignments, Azure Storage RBAC (~40 min) Day 16: Sessions 194–202\nRole Assignment Conditions, Licenses, Self-Service Password Reset (~35 min) Day 17: Sessions 203–209\nResource Tags, Moving Resources, Locking Resources (~35 min) Day 18: Sessions 210–217\nAzure Policy Service, Management Groups Labs (~35 min) Day 19: Assignment 6 + Quiz (~1 hour)\nDay 20: Review RBAC and Practice Labs (~1 hour)\nDay 21: Practice Labs and Quiz (~1 hour)\nWeek 4: Azure Monitor and Backup Day 22: Sessions 218–224\nAzure Monitor Service, Alerts, Log Analytics Workspace (~35 min) Day 23: Sessions 225–232\nLog Analytics Queries, Custom Logs, Azure Backup (~40 min) Day 24: Sessions 233–240\nBackup File Restore, MARS Agent, Recovery (~35 min) Day 25: Sessions 241–248\nSite Recovery, Backup Vaults (~40 min) Day 26: Quiz + Revision (~1 hour)\nDay 27: Practice Test (~1 hour)\nDay 28: Review Azure Monitor and Backup Labs (~1 hour)\nWeek 5: Automation with PowerShell and CLI Day 29: Sessions 251–264\nIntro to PowerShell, Resource Group Creation, CLI Basics (~40 min) Day 30: Sessions 265–277\nAzure CLI Advanced Commands, VM Creation, Storage Account (~40 min) Day 31: Practice Labs for PowerShell and CLI (~1 hour)\nDay 32: Quiz + Review (~1 hour)\nWeek 6: ARM Templates and Bicep Day 33: Sessions 281–291\nARM Templates, Deployment, Variables (~40 min) Day 34: Sessions 292–303\nSecure Strings, Availability Sets, Data Disks, Custom Script Extensions (~40 min) Day 35: Sessions 311–319\nBicep Basics, Variables, Parameters (~35 min) Day 36: Sessions 320–330\nBicep Labs: Creating Resources and Secure Strings (~35 min) Day 37: Practice Labs for ARM Templates + Bicep (~1 hour)\nDay 38: Assignments and Review (~1 hour)\nWeek 7: Revision and Practice Tests Day 39–42:\nFocused revision on key sections: Load Balancers, Application Gateway, DNS (~1 hour/day) Day 43–46:\nFocused revision: Storage Accounts, RBAC, Backup (~1 hour/day) Day 47: Full Practice Test 1 (~1 hour)\nDay 48: Review and fix errors from Practice Test 1 (~1 hour)\nDay 49: Full Practice Test 2 (~1 hour)\nDay 50: Review and fix errors from Practice Test 2 (~1 hour)\nWeek 8: Final Prep for Exam Day 51–55: Redo critical labs (1 hour/day)\nDay 56: Rest and relax before the exam (~1 hour)\nDay 57: Final Practice Test (~1 hour)\nDay 58: Go through any remaining weak areas (~1 hour)\nDay 59: Review cheat sheets, quick notes (~1 hour)\nDay 60: Exam Day – All Set!\n","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/timelines/az-104/","title":"Timelines AZ-104"},{"content":"1. Definition: Deep learning is a subset of machine learning that uses neural networks with multiple layers to model complex patterns. 2. Neural Network Structure: Consists of input layer, hidden layers, and output layer. Each neuron performs weighted sum and activation function. 3. Activation Functions: Sigmoid, ReLU, Tanh, Softmax. Non-linear functions to introduce complexity. 4. Types of Neural Networks: Feedforward Neural Networks (FNN) Convolutional Neural Networks (CNN) – Image processing. Recurrent Neural Networks (RNN) – Sequential data (e.g., time series). Generative Adversarial Networks (GANs) – Data generation. 5. Training: Uses backpropagation to minimize error. Optimization via gradient descent (SGD, Adam). 6. Loss Functions: Mean Squared Error (MSE), Cross-Entropy. 7. Overfitting: Happens when the model learns noise. Mitigated by techniques like dropout, regularization. 8. Batch Normalization: Normalizes layer inputs, speeding up training and improving stability. 9. Epochs and Batches: Epoch: One full cycle through training data. Batch: Subset of data for one forward and backward pass. 10. Popular Frameworks: TensorFlow, PyTorch, Keras. Good luck with your viva!\n1. Perceptron: Used for binary classification (e.g., yes/no, true/false). Simplest type of neural network (single-layer). Consists of input nodes, weights, bias, and output node. Activation function (e.g., step function) used for binary classification. 2. Multilayer Perceptron (MLP): Extension of perceptron with multiple hidden layers. Fully connected layers. Uses non-linear activation functions (e.g., ReLU, sigmoid). Can solve non-linear problems, unlike single-layer perceptron. 1. Perceptron: Used for binary classification (e.g., yes/no, true/false). 2. Multilayer Perceptron (MLP): Classification (e.g., image, text). Regression (predicting continuous values). Pattern recognition (e.g., handwriting, speech). Function approximation (learning complex mappings). 1. Sigmoid Activation Function: Formula: $( \\sigma(x) = \\frac{1}{1 + e^{-x}} )$ Range: 0 to 1. Uses: Binary classification tasks. Advantages: Smooth gradient, interpretable output as probability. Disadvantages: Can cause vanishing gradient problem; slow convergence for large input values. 2. Tanh (Hyperbolic Tangent) Function: Formula: $\\text{tanh}(x) = \\frac{e^x - e^{-x}}{e^x + e^{-x}}$ Range: -1 to 1. Uses: Classification tasks where negative values are significant. Advantages: Centered around zero, stronger gradient than sigmoid. Disadvantages: Can also suffer from vanishing gradient. 3. ReLU (Rectified Linear Unit): Formula: $f(x) = \\max(0, x)$ Range: 0 to infinity. Uses: Most common in hidden layers of deep networks. Advantages: Solves vanishing gradient problem, fast computation. Disadvantages: Can cause dying ReLU problem (neurons stuck inactive for negative inputs). 4. Leaky ReLU: $$\nFormula: ( f(x) = x ) if ( x \u0026gt; 0 ), otherwise ( f(x) = 0.01x ). $$ Range: Negative to infinity. Uses: Variation of ReLU to handle negative inputs. Advantages: Prevents dying ReLU problem. Disadvantages: Requires tuning of the leak factor. 5. Softmax Function: Formula: ( \\sigma(x_i) = \\frac{e^{x_i}}{\\sum_{j} e^{x_j}} ) Range: 0 to 1 (outputs sum to 1). Uses: Multi-class classification (probabilities for each class). Advantages: Outputs interpretable probabilities. Disadvantages: Sensitive to large input values, risk of gradient saturation. 6. Swish: Formula: ( f(x) = x \\cdot \\sigma(x) ) (where ( \\sigma(x) ) is the sigmoid). Range: Negative to infinity. Uses: Emerging as a smoother alternative to ReLU. Advantages: Better gradient flow, smoother transitions. Disadvantages: More computationally expensive. ","date":"2024-12-20T00:00:00Z","permalink":"http://localhost:1313/post/viva/deep-learning/","title":"viva Deep learning"},{"content":"==Linear DS consist of nodes with some sort of data, and a pointer, or link, to the next node.==️ data: The value stored in the node Pointer/Link: a reference to the next node on the sequence\nA big benefit with using linked lists is that ==nodes are stored wherever there is free space in memory, the nodes do not have to be stored contiguously right after each other like elements are stored in arrays==. Another nice thing with linked lists is that when adding or removing nodes, the r️️️️️est of the nodes in the list do not have to be shifted.\nTypes singly linked list: Each node points to the next node Doubly Linked List: Each node points to both the next and previous nodes. Circular Linked List: The last node points back to the first node. Basic Operations in Linked Lists Insertion: At the beginning. At the end. At a specific position. Deletion: From the beginning. From the end. From a specific position. Traversal: Printing all elements. Counting nodes. Search: Finding a specific value. Reverse the Linked List. Linked list vs Array In memory, an array is stored in [[contiguous memory locations]], where elements are accessed via direct indexing, making it faster for random access but requiring a fixed size. In contrast, a linked list stores nodes in ==non-contiguous memory==, connected by pointers, allowing ==dynamic resizing== but with ==slower access due to sequential traversal.==\nThe image below shows ==how a linked list can be stored in memory==. The linked list has four nodes with values 3, 5, 13 and 2, and each node has a pointer to the next node in the list.\nUnlike with arrays, the nodes in a linked list are not placed right after each other in memory. This means that when inserting or removing a node, shifting of other nodes is not necessary, so that is a good thing.\nTypes of linked list singly linked lists Doubly linked lists Circular linked list A singly linked list is the ==simplest kind of linked lists==. It takes up ==less space in memory because each node has only one address to the next nod==e, like in the image below.\nA doubly linked list has nodes with ==addresses to both the previous and the next node==, like in the image below, and therefore ==takes up more memory==. But doubly linked lists are ==good if you want to be able to move both up and down in the list.==\ncircular linked list is like a singly or doubly linked list with the first node, the \u0026ldquo;head\u0026rdquo;, and the last node, the \u0026ldquo;tail\u0026rdquo;, connected.\nCircular linked lists are good for lists you need to cycle through continuously.\nJava code for Linked lists [[Single linked list]]\nwhat is linked list\nHere is a concise summary of what a Linked List is:\nA linked list is a data structure consisting of nodes, each containing a value and a reference (or link) to the next node in the sequence. This allows for efficient insertion and deletion of elements at any position in the list, making it suitable for applications that require frequent updates. The order of elements in a linked list can be sorted or unsorted, and it is commonly used in algorithms such as stacks and queues, as well as in databases to manage data storage and retrieval.\nCode for linked list class Node { int data; // Node ka data Node next; // Agli node ka reference Node(int data) { // Constructor to initialize the node this.data = data; this.next = null; } } Singly linked list operations in java class LinkedList { // Head node of the Linked List private Node head; // Node class class Node { int data; Node next; Node(int data) { // Constructor this.data = data; this.next = null; } } // Insert a new node at the end public void insertAtEnd(int data) { Node newNode = new Node(data); if (head == null) { // If list is empty head = newNode; return; } Node temp = head; // Start from head while (temp.next != null) { // Traverse to the last node temp = temp.next; } temp.next = newNode; // Point the last node to new node } // Insert at the beginning public void insertAtBeginning(int data) { Node newNode = new Node(data); newNode.next = head; // New node points to current head head = newNode; // New node becomes the head } // Delete a node by value public void deleteByValue(int value) { if (head == null) { // Empty list System.out.println(\u0026#34;List is empty\u0026#34;); return; } // If the head node itself holds the value if (head.data == value) { head = head.next; // Shift head to the next node return; } Node temp = head; while (temp.next != null \u0026amp;\u0026amp; temp.next.data != value) { temp = temp.next; // Traverse until value is found } if (temp.next == null) { System.out.println(\u0026#34;Value not found in the list\u0026#34;); return; } temp.next = temp.next.next; // Skip the node to be deleted } // Display the Linked List public void display() { if (head == null) { System.out.println(\u0026#34;List is empty\u0026#34;); return; } Node temp = head; // Start from head while (temp != null) { System.out.print(temp.data + \u0026#34; -\u0026gt; \u0026#34;); temp = temp.next; } System.out.println(\u0026#34;null\u0026#34;); } public static void main(String[] args) { LinkedList list = new LinkedList(); // Insert nodes list.insertAtEnd(10); list.insertAtEnd(20); list.insertAtEnd(30); // Display list list.display(); // Output: 10 -\u0026gt; 20 -\u0026gt; 30 -\u0026gt; null // Insert at beginning list.insertAtBeginning(5); list.display(); // Output: 5 -\u0026gt; 10 -\u0026gt; 20 -\u0026gt; 30 -\u0026gt; null // Delete a node list.deleteByValue(20); list.display(); // Output: 5 -\u0026gt; 10 -\u0026gt; 30 -\u0026gt; null } } ","date":"2024-11-15T00:00:00Z","permalink":"http://localhost:1313/post/dsa/1.-linked-list/","title":"Linked list"},{"content":"watch this video\nhttps://www.youtube.com/watch?v=nq82V5OpapE\nhttps://summerofcode.withgoogle.com/\norganisations which is of devops\nCloud Native Computing Foundation (CNCF) Jenkins KubeVirt QEMU Stratosphere Laboratory\ni want to contribute to jenkins organisation\nhttps://summerofcode.withgoogle.com/programs/2024/organizations/jenkins-wp\nhttps://www.jenkins.io/projects/gsoc/contributors/\n","date":"2024-11-06T00:00:00Z","permalink":"http://localhost:1313/post/gsoc/gsoc-google-summer-of-code/","title":"GSOC - Google Summer Of Code"},{"content":"![alt text](devops roadmap.pdf)\n","date":"2024-10-31T00:00:00Z","permalink":"http://localhost:1313/post/devops---cloud/devops-roadmap/","title":"DevOps Roadmap"},{"content":"[[Super 30]]\n[[1. Basic Java]] [[2. Conditions and loops]] [[loops questions for interviews]] [[2. oops in java]] [[Switch Cases and Statements in java]] [[functions in java]] [[3. Time and Space Complexity]] [[Strings and StringBuilder in java]] [[string questions]] [[Mathematics for DSA]] Searching algorithms [[Linear Search Algorithm]] [[Binary search Algorithm]] [[Binary Search Algo Questions]] [[Binary search in 2d arrays]] [[String Questions]] sorting algorithms [[1. Bubble sort]] [[2. Selection sort]] [[3. insertion sort]] [[4. Merge sort ]] Quick sort Heap sort [[4. Patterns]] [[5. Recursion]] [[Arrays]] [[Array Questions]] [[Java recursion problems solved can be asked in interview]] [[6. Backtracking]] [[1. Linked List]] [[Linked list code.canvas|Linked list code]] [[Stack]] Queue Binary Tree BST HashSet HashMap Trie Graph ","date":"2024-10-25T00:00:00Z","permalink":"http://localhost:1313/post/dsa/0.-dsa-index/","title":"syllabus for DSA"},{"content":" [[1. Basic Java]] [[2. oops in java]] [[3. Time and Space Complexity]] sorting algorithms [[1. Bubble sort]] [[2. Selection sort]] [[3. insertion sort]] [[4. Merge sort ]] Quick sort Heap sort [[4. Patterns]] [[5. Recursion]] [[Java recursion problems solved can be asked in interview]] [[6. Backtracking]] Linked List Stack Queue Binary Tree BST HashSet HashMap Trie Graph ","date":"2024-10-25T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/java-index/","title":"syllabus for DSA"},{"content":"Assignment Syllabus module 4 [[AutoEncoders]] Here\u0026rsquo;s an expanded comparison with more details about each type of autoencoder, covering additional aspects like training challenges, implementation considerations, and real-world use cases:\nType of Autoencoder Description Loss Function Key Features Applications Training Challenges Implementation Considerations Linear Autoencoder Uses only linear transformations, making it analogous to PCA for linear dimensionality reduction Mean Squared Error (MSE) between input and reconstructed output Best suited for data that requires only linear transformation; cannot capture non-linear relationships Dimensionality reduction, data compression, linear feature extraction Limited representation capability with non-linear data Straightforward implementation; useful for initial data analysis Sparse Autoencoder Adds a sparsity penalty to encourage hidden layer neurons to be mostly inactive, forcing the model to learn compact and efficient features MSE + Sparsity Penalty (e.g., KL divergence) Promotes learning sparse, informative representations; effective at capturing localized features Feature extraction, anomaly detection, image recognition Balancing sparsity constraint with data fidelity; may require tuning Consider adjustable sparsity parameters; may use ReLU or L1 regularization Undercomplete Autoencoder Uses a bottleneck architecture with fewer hidden units than input units, forcing the model to prioritize essential features MSE or Cross-Entropy (for binary data) Naturally avoids overfitting by limiting model capacity; compact representations ideal for data compression Dimensionality reduction, feature extraction, data compression Can still overfit on small datasets; requires careful bottleneck size selection Suitable for small and mid-size datasets; often combined with non-linear activation functions Overcomplete Autoencoder Has more hidden units than input units, making it prone to overfitting without regularization MSE + Regularization (e.g., Dropout, Weight Decay) Higher capacity; can capture complex data structures but risks learning identity mappings Feature learning, deep feature extraction, complex pattern recognition Requires strong regularization to prevent overfitting; can be computationally intensive Can leverage large neural architectures; regularization is critical Denoising Autoencoder Trains on corrupted inputs with the aim of reconstructing the original, clean version, promoting robustness to noise MSE with Input Noise (Gaussian, salt-and-pepper, etc.) Effective at denoising data and learning features that are robust to noisy or incomplete inputs Image denoising, data cleaning, pretraining for downstream tasks Training on noisy data can be computationally demanding; quality of reconstruction may vary with noise level Requires careful choice of noise type and level; noise added during each training epoch Contractive Autoencoder Adds a penalty term on the Jacobian of the encoder to make learned features resistant to small perturbations in input data MSE + Jacobian Penalty (e.g., L2 norm of the Jacobian) Promotes stable and smooth feature representations; robust to small input changes Manifold learning, regularization, representation learning Jacobian penalty increases computational cost; requires tuning of contraction strength Best suited for manifold data; can help with learning invariant representations Additional Points Linear Autoencoder:\nReal-World Use Cases: It’s often used in cases where data relationships are linear, such as financial data and basic signal processing. Pros: Simple, interpretable, computationally efficient. Cons: Cannot handle complex, non-linear patterns, limiting its applicability in many real-world tasks. Sparse Autoencoder:\nReal-World Use Cases: Useful for image processing, where localized features (e.g., edges, textures) need to be identified. Pros: Helps in learning meaningful, interpretable features; robust in high-dimensional spaces. Cons: May require significant tuning of sparsity parameters; risk of learning redundant features if sparsity is too high. Undercomplete Autoencoder:\nReal-World Use Cases: Popular in anomaly detection, where unusual data points may not be well-represented in the compressed form. Pros: Efficient for compression and dimension reduction; prevents trivial mappings. Cons: Overly narrow bottlenecks can cause information loss; requires sufficient data to train effectively. Overcomplete Autoencoder:\nReal-World Use Cases: Suitable for tasks where a rich, detailed feature set is needed, such as in deep learning for complex images. Pros: High capacity for detailed feature extraction; adaptable to complex tasks. Cons: Overfitting risk; requires careful balancing of capacity and regularization. Denoising Autoencoder:\nReal-World Use Cases: Widely used for image and audio denoising, where data is often noisy or incomplete. Pros: Improves robustness to noise and data corruption; can enhance generalization in downstream tasks. Cons: Choosing the right noise level is crucial; excessive noise can degrade performance. Contractive Autoencoder:\nReal-World Use Cases: Often used in manifold learning, where the goal is to learn stable representations that capture continuous data variations. Pros: Provides smooth representations that are robust to small changes; can be useful for generating high-quality embeddings. Cons: Computationally demanding due to the Jacobian penalty; may require careful selection of the penalty strength to avoid excessive smoothing. module 5 Sequence learning Definition/Introduction: An autoencoder is a type of artificial neural network designed to learn efficient data representations in an unsupervised manner. It consists of two main components: an encoder that compresses input data into a lower-dimensional space (latent representation), and a decoder that reconstructs the original input from this compressed representation.\nImportance/Significance: Autoencoders are crucial for dimensionality reduction, data compression, and learning latent features of data without requiring labeled datasets. They are often used in feature learning, anomaly detection, and image denoising, enabling systems to discover useful patterns.\nAim/Goal/Purpose: The primary goal of an autoencoder is to reconstruct the original input as accurately as possible from its compressed form. In doing so, it forces the network to learn meaningful lower-dimensional representations of the data.\nFeatures/Characteristics: Unsupervised learning: Autoencoders do not require labeled data. Symmetric architecture: The encoder and decoder usually have a symmetric structure. Bottleneck layer: The middle layer (latent space) represents the compressed version of the input. Loss function: The difference between the input and the reconstructed output (e.g., Mean Squared Error) is minimized. Activation functions: Autoencoders use activation functions like ReLU, sigmoid, or tanh in their layers. Working/Process: Encoder: Compresses the input data into a lower-dimensional latent space representation by applying linear transformations and nonlinear activations. Bottleneck (latent space): The compressed form that ideally captures the essential information of the input. Decoder: Reconstructs the input from the latent representation by reversing the transformations of the encoder. Loss Calculation: The reconstruction error, often computed as the difference between the original input and the reconstructed output, guides the training of the network through backpropagation. Types/Classification: Vanilla Autoencoder: The basic form that compresses and reconstructs data. Denoising Autoencoder: Trained to remove noise from data by adding noise to input and learning the clean version. Sparse Autoencoder: Encourages sparsity in the latent space to learn more distinctive features. Variational Autoencoder (VAE): Incorporates probabilistic modeling in the latent space, used in generative modeling. Convolutional Autoencoder (CAE): Employs convolutional layers for image-based data to capture spatial hierarchies. Examples: Image denoising: Removing noise from corrupted images by learning clean representations. Anomaly detection: Detecting outliers in data by learning the \u0026ldquo;normal\u0026rdquo; reconstruction patterns. Dimensionality reduction: Compressing high-dimensional data (e.g., images) into a compact latent representation for visualization or further processing. Usage/Applications: Data compression: Reducing the size of data for storage and transmission. Image generation: Used in generative models like VAEs to create realistic images from latent space. Anomaly detection: Identifying anomalies in industrial equipment or cybersecurity by detecting reconstruction errors. Feature extraction: Learning compact representations that can be used in downstream tasks like classification or clustering. Advantages/Benefits: Efficient data compression: Reduces the size of data while preserving essential information. Unsupervised learning: Does not require labeled data for training. Feature learning: Learns meaningful representations that can enhance performance in other tasks. Noise removal: Denoising autoencoders can clean noisy input data effectively. Disadvantages/Limitations: Loss of detail: The compression may lose important details, especially in complex data. Training complexity: Autoencoders can be challenging to train and tune. Overfitting: They may memorize the training data instead of learning general patterns, especially if the latent space is too large. Poor generalization: They may not generalize well to unseen data, especially in high-dimensional spaces. Comparison with Similar Concepts: PCA (Principal Component Analysis): Both are used for dimensionality reduction, but autoencoders can capture nonlinear relationships in data, whereas PCA is linear. GANs (Generative Adversarial Networks): Both can be used for data generation, but GANs use an adversarial process, while autoencoders rely on reconstruction. RBMs (Restricted Boltzmann Machines): Like autoencoders, RBMs are used in unsupervised learning for feature extraction, but they model probabilistic relationships. Conclusion: Autoencoders are powerful tools in unsupervised learning, particularly for dimensionality reduction, data compression, and feature extraction. Despite some challenges in training and limitations in generalization, they remain essential in various applications like anomaly detection and generative modeling.\nEncoder Input layer takes raw input data\nThe hidden layers progressively reduce the dimensionality of the input, capturing important features and patterns. These layers compose the encoder.\nThe bottleneck layer (latent space) is the final hidden layer, where the dimensionality is significantly reduced. This layer represents the compressed encoding of the input data.\nDecoder The bottleneck layer takes the encoded representation and expands it back to the dimensionality of the original input.\nThe hidden layers progressively increase the dimensionality and aim to reconstruct the original input.\nThe output layer produces the reconstructed output, which ideally should be as close as possible to the input data.\nEasy Explanation (Bhai ki Tarah) Sequence learning ka matlab hai ki data jo ek specific order mein aata hai, jaise tumhe ek movie ya song sunne ka sequence hota hai, ussi tarah machine bhi sequence ko samajhti hai. Jaise agar main tumhe kal kya kiya tha poochu, to tumhe kal ke events ek sequence mein yaad aayenge. Machine learning mein bhi kuch problems aise hote hain jahan hume ye order ya sequence samajhna padta hai.\nDefinition A sequence learning problem involves learning from sequential data, where the order of the data points is important. This can include time-series data, language data (like sentences), or any data that changes over time and follows a certain pattern or order.\nImportance/Significance Sequence learning is crucial in many real-world applications such as natural language processing (NLP), speech recognition, time-series forecasting, and video analysis. The sequential nature of data is essential in these problems, where past information influences future predictions.\nAim/Goal/Purpose The primary goal of sequence learning is to model and predict the next item(s) in a sequence or to classify/understand the entire sequence. It aims to capture temporal or contextual dependencies within the data.\nFeatures/Characteristics Temporal Dependence: The current state is dependent on past information. Order Matters: Unlike typical classification or regression, the order of data points is crucial. Sequential Inputs/Outputs: The input and/or output can be a sequence of data points. Context-Aware Learning: The system uses context from past steps to make future predictions. Working/Process Data Input: The sequence (e.g., words in a sentence, stock prices over time) is fed into the model. Processing: A sequence learning model (like RNN, LSTM, or GRU) processes each element of the sequence while retaining memory of previous elements. Prediction: Based on the processed information, the model predicts the next element in the sequence or provides an output (classification, translation, etc.). Training: The model is trained on multiple sequences to capture patterns, temporal dependencies, and relationships. Types/Classification Supervised Sequence Learning: The model learns to predict future sequence elements based on labeled data (e.g., time-series forecasting). Unsupervised Sequence Learning: The model learns to capture patterns in the sequence without labeled data (e.g., clustering sequences). Sequence-to-Sequence: The input and output are both sequences (e.g., machine translation). Sequence Classification: The input is a sequence, and the output is a class label (e.g., sentiment analysis). Examples Natural Language Processing (NLP): Predicting the next word in a sentence (language modeling). Time-Series Forecasting: Predicting future stock prices based on past trends. Speech Recognition: Converting spoken words into text by understanding the sequence of sounds. Music Generation: Creating new melodies based on a sequence of musical notes. Usage/Applications Speech Recognition (e.g., Siri, Google Assistant) Machine Translation (e.g., translating text between languages) Stock Market Prediction (predicting future trends based on historical data) Autonomous Driving (predicting future vehicle movements) Chatbots (understanding and generating coherent dialogues) Advantages/Benefits Temporal Awareness: Captures time-dependent or contextual relationships. Versatility: Applicable to various domains like language, speech, finance, etc. Improved Predictions: Better for tasks where the past influences the future. Memory Handling: Models like LSTMs and GRUs can handle long-term dependencies. Disadvantages/Limitations Long Sequences: Difficult to capture very long-term dependencies in data. Training Time: Sequence learning models, especially with large datasets, take longer to train. Vanishing/Exploding Gradients: In traditional RNNs, gradients can vanish or explode, leading to poor learning. Data Hungry: Requires a large amount of sequential data for good performance. Comparison with Similar Concepts Sequence Learning vs. Traditional Learning: Traditional learning methods (like feedforward neural networks) don\u0026rsquo;t account for order, whereas sequence learning models like RNNs and LSTMs are designed specifically to handle ordered data. Sequence Learning vs. Time-Series Analysis: Time-series analysis focuses primarily on temporal data, while sequence learning covers broader areas like language and behavior prediction. Conclusion Sequence learning is essential for tasks where the order of data points matters, such as language processing, time-series forecasting, and speech recognition. Models like RNNs, LSTMs, and GRUs are used to handle these problems by learning patterns and relationships within sequential data. Despite some challenges, sequence learning opens the door to powerful applications in various domains.\nIn deep learning, sequence learning involves training models to recognize patterns in sequences of data, such as time-series, text, or audio. These types of models (such as Recurrent Neural Networks (RNNs), Long Short-Term Memory networks (LSTMs), or Transformers) can handle various types of input-output relationships. These relationships are categorized into several types based on the structure of the input and output sequences. Here are the main types of sequence learning:\n1. One-to-One (Single Input to Single Output) Description: This is the most basic type of mapping, where a single input is mapped to a single output. It doesn\u0026rsquo;t involve any sequential data. Example: Image classification, where a single image is mapped to a single class label (input → output). Model Type: Standard feedforward neural networks or convolutional neural networks (CNNs). 2. One-to-Many (Single Input to Sequence Output) Description: Here, a single input is used to generate a sequence of outputs. Example: Image captioning, where an image (single input) is translated into a sequence of words (caption). Model Type: This is usually handled by an encoder (CNN) to a decoder (RNN or Transformer). 3. Many-to-One (Sequence Input to Single Output) Description: A sequence of inputs is used to predict a single output. Example: Sentiment analysis, where a sequence of words (text) is mapped to a single sentiment label (positive or negative). Model Type: RNNs, LSTMs, GRUs, or Transformers can handle this scenario. 4. Many-to-Many (Sequence Input to Sequence Output, Timed) Description: This is when both input and output are sequences of the same length. The model generates an output for each input element at each time step. Example: Video classification, where each frame in the video is classified as a sequence. Model Type: RNNs or 3D CNNs can handle these types of tasks. 5. Many-to-Many (Sequence Input to Sequence Output, Unaligned) Description: Here, the input sequence and output sequence are of different lengths. This is commonly used in tasks where one sequence is transformed into another. Example: Machine translation, where a sentence in one language (input sequence) is translated into a sentence in another language (output sequence). Model Type: Sequence-to-sequence (Seq2Seq) models, usually with an encoder-decoder architecture using LSTMs or Transformers. LSTM LSTM (Long Short-Term Memory) is a type of recurrent neural network (RNN) that is designed to better handle sequential data. Unlike traditional RNNs, which struggle with long-term dependencies (forgetting information after a certain time), LSTMs are designed to remember information for long periods and can learn when to keep and forget information. Here\u0026rsquo;s a detailed breakdown of LSTMs:\n1. Why LSTM? Traditional RNNs face a challenge called the vanishing gradient problem, where gradients become extremely small during backpropagation, making it hard for the network to learn long-range dependencies. This makes RNNs ineffective for tasks that require memory of past data over a long duration (e.g., predicting a word based on a sentence or text classification). LSTMs solve this problem.\n2. LSTM Structure LSTMs introduce a memory cell and gates that control the flow of information. Here\u0026rsquo;s a breakdown of its components:\na. Cell State (Memory) This is the core idea of LSTMs. It acts like a conveyor belt, running through the entire chain with only minor linear interactions. Information can be added or removed via gates. The cell state is what allows LSTMs to remember or forget information selectively. b. Gates LSTMs use three gates to control the flow of information in and out of the cell:\nForget Gate: Decides what part of the previous cell state to forget. Input Gate: Decides what new information to store in the cell state. Output Gate: Controls how much of the current cell state to output as the hidden state. c. How it Works Forget Gate: The forget gate takes the previous hidden state (h_(t-1)) and the current input (x_t), passes them through a sigmoid function to produce a value between 0 and 1. If it\u0026rsquo;s close to 0, the network forgets that information; if it\u0026rsquo;s close to 1, the network keeps it.\n$f_t = \\sigma(W_f \\cdot [h_{t-1}, x_t] + b_f)$\nInput Gate: The input gate decides which values to update. It has two parts:\nA sigmoid layer that determines which values to update. A tanh layer that creates new candidate values that could be added to the cell state. $i_t = \\sigma(W_i \\cdot [h_{t-1}, x_t] + b_i)$\n$\\tilde{C}t = \\tanh(W_C \\cdot [h{t-1}, x_t] + b_C)$\nUpdate the Cell State: After the forget and input gates decide what to forget and what new information to add, the cell state is updated as follows:\n$C_t = f_t * C_{t-1} + i_t * \\tilde{C}_t$\nOutput Gate: The output gate determines the next hidden state (h_t), which is based on the current cell state but controlled through a sigmoid function. $o_t = \\sigma(W_o \\cdot [h_{t-1}, x_t] + b_o)$\nThe hidden state is computed as: $h_t = o_t * \\tanh(C_t)$\n3. How LSTM Handles Sequence Data LSTMs are well-suited for sequence-based tasks because of their ability to selectively remember long-term information while also being able to forget irrelevant data. This makes them powerful for tasks like:\nText Generation Speech Recognition Time Series Forecasting Machine Translation 4. Variants of LSTM Over time, different variations of LSTMs have been developed:\nBidirectional LSTM (BiLSTM): It processes data in both directions, allowing the model to have both past and future context when making predictions. Stacked LSTM: Multiple LSTM layers stacked on top of each other to increase model complexity. 5. Advantages of LSTM Solves the Vanishing Gradient Problem: LSTMs are capable of learning and remembering over long sequences. Efficient Memory Management: The gates allow LSTM to selectively memorize and forget information, making it more efficient in handling long sequences. Versatile: Used in a variety of tasks, especially those involving time dependencies (e.g., video processing, speech recognition, language modeling). 6. Applications of LSTM Natural Language Processing (NLP): Used in tasks like machine translation, sentiment analysis, and text generation. Speech Recognition: Models can predict the next phoneme or word based on past inputs. Time Series Prediction: Stock market predictions, weather forecasting, etc. Video Analysis: Used to model sequences in videos for tasks like activity recognition. In summary, LSTMs are a powerful tool for learning from sequences, and their ability to handle long-term dependencies makes them suitable for complex tasks requiring memory over time.\nGRU A GRU (Gated Recurrent Unit) is a type of recurrent neural network (RNN) that is similar to Long Short-Term Memory (LSTM) but with a simpler architecture. Like LSTMs, GRUs are designed to solve the vanishing gradient problem and better handle long-range dependencies in sequential data, but they do so with fewer gates and parameters, which makes them computationally more efficient.\nHere’s a detailed breakdown of GRUs:\n1. Why GRU? GRUs were introduced to simplify the complexity of LSTMs while still retaining their ability to model long-term dependencies. GRUs use fewer gates and operations, which reduces their computational cost and speeds up training. They are often used as an alternative to LSTMs when you need a faster and more lightweight model without sacrificing much performance.\n2. GRU Architecture Unlike LSTMs, which have three gates (forget, input, and output) and a separate memory cell, GRUs have only two gates:\nReset Gate Update Gate They also directly control the flow of information without needing a separate memory cell, making the structure more straightforward.\na. Reset Gate The reset gate controls how much of the previous memory (hidden state) to forget. If the reset gate is close to zero, the GRU forgets a lot of the previous information. If it’s close to one, it retains most of the previous memory. b. Update Gate The update gate determines how much of the previous memory (hidden state) to carry forward into the next time step. It decides the proportion of the new information to mix with the past information. c. How it Works Reset Gate Formula:\nThe reset gate is calculated using a sigmoid function, taking the current input x_t and the previous hidden state h_(t-1) as inputs:\n$$ r_t = \\sigma(W_r \\cdot [h_{t-1}, x_t] + b_r) $$ Here, W_r represents the weight matrix for the reset gate, and b_r is the bias term.\nUpdate Gate Formula:\nSimilarly, the update gate uses a sigmoid function to decide how much of the previous state to carry forward: $$\nz_t = \\sigma(W_z \\cdot [h_{t-1}, x_t] + b_z) $$\nCandidate Hidden State (New Memory):\nThe new memory (or candidate hidden state) is created based on the reset gate. The reset gate decides how much of the previous hidden state should contribute to the new memory. This is calculated as follows:\n$$ \\tilde{h}t = \\tanh(W_h \\cdot [r_t * h{t-1}, x_t] + b_h) $$\nThis is where the reset gate plays a key role, by filtering out the irrelevant parts of the previous hidden state h_(t-1).\nFinal Hidden State:\nThe final hidden state is a linear combination of the previous hidden state h_(t-1) and the new candidate hidden state \\tilde{h}_t. The update gate controls this combination:\n$$ h_t = z_t * h_{t-1} + (1 - z_t) * \\tilde{h}_t $$\nIf the update gate (z_t) is close to 1, the model retains the previous hidden state. If it’s close to 0, the model updates the hidden state with the new memory.\n3. How GRU Handles Sequential Data GRUs, like LSTMs, are able to capture long-term dependencies in sequential data because of their gating mechanism. The update and reset gates allow the GRU to learn which parts of the data to remember and which parts to forget as it processes sequences over time. This makes GRUs suitable for tasks where understanding the context of previous steps is important.\n4. Comparison to LSTM Simpler Architecture: GRUs are simpler than LSTMs, as they have fewer gates (2 vs. 3) and no separate memory cell. This makes them faster to train and requires fewer parameters. Efficiency: GRUs tend to be more efficient than LSTMs, especially for tasks where the dataset is large and computational resources are a concern. Performance: In practice, GRUs and LSTMs perform similarly on many tasks, but the performance may vary depending on the specific problem. GRUs may work better for shorter sequences, while LSTMs might have an edge for longer, more complex sequences. 5. Advantages of GRU Fewer Parameters: GRUs have fewer parameters than LSTMs, leading to faster training and inference times. Efficient Memory Use: Since GRUs use a simpler mechanism, they are more memory-efficient. Better for Shorter Sequences: GRUs often perform better on shorter sequences due to their simpler structure. 6. Applications of GRU GRUs are widely used in many of the same applications as LSTMs:\nNatural Language Processing (NLP): GRUs are used for tasks like machine translation, language modeling, and text classification. Time Series Prediction: Used to model time-series data such as stock market predictions or weather forecasting. Speech Recognition: Like LSTMs, GRUs are also effective in speech recognition tasks where long-term context is crucial. Video Processing: GRUs can be used for sequential data in videos, especially when there is a need for real-time processing due to their efficiency. 7. GRU vs. LSTM: When to Use? Use GRU when:\nYou need faster computation and training. The sequences are relatively short or computational resources are limited. Use LSTM when:\nYou need more flexibility and power in handling long sequences with more complex patterns. 8. Mathematical Summary Reset Gate: Controls what parts of the previous memory to forget. $$ r_t = \\sigma(W_r \\cdot [h_{t-1}, x_t] + b_r) $$\nUpdate Gate: Controls how much of the new information to mix with the old memory. $$ z_t = \\sigma(W_z \\cdot [h_{t-1}, x_t] + b_z) $$\nNew Memory: Uses the reset gate to create the new memory. $$ \\tilde{h}t = \\tanh(W_h \\cdot [r_t * h{t-1}, x_t] + b_h)\n$$\nFinal Hidden State: Combines the old and new memories using the update gate. $$ h_t = z_t * h_{t-1} + (1 - z_t) * \\tilde{h}_t\n$$\n9. Conclusion GRUs are a simplified and efficient alternative to LSTMs, offering similar functionality in handling sequential data but with fewer parameters and computational complexity. They are particularly useful in situations where faster training and inference times are essential, while still maintaining the ability to capture long-term dependencies in d\nGAN Generative Adversarial Networks (GANs) are a type of neural network architecture used for generating new data samples that resemble a given set of training data. Introduced by Ian Goodfellow in 2014, GANs have become one of the most popular and powerful methods in unsupervised learning for generating realistic data, such as images, music, and even text.\nBasic Concept of GANs: GANs consist of two neural networks that work against each other (hence the term \u0026ldquo;adversarial\u0026rdquo;): Generator (G):\nThe generator’s job is to generate new data samples that are similar to the real data.\nDiscriminator (D):\nThe discriminator’s job is to distinguish between real data (from the training dataset) and fake data (generated by the generator).\nThe generator and discriminator are in a constant \u0026ldquo;game\u0026rdquo; against each other:\nThe generator tries to create data that can fool the discriminator into thinking it\u0026rsquo;s real. The discriminator tries to get better at distinguishing between real and fake data. The competition between these two networks pushes the generator to produce data that is increasingly realistic over time.\nHow GANs Work: Generator Network:\nThe generator takes in a random noise vector (usually sampled from a Gaussian distribution) as input. It tries to transform this random noise into a meaningful data sample (like an image). Initially, the generated data is poor quality, but over time, as the generator improves, the samples start resembling real data more closely. Discriminator Network:\nThe discriminator is a classifier that receives two types of inputs: real data from the training set and fake data generated by the generator. It tries to correctly label each input as either \u0026ldquo;real\u0026rdquo; or \u0026ldquo;fake.\u0026rdquo; The output of the discriminator is typically a probability, where a higher value indicates that the input is real, and a lower value indicates that it is fake. The GAN Training Process: GANs are trained in an alternating process where both networks improve simultaneously:\nStep 1 (Train the Discriminator):\nThe discriminator is trained to classify real data as \u0026ldquo;real\u0026rdquo; and fake data as \u0026ldquo;fake.\u0026rdquo; It tries to maximize its ability to distinguish between the two types of data. Step 2 (Train the Generator):\nThe generator is trained to produce data that the discriminator classifies as \u0026ldquo;real.\u0026rdquo; It tries to minimize its loss by generating more realistic data that can fool the discriminator. The generator\u0026rsquo;s objective is to minimize the discriminator\u0026rsquo;s ability to correctly classify generated samples, while the discriminator\u0026rsquo;s objective is to maximize its classification accuracy. This creates a \u0026ldquo;min-max\u0026rdquo; optimization problem.\nThe loss functions for both networks can be written as:\nDiscriminator loss: $$ L_D = - \\left[ \\log(D(x_{\\text{real}})) + \\log(1 - D(G(z))) \\right] $$\nWhere ( D(x_{\\text{real}}) ) is the discriminator\u0026rsquo;s prediction for real data, and ( D(G(z)) ) is the discriminator\u0026rsquo;s prediction for generated data.\nGenerator loss: $$ L_G = - \\log(D(G(z))) $$\nThe generator\u0026rsquo;s goal is to maximize the probability that the discriminator misclassifies its generated data as real.\nOver time, the generator gets better at producing realistic data, and the discriminator improves its ability to tell real from fake. However, as training progresses, the generator ideally produces samples that are indistinguishable from real data, effectively \u0026ldquo;fooling\u0026rdquo; the discriminator.\nKey Challenges in GANs: Training Instability: GANs are notoriously hard to train because of the dynamic between the generator and discriminator. If one network becomes too strong too quickly, the other network might not improve. This can cause issues like:\nMode collapse: The generator starts producing very similar outputs for different inputs, meaning it generates only a small variety of data. Vanishing gradients: If the discriminator becomes too strong, the generator won\u0026rsquo;t receive useful feedback for improving, as the discriminator will easily classify all generated data as fake. Balancing the Generator and Discriminator:\nFor effective training, both the generator and discriminator need to improve at a similar rate. If the discriminator is too powerful, the generator will struggle to fool it, and if the generator becomes too good too quickly, the discriminator won\u0026rsquo;t have a chance to improve.\nHyperparameter Tuning:\nProper tuning of learning rates, network architectures, and other hyperparameters is crucial for successful GAN training.\nVariants of GANs: Over time, several variations of GANs have been developed to address specific problems or to improve performance in particular tasks. Some popular variants include:\nConditional GAN (cGAN):\nIn a conditional GAN, both the generator and discriminator are conditioned on some additional information. For example, you can condition the GAN on class labels to generate images of a specific class (e.g., generating images of dogs, cats, or cars).\nExample: Generate an image based on a given label, like generating a specific type of flower or animal.\nDeep Convolutional GAN (DCGAN):\nDCGANs incorporate convolutional layers, making them especially good at generating images. These networks replace fully connected layers with convolutional ones, making the generator and discriminator much more efficient at capturing spatial patterns in images.\nExample: Generating realistic-looking human faces, landscapes, or artwork.\nWasserstein GAN (WGAN):\nWGANs aim to improve the stability of GAN training by using a different loss function that measures the Wasserstein distance (also called Earth Mover’s distance) between real and generated data distributions. This often leads to better convergence and more stable training.\nExample: Stable image generation with fewer issues like mode collapse.\nCycleGAN:\nCycleGANs are used for image-to-image translation tasks where there is no paired data available. For instance, it can convert an image of a horse into an image of a zebra without needing specific horse-zebra image pairs.\nExample: Converting photos taken in summer into winter scenery or converting sketches into fully-colored images.\nStyleGAN:\nStyleGAN is known for generating high-quality images with control over various features (like facial attributes). It allows for fine control over the style and features of generated images, making it useful for tasks where precise generation is needed.\nExample: Generating ultra-realistic human faces or art with customizable features like age, hair color, or expression.\nApplications of GANs: Image Generation:\nGANs are widely used for generating realistic images, such as generating human faces, landscapes, or artwork from scratch.\nImage-to-Image Translation:\nGANs can be used to convert images from one domain to another, like transforming black-and-white images into color or converting sketches into realistic images.\nSuper-Resolution:\nGANs can enhance the resolution of images, generating high-quality images from low-resolution inputs. This is especially useful in medical imaging, satellite imaging, and photography.\nData Augmentation:\nGANs can generate new, diverse samples of data for training machine learning models, helping to balance datasets that suffer from class imbalance.\nText-to-Image Generation:\nGANs can be used to generate images based on textual descriptions, which is useful in scenarios like generating artwork or realistic images from descriptions.\nVideo and Music Generation:\nBeyond images, GANs have been used to generate videos and even music, allowing for creative content generation in these domains.\nConclusion: Generative Adversarial Networks (GANs) represent one of the most exciting advances in machine learning, particularly in unsupervised and generative modeling. By leveraging the competition between a generator and a discriminator, GANs can generate new data that closely mimics the original dataset. Despite challenges like training instability, GANs have found significant applications in image generation, data augmentation, super-resolution, and beyond. Through advanced variants like DCGAN, WGAN, and CycleGAN, the potential of GANs continues to grow, making them a central tool in generative AI.\nHere’s a tabular comparison of LeNet and AlexNet, two pioneering Convolutional Neural Network (CNN) architectures with distinct designs and purposes:\nFeature LeNet AlexNet Introduced By Yann LeCun et al. Alex Krizhevsky et al. Year 1998 2012 Primary Use Handwritten digit recognition (MNIST) Large-scale image classification (ImageNet) Dataset Size Small (MNIST dataset, 60,000 images) Large (ImageNet, 1.2 million images) Input Size 28 x 28 (grayscale images) 227 x 227 (color images) Number of Layers 5 layers (3 convolutional, 2 fully connected) 8 layers (5 convolutional, 3 fully connected) Activation Function Sigmoid ReLU (Rectified Linear Unit) Dropout No Yes (to reduce overfitting) Pooling Type Average pooling Max pooling Normalization None Local Response Normalization (LRN) Stride Small stride (1) Larger stride (2 in some layers) Computational Cost Low High Framework Custom, early implementation Implemented in CUDA for GPUs Top-1 Accuracy ~99% on MNIST ~63% on ImageNet Key Innovations Introduced basic CNN layers and structure Deeper CNN with ReLU, dropout, and GPU usage Summary LeNet: Simple, small network aimed at handwritten digit classification. AlexNet: Deeper, larger network designed for large-scale image classification, a breakthrough in computer vision. This comparison highlights the evolution of CNNs from simpler, smaller-scale applications to powerful, complex models for large-scale tasks.\n","date":"2024-10-07T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/deep-learning/module-4-to-6/","title":"Deep Learning For IA"},{"content":"Assignment Module 4 : Sementic analysis Defination Semantic analysis in Natural Language Processing (NLP) is the process of understanding the meaning and interpretation of words, phrases, and sentences in a way that mimics how humans comprehend language.\nor\nSemantic analysis is the process of finding the meaning of text. It can direct computers to understand and interpret sentences, paragraphs or whole documents by analyzing their grammatical structure and identifying the relationships between individual words of sentence in a particular context.\nGoal to capture not just the individual meanings of words, but also how they combine to form coherent and meaningful ideas in a larger context.\nThe aim of semantic analysis is to draw exact meaning or dictionary meaning from the text.\nExample The purpose of this analyzer is to check the text for ==meaningfulness, most== ==important task is to get the proper meaning of sentence.== E.g. “Govind is great” in this sentence the speaker is talking about lord Govind or about a person whose name is Govind.\nUses This analysis is used in extracting the important information from achieving human level accuracy from the computers.\nIt is used in tools like Machine Translations, chatbots, search engines and text analysis.\nSyntactic \u0026amp; Semantic Analysis: Syntactic analysis determines and checks whether the instance of the language is “well formed” and analyze its grammatical structure. Semantic analysis analyses its meaning \u0026amp; find out whether it “makes sense”. Syntactic analysis depends on the types of words, but not on their meaning. Semantic analysis in NLP Semantic analysis is the subfield of NLP \u0026amp; ML It tries to clear the context of any text and makes one realize the emotions inherent in the sentence. Understand Sementic analysis\nLexical Seantic 1. Definition: Lexical semantics is the branch of linguistics and Natural Language Processing (NLP) that deals with the meaning of words and the relationships between them. It involves understanding how words convey meaning in different contexts and how they are related to one another in terms of synonyms, antonyms, hyponyms, and more.\n2. Aim / Goal: The main aim of lexical semantics is to:\nAnalyze and understand the meaning of individual words. Establish relationships between words, like similarity, opposition, or inclusion. Help machines and algorithms in NLP to correctly interpret the meaning of words in different contexts. Enable computers to perform tasks like text summarization, sentiment analysis, and machine translation by understanding word meanings. 3. Applications: Lexical semantics has wide applications in NLP and related areas:\nMachine Translation: To accurately translate text by understanding word meanings in context. Information Retrieval: Enhances search engines by improving search result relevance based on word meaning. Text Summarization: Helps summarize long texts by understanding the key words and their meanings. Sentiment Analysis: Understands the sentiment (positive, negative, neutral) behind words used in reviews, social media, etc. Chatbots and Virtual Assistants: Helps AI understand user queries by interpreting word meanings. 4. Features: Word Relationships: Lexical semantics identifies various relationships like synonyms (similar words), antonyms (opposite words), and hyponyms (specific terms under a broader term). Context Sensitivity: The meaning of words changes based on the context in which they are used. Polysemy and Homonymy: Identifies words with multiple meanings (polysemy) and words that sound or are spelled the same but have different meanings (homonymy). Word Similarity: Determines how similar or different words are based on their meanings. 5. Advantages: Improved Understanding: It allows machines to process text more naturally, understanding word meaning and context just like humans. Better Translation: Ensures more accurate translations by capturing the nuances of word meaning. Enhanced Search: Improves search engine results by considering synonyms and related terms. Contextual Relevance: Helps in applications like text summarization and sentiment analysis by capturing the meaning of words in context. 6. Disadvantages / Limitations: Ambiguity: Some words have multiple meanings (polysemy), making it difficult for systems to always determine the correct meaning. Lack of World Knowledge: Machines struggle to understand word meanings in real-world scenarios without having external, world knowledge. Complexity in Large Texts: When dealing with large corpora of text, the variety of meanings can increase complexity. Dependency on Language Data: For effective lexical analysis, systems need large, diverse datasets. Without them, the results can be inaccurate. 7. Examples: Word Sense Disambiguation: In the sentence, \u0026ldquo;I went to the bank,\u0026rdquo; lexical semantics helps determine if \u0026ldquo;bank\u0026rdquo; refers to a financial institution or the side of a river. Hyponymy: Understanding that \u0026ldquo;rose\u0026rdquo; is a type of \u0026ldquo;flower\u0026rdquo; helps in classifying and organizing words. Synonymy in Search Engines: Searching for \u0026ldquo;buy car\u0026rdquo; also retrieves results for \u0026ldquo;purchase automobile\u0026rdquo; because lexical semantics helps relate these words. You can use this structure in your exam to give a complete and clear explanation of lexical semantics.\nHere\u0026rsquo;s a detailed breakdown of the given topics related to Lexical Semantics, corpus studies, dictionaries like WordNet and BabelNet, and word relations.\nCorpus Study: A corpus is a large and structured collection of texts, often used in linguistics for studying language. In NLP, a corpus study helps analyze real-world language usage by examining patterns, meanings, and relationships in a massive body of texts.\nKey Points: Purpose: To analyze word usage, frequency, and meaning in natural language. Application: Used in training NLP models for tasks like translation, sentiment analysis, etc. Examples of Corpora: British National Corpus (BNC), Penn Treebank, Google Books Corpus. Importance: It helps in understanding linguistic structures and provides data for language processing algorithms. Study of Language Dictionaries: a) WordNet: WordNet is a large lexical database of English where words are grouped into sets of synonyms called synsets.\nEach synset represents a distinct concept, and the words within a synset are interchangeable in some contexts.\nRelations in WordNet:\nSynonymy: Words with similar meanings. Antonymy: Words with opposite meanings. Hyponymy: Specific terms under a broader category (e.g., \u0026ldquo;dog\u0026rdquo; is a hyponym of \u0026ldquo;animal\u0026rdquo;). Meronymy: Part-whole relationships (e.g., \u0026ldquo;wheel\u0026rdquo; is a part of \u0026ldquo;car\u0026rdquo;). Usage: Widely used in NLP applications like word sense disambiguation and text classification.\nb) BabelNet: BabelNet is a multilingual lexical network that integrates information from WordNet and Wikipedia, covering multiple languages.\nIt links words and concepts across different languages, making it useful for tasks like machine translation and cross-lingual information retrieval.\nRelations in BabelNet:\nMultilingual Synsets: Words in different languages that refer to the same concept. Conceptual Relations: Similar to WordNet, but extended across languages. Usage: It is used in cross-linguistic NLP tasks, multilingual semantic analysis, and machine translation.\nRelations Among Lexemes \u0026amp; Their Senses: Lexical semantics studies the relationships between lexemes (words) and their senses (meanings). Here are the key relations:\na) Homonymy: Words that share the same spelling or pronunciation but have different and unrelated meanings.\nExample:\n\u0026ldquo;Bat\u0026rdquo; (cricket bat) vs. \u0026ldquo;Bat\u0026rdquo; (flying mammal). Types:\nHomophones: Words that sound the same but have different meanings (e.g., \u0026ldquo;bare\u0026rdquo; vs. \u0026ldquo;bear\u0026rdquo;). Homographs: Words that are spelled the same but have different meanings (e.g., \u0026ldquo;lead\u0026rdquo; as a metal vs. \u0026ldquo;lead\u0026rdquo; as to guide). b) Polysemy: A word has multiple related meanings.\nExample:\n\u0026ldquo;Head\u0026rdquo; (body part) vs. \u0026ldquo;Head\u0026rdquo; (leader of a group). Importance: Polysemy is common in natural languages, and disambiguating such meanings is crucial for NLP applications.\nc) Synonymy: Words that have similar or identical meanings.\nExample:\n\u0026ldquo;Happy\u0026rdquo; and \u0026ldquo;Joyful\u0026rdquo;. Usage: Understanding synonyms helps in improving search engines and text processing by recognizing words with similar meanings.\nd) Hyponymy: A relationship where a word represents a subtype of a broader category.\nExample:\n\u0026ldquo;Dog\u0026rdquo; is a hyponym of \u0026ldquo;Animal\u0026rdquo;, and \u0026ldquo;Rose\u0026rdquo; is a hyponym of \u0026ldquo;Flower\u0026rdquo;. Importance: Hyponymy is useful for organizing information hierarchically and understanding taxonomies in NLP.\nSemantic Ambiguity: Semantic ambiguity occurs when a word, phrase, or sentence can have multiple meanings. There are two main types of semantic ambiguity:\na) Lexical Ambiguity: Ambiguity in the meaning of a single word. Example: \u0026ldquo;Bank\u0026rdquo; can refer to a financial institution or the side of a river. b) Structural Ambiguity: Ambiguity that arises from the structure or grammar of a sentence.\nExample:\n\u0026ldquo;Visiting relatives can be annoying.\u0026rdquo; (It is unclear whether \u0026ldquo;visiting\u0026rdquo; is an action or describes the relatives). Impact on NLP: Ambiguity complicates tasks like machine translation, question answering, and semantic analysis because the system needs to understand which meaning is intended based on context.\nSummary: Corpus Study: Involves analyzing large text collections to understand language patterns. WordNet: A lexical database that groups words into synsets based on meanings and relationships. BabelNet: A multilingual lexical network linking words across languages. Relations: Homonymy: Same spelling or pronunciation, different meanings. Polysemy: Multiple related meanings for a word. Synonymy: Words with similar meanings. Hyponymy: Specific words under broader categories. Semantic Ambiguity: Ambiguity in word or sentence meaning that complicates text understanding. This detailed understanding of these concepts is essential for tackling tasks in NLP, such as machine translation, word sense disambiguation, and semantic analysis.\nWord Sense Disambiguation (WSD) is the process of determining which meaning (or sense) of a word is intended in a given context. In natural language processing (NLP), many words have multiple meanings (polysemy), so it is crucial to accurately identify the correct sense of the word to understand the overall meaning of the text.\n1. Word Sense Disambiguation (WSD): Definition: WSD is the task of identifying which sense of a word is used in a sentence, especially when the word has multiple meanings. Example: The word \u0026ldquo;bank\u0026rdquo; could mean either a financial institution or the side of a river. In WSD, the goal is to determine which meaning is intended based on the surrounding context. 2. Knowledge-based Approach (Lesk\u0026rsquo;s Algorithm): Knowledge-based approaches use pre-existing lexical resources (like dictionaries or thesauruses) to determine the meaning of words.\nLesk\u0026rsquo;s Algorithm: Lesk\u0026rsquo;s Algorithm is a knowledge-based WSD method that disambiguates words by comparing the dictionary definitions (or glosses) of each possible sense of a word to the context in which the word appears.\nWorking:\nFor each sense of an ambiguous word, Lesk\u0026rsquo;s algorithm calculates how much overlap there is between the dictionary definition of that sense and the words in the surrounding context. The sense with the highest overlap is selected as the most likely meaning. Example:\nIn the sentence, \u0026ldquo;I went to the bank to fish,\u0026rdquo; Lesk’s algorithm would check the glosses of the word \u0026ldquo;bank\u0026rdquo; (both financial institution and riverbank) and find that \u0026ldquo;riverbank\u0026rdquo; overlaps with the word \u0026ldquo;fish,\u0026rdquo; thus selecting the riverbank meaning. Limitation:\nLesk’s algorithm heavily depends on the quality and detail of the dictionary definitions, and it may not work well if glosses are short or vague. 3. Supervised Approaches: Supervised methods for WSD rely on labeled datasets where each word is manually tagged with the correct sense. These methods learn to disambiguate words based on training data and predict the correct sense for new instances.\na) Naïve Bayes Classifier: Naïve Bayes is a probabilistic classifier based on Bayes\u0026rsquo; theorem. It assumes that the features (context words) are independent of each other.\nHow it works:\nFor each possible sense of the ambiguous word, the classifier computes the probability that the given context fits that sense using previously learned probabilities from training data. The sense with the highest probability is selected. Example: Given a word like \u0026ldquo;bass\u0026rdquo; in a sentence, Naïve Bayes would calculate the probability of \u0026ldquo;bass\u0026rdquo; meaning \u0026ldquo;fish\u0026rdquo; or \u0026ldquo;musical instrument\u0026rdquo; based on the nearby words (e.g., \u0026ldquo;lake\u0026rdquo; vs. \u0026ldquo;guitar\u0026rdquo;).\nb) Decision List Algorithm: A Decision List algorithm learns a set of if-then rules from training data. These rules rank different features (like surrounding words) by their ability to disambiguate a word.\nHow it works:\nDuring training, the algorithm creates a ranked list of features (e.g., specific words or part-of-speech tags in the context). When testing, the highest-ranked rule that applies is used to assign the word’s sense. Example: The rule \u0026ldquo;If \u0026lsquo;fish\u0026rsquo; appears near \u0026lsquo;bass\u0026rsquo;, then choose the sense \u0026lsquo;fish\u0026rsquo;\u0026rdquo; would take precedence over other possible senses of \u0026ldquo;bass.\u0026rdquo;\n4. Semi-supervised Approach (Yarowsky\u0026rsquo;s Algorithm): Semi-supervised methods use both labeled and unlabeled data. Yarowsky\u0026rsquo;s algorithm is a classic semi-supervised approach to WSD.\nYarowsky\u0026rsquo;s Algorithm: It relies on two key principles:\nOne Sense Per Collocation: A word tends to have a consistent meaning in similar contexts. One Sense Per Discourse: A word usually keeps the same sense throughout a document. How it works:\nInitial Labeled Data: Yarowsky starts with a small set of labeled examples (where the correct senses are already known). Bootstrapping: It uses these labeled examples to classify unlabeled examples based on their similarity to the labeled ones. As more data is labeled, the system iteratively improves its model without needing much human intervention. Example: If the algorithm sees \u0026ldquo;bass\u0026rdquo; near \u0026ldquo;lake\u0026rdquo; labeled as \u0026ldquo;fish,\u0026rdquo; it will begin labeling similar contexts as \u0026ldquo;fish\u0026rdquo; without needing more manual labels.\n5. Unsupervised Approach (HyperLex): Unsupervised methods do not require labeled training data. They use clustering or similarity measures to infer word senses from the data itself.\nHyperLex Algorithm: HyperLex is an unsupervised WSD approach that uses distributional similarity between words. It clusters word occurrences based on their contexts and then assigns word senses based on the clusters.\nHow it works:\nWords that appear in similar contexts are assumed to have similar meanings. HyperLex creates clusters of word senses by analyzing the distributional properties of words in large corpora. It uses vector-space models to represent words and their contexts and applies clustering algorithms to group different usages into distinct senses. Example: HyperLex might analyze the occurrences of \u0026ldquo;bass\u0026rdquo; and cluster it into \u0026ldquo;fish-related\u0026rdquo; and \u0026ldquo;music-related\u0026rdquo; groups based on context words like \u0026ldquo;lake\u0026rdquo; and \u0026ldquo;guitar.\u0026rdquo;\nLimitation:\nUnsupervised methods can struggle to identify highly nuanced word senses because they rely purely on statistical patterns without external knowledge. Summary of Approaches: Approach Type Algorithm Key Features Knowledge-based Dictionary-driven Lesk\u0026rsquo;s Algorithm Uses gloss overlap to select word senses. Supervised Labeled Data Naïve Bayes, Decision List Uses labeled training data, probabilistic models, and rule-based approaches. Semi-supervised Labeled + Unlabeled Yarowsky\u0026rsquo;s Algorithm Bootstraps from a small labeled set using context consistency. Unsupervised No Labeled Data HyperLex Clusters word usages based on context distribution. Conclusion: Word Sense Disambiguation is crucial for many NLP tasks like machine translation, information retrieval, and text understanding. Different approaches (knowledge-based, supervised, semi-supervised, and unsupervised) use varying strategies to resolve word meaning ambiguity. Each method has its own strengths and limitations, making them suitable for different types of tasks and data availability.\nDictionary-Based Approach for Word Sense Disambiguation (WSD): A dictionary-based approach to Word Sense Disambiguation (WSD) leverages predefined lexical resources (like dictionaries, thesauruses, or semantic networks) to resolve the ambiguity of word meanings. It identifies the correct sense of a word based on word definitions (glosses) and the context in which the word is used.\nUnlike supervised methods, dictionary-based approaches do not require large amounts of labeled data. Instead, they rely on external lexical resources such as WordNet or other dictionaries to identify word meanings.\nKey Concepts: Dictionary/Thesaurus as Knowledge Source:\nDictionary: Provides word meanings (glosses), synonyms, antonyms, and usage examples. Semantic Network: Resources like WordNet offer a more structured representation of words, linking them based on semantic relationships (synonymy, hyponymy, etc.). Gloss: The definition or explanation of a word found in a dictionary. In dictionary-based approaches, the gloss is compared with the words in the sentence to determine which sense of the word fits best.\nTypes of Dictionary-Based Approaches: 1. Lesk’s Algorithm: The Lesk algorithm is one of the most famous dictionary-based methods for WSD. It disambiguates words by comparing the dictionary definitions (glosses) of each potential sense of a word with the surrounding words in the context.\nHow Lesk’s Algorithm Works: Input: An ambiguous word and its surrounding context. Step 1: For each sense of the word, retrieve the corresponding gloss from a dictionary (e.g., WordNet). Step 2: Compare the glosses of each sense with the words in the sentence. Step 3: Count the overlapping words (common words) between the gloss and the context. Step 4: The sense with the highest overlap is selected as the correct one. Example: Sentence: \u0026ldquo;I went to the bank to fish.\u0026rdquo;\nSenses of bank (from a dictionary):\nFinancial institution: \u0026ldquo;An establishment that provides financial services.\u0026rdquo; Riverbank: \u0026ldquo;The land alongside a river.\u0026rdquo; Context words: \u0026ldquo;I\u0026rdquo;, \u0026ldquo;went\u0026rdquo;, \u0026ldquo;fish\u0026rdquo;. Overlap check: Financial institution gloss: No overlap. Riverbank gloss: Overlap with the word \u0026ldquo;fish\u0026rdquo; (associated with rivers). In this case, the riverbank sense would be selected due to the overlap with \u0026ldquo;fish.\u0026rdquo;\n4. Graph-Based Approach (WordNet): Using WordNet or similar lexical resources, dictionary-based WSD methods can create a graph of word senses and their relationships (e.g., synonymy, hyponymy). The graph is then analyzed to find the best sense based on connectedness to other senses or words in the context.\nHow it Works: WordNet provides a network of related words and senses. The target word is mapped to its possible senses in the WordNet graph. Context words are also mapped to their senses in WordNet. The algorithm selects the sense of the target word that is most closely related to the senses of the surrounding words in the context. Example: Sentence: \u0026ldquo;The apple fell from the tree.\u0026rdquo;\nWordNet senses: Apple (fruit). Apple (company). By analyzing the relationship between \u0026ldquo;tree\u0026rdquo; and \u0026ldquo;apple\u0026rdquo; in the WordNet graph, the algorithm identifies \u0026ldquo;apple\u0026rdquo; as fruit, as it is closely related to \u0026ldquo;tree\u0026rdquo; (through a hypernymy relation: \u0026ldquo;tree\u0026rdquo; → \u0026ldquo;plant\u0026rdquo; → \u0026ldquo;fruit\u0026rdquo;).\nAdvantages of Dictionary-Based Approaches: No Training Data Required: These methods do not require labeled corpora for training, making them highly scalable. Utilization of External Knowledge: Leverage rich linguistic resources like dictionaries, WordNet, and other semantic networks. Simple and Fast: Easy to implement, and works well with small-scale or resource-limited environments. Disadvantages of Dictionary-Based Approaches: Dependence on Gloss Quality: The accuracy of the method depends heavily on the quality and comprehensiveness of the glosses in the dictionary. Gloss Overlap Limitations: Words with similar meanings but no exact overlap in the glosses may be poorly disambiguated. Scalability Issues: In large corpora with complex sentence structures, the method may struggle to maintain accuracy. Ambiguity in Glosses: Some glosses can be too vague, and different dictionaries may define the same sense in different ways. Example Applications: Machine Translation: WSD ensures that the correct word sense is translated into the target language. Information Retrieval: Enhances search engines by correctly interpreting ambiguous words in search queries (e.g., \u0026ldquo;bank\u0026rdquo; financial institution vs. \u0026ldquo;bank\u0026rdquo; riverbank). Text Summarization: Ensures that ambiguous words are correctly interpreted when summarizing text. Conclusion: Dictionary-based approaches for WSD, such as Lesk’s Algorithm and its variations, are effective methods that use pre-existing lexical knowledge to resolve word ambiguities. These methods are easy to implement and do not require large amounts of labeled data, making them ideal for certain NLP tasks where annotated datasets are unavailable. However, their performance depends on the richness of the dictionary or lexical resource used and may struggle with complex language scenarios.\nmodule 5 Discourse in NLP Discourse in NLP is nothing but coherent groups of sentences. When we are dealing with Natural Language Processing, the provided language consists of structured, collective, and consistent groups of sentences, which are termed discourse in NLP.\nThe relationship between words makes the training of the NLP model quite easy and more predictable than the actual results.\nusage: Discourse Analysis is extracting the meaning out of the corpus or text. Discourse Analysis is very important in Natural language Processing and helps train the NLP model better.\nReference Resolution: Identifying what or who a word (like a pronoun) refers to in the text. Example: \u0026ldquo;John went to the store. He bought apples.\u0026rdquo; (\u0026ldquo;He\u0026rdquo; refers to John). Reference Phenomena: Anaphora: Refers back to an earlier entity (e.g., \u0026ldquo;he\u0026rdquo;, \u0026ldquo;she\u0026rdquo;). Cataphora: Refers to something mentioned later in the text. Syntactic \u0026amp; Semantic Constraints on Coherence: Syntactic Constraints: Structure of sentences must be clear and consistent for proper reference (e.g., \u0026ldquo;He\u0026rdquo; should refer to an understandable noun). Semantic Constraints: Words must be meaningfully connected across sentences. Anaphora Resolution: The task of identifying the correct antecedent (who/what a pronoun refers to). Algorithms for Anaphora Resolution: Hobbs’ Algorithm: Uses syntactic structure (parse trees) to resolve pronouns. Centering Algorithm: Focuses on coherence between sentences by tracking discourse entities. Coreference Coreference refers to the linguistic phenomenon where two or more expressions in a text refer to the same entity.\nThe primary goal of coreference resolution is to establish the links between these expressions, allowing for a coherent understanding of the text.\n","date":"2024-10-07T00:00:00Z","permalink":"http://localhost:1313/post/ia-2-exam/nlp/","title":"NLP for IA 2 Exam"},{"content":"\n1. Summarize Bloom’s filter with example and its application 2. Explain DGIM algorithm. 3. Explain cure algorithm (2) 4.What is Recommender System? Explain Types of recommender system. 5. Distance measure (2) 6. Page Rank Algorithm (2) 7. Explain Issues in Data stream query processing 8. Explain Collaborative filtering system. How is it different from content based system Module 5 The stream data model The stream data model represents continuous, real-time data flows\nContinuous Data Flow: Data arrives in a continuous stream rather than in fixed sets. Real-time Processing: Data is processed immediately as it arrives. Unbounded Data: The data stream may not have a known end, making it different from traditional static data sets. Time Sensitivity: Data processing and analysis often depend on the order and timestamp of events. Incremental Processing: Data is processed in small increments, as opposed to batch processing. Windowing: Data is analyzed over specific time windows (e.g., last 10 seconds of data). High Throughput: Stream models handle a large volume of data in real-time. Low Latency: Quick response times are required for immediate processing. Stateful Operations: The system may maintain some state (memory of past data) to compute future events. Use Cases: Suitable for applications like live analytics, IoT, financial transactions, and sensor data. Advantages of Stream Data Model: Real-time Insights: Enables instant analysis and decision-making as data is received. Low Latency: Immediate data processing ensures fast responses to events. Scalability: Designed to handle high-throughput applications like IoT, social media feeds, etc. Continuous Processing: Efficient for monitoring and managing data without delays. Event-Driven: Well-suited for applications that need to react to real-time changes (e.g., fraud detection, stock market analysis). Resource Efficiency: In some cases, it reduces resource usage by avoiding the need to store large amounts of data for batch processing. Disadvantages of Stream Data Model: Complex Development: Implementing a real-time data pipeline is often more complex than traditional batch systems. Fault Tolerance: Ensuring system reliability and recovering from errors in a real-time system can be challenging. High Cost: Real-time processing may require significant infrastructure and computational resources. Data Loss Risk: If there is a system failure, there’s a risk of losing incoming data since it is not stored persistently. Debugging Challenges: Debugging and testing real-time applications can be difficult due to the continuous flow of data. Problems and Limitations: Data Ordering: Maintaining the correct sequence of events in a high-throughput environment can be difficult. State Management: Managing the state for processing, especially in distributed systems, can be complex. Latency vs Accuracy: Real-time processing often sacrifices accuracy for speed, which may not work for all applications. Windowing Limitations: Some data might fall outside the time windows used for analysis, leading to incomplete results. Data Overload: Handling continuous streams at scale can overwhelm systems if not carefully managed. Inconsistent Data Quality: Stream data might have inconsistent quality, missing values, or require cleansing.s 2. What is Stream Computing ??? Stream computing (or stream processing) refers to the real-time processing of continuous data streams as they are produced.\nUnlike traditional batch processing, where data is collected, stored, and then processed later, stream computing handles data in motion—processing it immediately as it arrives.\nKey Features of Stream Computing: Real-Time Data Processing: Processes data as soon as it is generated, without delays.\nContinuous Data Flow: Data comes in continuously from sources like sensors, social media, financial transactions, or IoT devices.\nLow Latency: Stream computing aims to provide near-instant insights with minimal delay between data generation and action.\nScalability: Can handle high-velocity, high-volume data by scaling horizontally (across multiple servers).\nStateful and Stateless Operations:\nStateless: Each event is processed independently (e.g., filtering out specific types of data). Stateful: Keeps track of the state across events (e.g., counting occurrences over time). Examples of Stream Computing Use Cases: Financial Services IoT (Internet of Things) Social Media Network Monitoring Healthcare Common Stream Processing Frameworks: Apache Kafka: Distributed event streaming platform for building real-time data pipelines. Apache Flink: Stream processing framework for distributed data streams. Apache Storm: Real-time computation system that processes unbounded streams of data. Spark Streaming: Extension of Apache Spark for processing real-time data streams. Benefits of Stream Computing: Immediate Insights: Enables real-time decision-making and actions based on incoming data. Efficient Resource Utilization: Continuous processing reduces the need to store and process massive batches of data later. Scalable: Can handle large volumes of fast-moving data by distributing the workload across clusters. Flexibility: Supports a wide variety of real-time applications, from real-time dashboards to automated triggers and actions. 3. Page Rank [!Defination] PageRank is an algorithm that assigns a numerical value to web pages, based on the quantity and quality of links pointing to them, to measure their importance and influence within the web.\nPageRank Algorithm is a method developed by Larry Page and Sergey Brin, the founders of Google, to rank web pages in search engine results.\nIt works by evaluating the quality and quantity of links pointing to a page and assigning it a \u0026ldquo;rank\u0026rdquo; or importance score.\n1. Webpages as Nodes Imagine the entire web as a graph, where web pages are nodes, and hyperlinks between pages are edges connecting them. Each page in this graph points to other pages via links and receives links from others. 2. The Importance of Links (Votes) A link to a page is considered a vote of confidence or importance for that page. Not all votes (links) are equal; the importance of a page that gives the vote matters. 3. Recursive Nature of PageRank The PageRank of a page is determined by the PageRank of other pages linking to it. Pages that are linked from many high-ranked pages will receive a higher score. 4. Random Surfer Model PageRank is based on the assumption of a \u0026ldquo;random surfer\u0026rdquo; who starts on a random page and randomly follows links. With each step, the surfer either clicks a link to another page or jumps to a random page with some probability. 5. **Damping Factor The algorithm introduces a damping factor (usually around 0.85), representing the probability that a user follows a link. With a probability of (1 - damping factor), the user jumps to a random page instead of following a link. This ensures the model doesn’t get stuck in loops or dead-end pages. 6. Rank Calculation Formula For any given page (P), its PageRank is calculated as: [!formula] $PR(P) = \\frac{1 - d}{N} + d \\left( \\sum_{i=1}^{n} \\frac{PR(P_i)}{L(P_i)} \\right)$\nWhere:\nd is the damping factor (typically 0.85), N is the total number of pages, PR(Pi) is the PageRank of the pages linking to page P, L(Pi) is the number of outbound links from page Pi. 7. Initial PageRank Every page is assigned an initial equal rank before calculations begin, usually ( 1/N ) where N is the total number of pages. The PageRank values are updated iteratively until they converge (i.e., stop changing significantly). 8. Handling Dead Ends (Sink Pages) Some pages might not link to any other pages, creating dead ends. The damping factor helps to handle these situations, as it prevents such pages from trapping the random surfer indefinitely. 9. Iterative Process The calculation of PageRank is performed in an iterative process where the ranks of all pages are updated multiple times. The process repeats until the PageRank values of all pages stabilize. 10. Relevance of High PageRank A high PageRank means a page is linked to by many important pages, making it more authoritative or popular. However, PageRank is just one of many factors Google uses to rank pages in search results. PageRank provides a scalable way to evaluate the importance of millions (or billions) of web pages, helping search engines deliver more relevant results.\nImportance of page rank measure page authority Improves search relevace link popularity factor reduce spam Democratic nature Encourages quality content seo foundation enhances web navigation foundation for modern search algorithm 3. Structure of web (bowtie) The structure of the web can be understood as a vast network of interconnected documents (web pages), where each page is linked to others through hyperlinks.\n1. Nodes (Web Pages) Each web page is represented as a node in the web\u0026rsquo;s graph-like structure. Pages can contain text, images, videos, and other media, along with links to other pages. 2. Edges (Hyperlinks) Hyperlinks between pages act as edges connecting the nodes. A hyperlink from one page to another creates a directed connection, indicating a relationship or reference. 3. Directed Graph The web forms a directed graph, where links have direction (from one page to another). Not all links are reciprocal, meaning one page may link to another without receiving a link back. 4. Hub-and-Spoke Model Popular or highly authoritative pages act as hubs, receiving many inbound links. These hubs often link to spoke pages, which are smaller, more specific resources or less popular pages. 5. Clusters or Communities Pages are often grouped into clusters or communities based on shared topics or common links. Pages within a cluster tend to have more interlinks with each other than with pages outside the cluster. 6. Dead Ends and Sink Pages Dead ends occur when a page has no outbound links, leaving no way for users to navigate to other pages. Sink pages have inbound links but no outbound links, potentially trapping users. 7. Small-World Property The web exhibits the small-world phenomenon, where most pages are separated by only a few links, making it relatively easy to navigate between distant pages. 8. Hierarchical Structure Web pages are often organized hierarchically, with homepage or main pages at the top, linking to various subpages that provide more specific information. 9. Dynamic and Static Content The web includes static content (fixed HTML pages) and dynamic content (pages generated based on user interaction or database queries). 10. Crawling and Indexing Search engines use web crawlers to explore the web\u0026rsquo;s structure by following links from page to page, gathering and indexing content for retrieval in search results. 1. Bow-Tie Structure of the Web The web can be broken down into a bow-tie shape with distinct regions based on how pages are connected to each other via hyperlinks. 2. Strongly Connected Component (SCC) SCC is the central core of the web, consisting of pages that are strongly connected to each other. Any page in the SCC can be reached from any other page within the SCC, and vice versa. This component contains the most tightly interlinked and authoritative pages, often highly ranked websites. 3. IN Component Pages in the IN component are those that can link to the SCC, but pages in the SCC cannot link back to them. These are pages that can access the core but are not reachable from the SCC, often newly created or less authoritative pages. 4. OUT Component Pages in the OUT component are those that can be reached from the SCC but do not link back to the SCC. These are often result pages or pages that provide specific resources but aren\u0026rsquo;t heavily linked to by other pages. 5. Tendrils Tendrils are pages that are not part of the SCC, IN, or OUT components. They link to either the IN or OUT components but not to both, forming pathways that connect these regions but never reach the central SCC. Tendrils can be thought of as isolated paths or dead-end areas of the web, leading to content that is not as well connected. 6. Disconnected Components (Islands) Some pages are completely isolated, meaning they neither connect to the SCC nor to the IN or OUT components. These are often referred to as islands in the web\u0026rsquo;s structure, completely separate from the bow-tie. 7. Tubes Tubes are special pathways that directly connect IN to OUT without going through the SCC. These serve as direct routes between peripheral parts of the web. ","date":"2024-10-02T00:00:00Z","permalink":"http://localhost:1313/post/ia-2-exam/bda-assignment/","title":"BDA Assignment"},{"content":"1. code to print simple rectangle public class patterns { public static void main(String[] args) { int n = 4; // for rows int m = 5; //for columns for (int i = 1 ; i \u0026lt;= n ; i++){ // outerloop to print rows for( int j = 1; j \u0026lt;= m; j++){ // inner loop to print columns System.out.print(\u0026#34;*\u0026#34;); // print *s } System.out.println(); // move to next line after n = 4 row } } } 2. hollow rectangle public class hollowpatterns { public static void main(String[] args) { int n = 4; // n = 4 rows int m = 5; // m = 5 columns for(int i = 1 ; i \u0026lt;=n ; i++){ // loop for rows for (int j = 1 ; j \u0026lt;=m ; j++){ // loop for cloumns if (i == 1 || j == 1|| i == n||j ==m){ // fi condition for 1st row and 1st column System.out.print(\u0026#34;*\u0026#34;); }else{ System.out.print(\u0026#34; \u0026#34;); } } System.out.println(); } } } 3. half pyramid public class pyramid { public static void main(String[] args) { int n = 5; // n = 5 rows for ( int i = 1; i \u0026lt;= n; i++){ for ( int j = 1 ; j \u0026lt;= i ; j++){ System.out.print(\u0026#34;* \u0026#34;); } System.out.println(); } } } 4. invert half pyramid method 1\npublic class inverthalfpyramid { public static void main(String[] args) { int n = 5; // n = 5 rows for ( int i = n; i \u0026lt;= n; i--){ for ( int j = 1 ; j \u0026lt;= i ; j++){ System.out.print(\u0026#34;* \u0026#34;); } System.out.println(); } } } method 2\npublic class inverthalfpyramid { public static void main(String[] args) { int n = 5; // n = 5 rows for ( int i = 1 ; i \u0026lt;= n; i++){ for ( int j = 1 ; j \u0026lt;= n-1 ; j++){ System.out.print(\u0026#34;* \u0026#34;); } System.out.println(); } } } 5. number pattern problem 1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 public class numberpattern { public static void main(String[] args) { int n = 5; for(int i = 1 ; i \u0026lt;= n; i++ ){ for(int j = 1 ; j \u0026lt;= i ; j++){ System.out.print(j+ \u0026#34; \u0026#34;); } System.out.println(); } } } 6. invert pattern 1 2 3 4 5 1 2 3 4 1 2 3 1 2 1 public class invertednumberpattern { public static void main(String[] args) { int n = 5; for (int i = 1 ; i \u0026lt;= n ; i++){ for (int j =1; j \u0026lt;= n-i+1 ;j++){ System.out.print(j+\u0026#34; \u0026#34;); } System.out.println(); } } } 7. Flloids triangle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class flloidstriangle { public static void main(String[] args) { int n = 5; int number = 1; for (int i = 1 ; i \u0026lt;= n ; i++){ for (int j =1; j \u0026lt;= i ;j++){ System.out.print(number+\u0026#34; \u0026#34;); number++; } System.out.println(); } } } 8. binary triangle 1 0 1 1 0 1 0 1 0 1 1 0 1 0 1 public class binarytriangle { public static void main(String[] args) { int n = 5; for (int i = 1 ; i \u0026lt;= n ; i++){ for (int j =1; j \u0026lt;= i ;j++){ int sum = i+j; if(sum%2 == 0){ System.out.print(\u0026#34; \u0026#34;+ \u0026#34;1\u0026#34;); }else{ System.out.print(\u0026#34; \u0026#34; + \u0026#34;0\u0026#34;); } } System.out.println(); } } } 9. butterfly pattern * * ** ** ****** ****** ** ** * * public class butterfly { public static void main(String[] args) { int n = 3; for (int i = 1;i\u0026lt;=n;i++){ for( int j = 1 ; j \u0026lt;=i;j++){ System.out.print(\u0026#34;*\u0026#34;); } int spaces = 2 *(n-i); for(int j=1; j \u0026lt;=spaces;j++){ System.out.print(\u0026#34; \u0026#34;); } for(int j = 1 ;j\u0026lt;=i;j++){ System.out.print(\u0026#34;*\u0026#34;); } System.out.println(); } for (int i = n;i\u0026gt;=1;i--){ for( int j = 1 ; j \u0026lt;=i;j++){ System.out.print(\u0026#34;*\u0026#34;); } int spaces = 2 *(n-i); for(int j=1; j \u0026lt;=spaces;j++){ System.out.print(\u0026#34; \u0026#34;); } for(int j = 1 ;j\u0026lt;=i;j++){ System.out.print(\u0026#34;*\u0026#34;); } System.out.println(); } } } 10. Solid rhombus * * * * * * * * * * * * * * * * * * * * * * * * * public class rhombus { public static void main(String[] args) { int n = 5; for ( int i = 1 ; i \u0026lt;= n ; i++){ for ( int j = 1; j \u0026lt;=n -i; j++ ){ System.out.print(\u0026#34; \u0026#34;); } for( int j = 1;j\u0026lt;=5 ; j++){ System.out.print(\u0026#34; *\u0026#34;); } System.out.println(); } } } 11. star pyramid * * * * * * * * * * * * * * * public class pyramid { public static void main(String[] args) { int n = 5; for ( int i = 1 ; i \u0026lt;= n ; i++){ for ( int j = 1; j \u0026lt;=n -i; j++ ){ System.out.print(\u0026#34; \u0026#34;); } for( int j = 1;j\u0026lt;=i ; j++){ System.out.print(\u0026#34; *\u0026#34;); } System.out.println(); } } } 12. palindromic pattern 1 212 32123 4321234 543212345 public class palindromicpattern { public static void main(String[] args) { int n = 5; for (int i=1; i\u0026lt;=n;i++){ for (int j =1;j\u0026lt;=n-i;j++){ System.out.print(\u0026#34; \u0026#34;); } for ( int j=i;j\u0026gt;=1;j--){ System.out.print(j); } for(int j=2;j\u0026lt;=i;j++ ){ System.out.print(j); } System.out.println(); } } } 13. Diamond pattern * *** ***** ***** *** * public class diamond{ public static void main(String[] args) { int n = 3; for(int i = 1; i \u0026lt;=n;i++){ for (int j = 1 ; j\u0026lt;=n-i;j++){ System.out.print(\u0026#34; \u0026#34;); } for (int j = 1; j\u0026lt;=2*i-1;j++){ System.out.print(\u0026#34;*\u0026#34;); } System.out.println(); } for(int i = n; i \u0026gt;=1;i--){ for (int j = 1 ; j\u0026lt;=n-i;j++){ System.out.print(\u0026#34; \u0026#34;); } for (int j = 1; j\u0026lt;=2*i-1;j++){ System.out.print(\u0026#34;*\u0026#34;); } System.out.println(); } } } 14. code to print pascal triangle 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 public class PascalTriangleSimple { public static void main(String[] args) { int numRows = 5; // Number of rows to print for (int i = 0; i \u0026lt; numRows; i++) { int number = 1; // First number in each row is always 1 // Print spaces to center the triangle for (int j = 0; j \u0026lt; numRows - i; j++) { System.out.print(\u0026#34; \u0026#34;); } // Print each number in the row for (int j = 0; j \u0026lt;= i; j++) { System.out.print(number + \u0026#34; \u0026#34;); number = number * (i - j) / (j + 1); // Update the number using Pascal\u0026#39;s rule } System.out.println(); // Move to the next line after each row } } } ","date":"2024-10-02T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/patterns-in-java/","title":"Patterns in java (placements)"},{"content":"latest to run container sudo docker run --privileged -it -v /var/lib/docker/volumes/fusiondata/_data:/home/fusion debian /bin/bash Pull premade docker image docker pull yashuop/fusionguibuildcontainer:latest Run container sudo docker run --privileged -it -v /var/lib/docker/volumes/fusiondata/_data:/home/fusion fusionbuild1 /bin/bash i want to make a custom linux distribution based on debain bookworm with live build tool please help me with that distribution usecase : for ai, ml /ds engineers based on : debain 12 bookworm installer : Calamares\ndesktop environment : no desktop environment i want i3 window manager preinstalled features : usb persisteance when boot through usb (that is memory must not loose after rebooting it) every where it should replace debain as Fusion flux as an Distribution name iso : 64bit amd64 iso\nprerequisites To create a custom Linux distribution using the Live Build tool (commonly used for Debian-based distributions like Debian, Ubuntu, and their derivatives), you need to install several prerequisite packages. Here\u0026rsquo;s a list of essential packages and a basic step-by-step guide for setting up the environment.\nPrerequisites for Using live-build: Debian/Ubuntu-based System: Ensure you are working on a Debian or Ubuntu system, as live-build is designed for these distributions.\nInstall Required Packages:\nOpen a terminal and run the following command to install the required tools:\nsudo apt-get update sudo apt-get install live-build debootstrap curl wget xorriso syslinux squashfs-tools genisoimage live-build: The core tool to create live images. debootstrap: Helps in creating a minimal base system (required for bootstrapping a Debian system). curl/wget: For downloading additional files or packages during the build process. xorriso: A command-line ISO 9660 editor and CD image creation tool, needed for making ISO files. syslinux: For booting the system; used to configure boot loaders like ISOLINUX. squashfs-tools: Tools to create a compressed filesystem, which is commonly used in live images. genisoimage: Tool for creating the actual ISO image. Optional Packages: Depending on the complexity of the custom distribution, you may need additional packages:\napt-cacher-ng: If you plan to cache packages during repeated builds.\nsudo apt-get install apt-cacher-ng git: To manage repositories or pull specific configuration files.\nsudo apt-get install git locales: To manage system locales if you want to customize them.\nsudo apt-get install locales schroot: To manage chroots if you are building in an isolated environment.\nsudo apt-get install schroot Configure Live Build Environment:\nAfter the necessary packages are installed, you can configure the build environment. For example:\nlb config This command sets up the default configuration for live-build. You can further customize it by adding options, such as specifying the distribution (Debian or Ubuntu version) or desktop environment.\nBuild the Image:\nOnce the environment is configured, you can start building the ISO by running:\nsudo lb build This process will generate a live ISO image that you can customize further by editing configuration files or adding packages as per your requirements.\nKey Files and Directories: config/package-lists/: You can place custom package lists here to include specific software in the build. config/includes.chroot/: You can add custom files or scripts to be included in the final system. By ensuring these prerequisites are installed and following the steps above, you\u0026rsquo;ll be able to create a custom Linux distribution using live-build.\n0th Config file #!/bin/sh set -e lb config noauto \\ --distribution bookworm \\ --architecture amd64 \\ --debian-installer false \\ --debian-installer-gui false \\ --bootappend-live \u0026#34;boot=live components persistence\u0026#34; \\ --linux-flavours amd64 \\ --iso-publisher \u0026#34;Fusion Flux\u0026#34; \\ --iso-volume \u0026#34;Fusion Flux Live\u0026#34; \\ --iso-application \u0026#34;Fusion Flux AI/ML Distribution\u0026#34; \\ --apt-indices false \\ --firmware-binary true \\ --firmware-chroot true \\ --archive-areas \u0026#34;main contrib non-free non-free-firmware\u0026#34; \\ \u0026#34;${@}\u0026#34; 1st build (basic) Creating a custom Linux distribution based on Debian, with the ability to boot from a USB (using tools like Rufus or Ventoy) and install directly from the BIOS like other popular distributions (such as Kali), involves several steps and key configurations. Here’s a breakdown of the major components and steps you\u0026rsquo;ll need to follow:\n1. Choose a Base (Debian) Version Select the correct Debian base version (e.g., Debian 11 \u0026ldquo;Bullseye\u0026rdquo; or 12 \u0026ldquo;Bookworm\u0026rdquo;). Make sure to use the amd64 architecture as you mentioned. 2. Debian Live Build System Use Debian live-build tools, which are designed for creating live systems and installing them. Install the live-build tool to generate the ISO: sudo apt-get install live-build Live-build allows customization of the system, including packages, scripts, and configurations, which you need for the live boot and installation. 3. Configure the Live Boot The live boot system is essential for creating an image that can be tested in live mode (before installation). Steps: Create a working directory: mkdir custom-linux cd custom-linux Start the live build process with a minimal Debian system template: lb config --architecture amd64 Customize configurations: Set up live boot settings (optional configurations can be added in the auto/config file): lb config \\ --distribution bullseye \\ --architecture amd64 \\ --debian-installer true \\ --bootappend-live \u0026#34;boot=live components\u0026#34; \\ --iso-publisher \u0026#34;YourLinux v1.0\u0026#34; \\ --iso-volume \u0026#34;YourLinux\u0026#34; \\ --iso-application \u0026#34;YourLinux Live Installer\u0026#34; Generate the live image: sudo lb build This will create an .iso file, which you can use with Rufus or Ventoy to boot into a live session. 4. Include a Debian Installer To install the OS from the BIOS directly (as is done with Kali Linux), you need to enable the Debian installer. You can enable the Debian installer using the --debian-installer true option in live-build as shown above. This ensures that your custom OS includes a full installation option alongside the live boot. 5. Custom Packages and Pre-installed Software Use the packages.chroot file to specify the software you want installed in the live system (and also installed post-install). Example: Add specific software packages to the live system like this: echo \u0026#34;kali-linux-default\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot echo \u0026#34;gnome-core\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot echo \u0026#34;curl\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot 6. Custom Branding (Optional) Add custom logos, backgrounds, and boot menus. Modify the boot menu using GRUB configuration in /config/bootloaders/grub or the grub-pc package for BIOS compatibility. 7. BIOS Compatibility Make sure your ISO is hybrid (so it works for both BIOS and UEFI systems). You can achieve this by ensuring your lb config command uses the --debian-installer true option. Hybrid ISO configurations will make the boot media compatible across different systems, including BIOS and UEFI boot modes. Verify the ISO can be booted using Rufus and Ventoy in both MBR and GPT partition schemes. 8. Persistent Storage (Optional) If you want the live boot environment to support persistence (i.e., save changes to the USB), enable persistence via custom configurations: Modify the boot command line (in syslinux or grub): boot=live components persistence The persistence file or partition needs to be named properly (e.g., persistence.conf in the root of the USB drive). 9. Testing and Debugging Test your custom live image on virtual machines like VirtualBox or QEMU. Boot the ISO with tools like Rufus, Ventoy, or BalenaEtcher to verify it works both in live mode and installation mode. Ensure that the system installs correctly and that custom packages/software are properly configured post-installation. 10. Optional Tools for Simplified Building Refracta Tools: If live-build feels complex, you can use Refracta tools. They simplify the process of creating a live system and installer. These tools can create a live ISO and provide an easy-to-use graphical installer.\nInstall Refracta Tools:\nsudo apt-get install refractasnapshot refractainstaller refractainstaller-base 11. ISO Testing and Finalization Ensure the ISO is well-tested on multiple devices with different BIOS and UEFI settings. Verify boot compatibility on different systems (BIOS/UEFI) using tools like Rufus or Ventoy for creating bootable USBs. Additional Considerations: File system support: Ensure the system supports ext4, Btrfs, or other file systems commonly used on Linux. Secure Boot support: If needed, configure secure boot support for UEFI systems. Kernel options: Customize the kernel if specific features or drivers are needed. Documentation: Provide good documentation for users who will install your custom distro, especially if it has unique tools or configurations. Example of a Customized Command for Building: lb config \\ --architecture amd64 \\ --debian-installer true \\ --distribution bullseye \\ --bootappend-live \u0026#34;boot=live components persistence\u0026#34; \\ --iso-application \u0026#34;Custom Linux OS\u0026#34; \\ --iso-publisher \u0026#34;YourOS Publisher\u0026#34; \\ --iso-volume \u0026#34;YourOS Installer\u0026#34; \\ --debian-installer true \\ --mirror-bootstrap \u0026#34;http://deb.debian.org/debian/\u0026#34; \\ --archive-areas \u0026#34;main contrib non-free\u0026#34; This process will create a Debian-based custom ISO with live boot and installation options, BIOS/UEFI compatibility, and custom software configurations.\n2nd via prompt To create a custom Linux distribution based on Debian 12 \u0026ldquo;Bookworm\u0026rdquo; using the live-build tool, tailored for AI, ML/DS engineers, and using the i3 window manager without a desktop environment, here’s how you can go about it. You also want the installer to be Calamares, with USB persistence support and custom branding replacing Debian with the name Fusion Flux.\nBelow are the detailed steps to guide you through the process:\n1. Install Required Tools First, you need to install the necessary tools on your build machine (which should ideally be a Debian 12 \u0026ldquo;Bookworm\u0026rdquo; system):\nsudo apt update sudo apt install live-build calamares git live-build: Tool for building live systems (ISO images). calamares: A modular installer framework. 2. Set Up the Build Directory Create a new directory for your custom distribution:\nmkdir fusion-flux cd fusion-flux 3. Configure Live Build You\u0026rsquo;ll need to configure live-build to create your base system with i3, custom branding, persistence, and other features.\nBase Configuration Command: Run the following command to set the basic options for the live-build system:\nlb config \\ --distribution bookworm \\ --architecture amd64 \\ --debian-installer false \\ --debian-installer-gui false \\ --bootappend-live \u0026#34;boot=live components persistence\u0026#34; \\ --linux-flavours amd64 \\ --iso-publisher \u0026#34;Fusion Flux\u0026#34; \\ --iso-volume \u0026#34;Fusion Flux Live\u0026#34; \\ --iso-application \u0026#34;Fusion Flux AI/ML Distribution\u0026#34; \\ --apt-indices false \\ --firmware-binary true \\ --firmware-chroot true \\ --archive-areas \u0026#34;main contrib non-free\u0026#34; Here’s what each option does:\n--distribution bookworm: Specifies the Debian 12 Bookworm base. --architecture amd64: Sets 64-bit architecture. --bootappend-live \u0026quot;boot=live components persistence\u0026quot;: Enables persistence. --debian-installer false: Disables the default Debian installer (you\u0026rsquo;ll be using Calamares instead). --firmware-binary and --firmware-chroot: Ensures firmware is available for hardware support. --archive-areas \u0026quot;main contrib non-free\u0026quot;: Enables access to additional repositories for non-free and contrib software. Customizing the Build: Window Manager Configuration (i3) Create a config/package-lists/custom.list.chroot file and add the packages you want preinstalled in the system:\nmkdir -p config/package-lists echo \u0026#34;i3\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot echo \u0026#34;lightdm\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot # For a lightweight display manager echo \u0026#34;xterm\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot echo \u0026#34;git\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot echo \u0026#34;python3\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot echo \u0026#34;python3-pip\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot echo \u0026#34;python3-venv\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot echo \u0026#34;jupyterlab\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot echo \u0026#34;neovim\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot echo \u0026#34;scikit-learn\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot echo \u0026#34;tensorflow\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot echo \u0026#34;pytorch\u0026#34; \u0026gt;\u0026gt; config/package-lists/custom.list.chroot This list ensures that the i3 window manager is installed, alongside AI/ML-related tools (e.g., scikit-learn, tensorflow, pytorch, and Jupyter).\nAdd Calamares Installer Calamares is a modular and customizable installer used by various Linux distributions.\nIn your config/package-lists/, create a list for Calamares:\necho \u0026#34;calamares\u0026#34; \u0026gt;\u0026gt; config/package-lists/installer.list.chroot echo \u0026#34;calamares-settings-debian\u0026#34; \u0026gt;\u0026gt; config/package-lists/installer.list.chroot To configure Calamares, you need to create custom settings. Create the following directory:\nmkdir -p config/includes.chroot/etc/calamares/modules You can find default configurations for Calamares modules in the Debian repository. Customize the installer for your distribution’s needs. For example, place the following configuration in the netinstall.conf for Calamares:\necho \u0026#34; --- name: netinstall welcome: true pre_install: - initramfs-update installation: - install - configure-base post_install: - initramfs-update \u0026#34; \u0026gt;\u0026gt; config/includes.chroot/etc/calamares/modules/netinstall.conf Custom Branding (Replace \u0026ldquo;Debian\u0026rdquo; with \u0026ldquo;Fusion Flux\u0026rdquo;)\nReplace any Debian branding with Fusion Flux. This involves replacing logos, system messages, and installer text. Update the GRUB menu and any logos found in /boot/grub/themes and /usr/share/plymouth/themes to reflect your distribution’s branding. You can customize /etc/lsb-release to define the release version: echo \u0026#34;DISTRIB_ID=FusionFlux\u0026#34; \u0026gt; config/includes.chroot/etc/lsb-release echo \u0026#34;DISTRIB_DESCRIPTION=\u0026#39;Fusion Flux AI/ML Distribution\u0026#39;\u0026#34; \u0026gt;\u0026gt; config/includes.chroot/etc/lsb-release Persistence Configuration To ensure USB persistence, ensure the boot command includes the persistence option (already included in --bootappend-live). Additionally, when users create a live USB with persistence, they need to set up a persistence partition named persistence.\nModify the live boot files to include support for persistence: echo \u0026#34;/ union\u0026#34; \u0026gt; config/includes.binary/persistence.conf 4. Build the ISO Once the configuration is ready, build the ISO using the following command:\nsudo lb build This will create a 64-bit amd64 ISO image in the current directory.\nThe build process can take some time depending on the size of the packages you’ve included. Check for any errors or missing packages and modify config/package-lists/custom.list.chroot as needed. 5. Test Your ISO After the build process is complete, you will have a .iso file ready for testing.\nTest the ISO in VirtualBox or QEMU: You can test the live boot and installation process using a virtual machine before trying it on real hardware. If everything works, you can create a bootable USB.\nCreate a Bootable USB with Persistence: Use Rufus, Ventoy, or BalenaEtcher to create a bootable USB from the ISO.\nIf you are using persistence, make sure to create a second partition on the USB labeled persistence and a file named persistence.conf with the following content:\n/ union This will ensure that changes made in the live session (e.g., saved files or installed packages) are persistent.\n6. Final Touches Once your ISO is fully functional, you may want to:\nFurther tweak configurations for the installer. Add more advanced AI/ML tools based on feedback from users or your own preferences. Ensure all branding elements (logos, texts, etc.) reflect the Fusion Flux identity. By following these steps, you will have created a custom Debian Bookworm-based Linux distribution named Fusion Flux, with i3 preinstalled, Calamares as the installer, and USB persistence. This distribution will be optimized for AI, ML, and Data Science workflows, and should work smoothly when booted from a USB or installed on a system.\n3rd firmware error I understand you\u0026rsquo;re encountering an error while building your Fusion Linux distribution. The error message indicates that the package \u0026lsquo;firmware-linux\u0026rsquo; is not available. This is a common issue when working with Debian-based distributions, especially when dealing with non-free firmware. Let\u0026rsquo;s troubleshoot this step by step:\nFirst, ensure that you have the non-free and contrib repositories enabled. In your lb config command, add the following if you haven\u0026rsquo;t already:\nlb config --distribution bookworm --archive-areas \u0026#34;main contrib non-free non-free-firmware\u0026#34; The package \u0026lsquo;firmware-linux\u0026rsquo; has been replaced by more specific packages in recent Debian versions. Instead of \u0026lsquo;firmware-linux\u0026rsquo;, you should use \u0026lsquo;firmware-linux-free\u0026rsquo; and possibly \u0026lsquo;firmware-linux-nonfree\u0026rsquo;. Update your package list to include these:\nEdit your config/package-lists/live.list.chroot file and replace \u0026lsquo;firmware-linux\u0026rsquo; with:\nfirmware-linux-free firmware-misc-nonfree Make sure your system is up to date:\nsudo apt update sudo apt upgrade Clean your build environment before rebuilding:\nsudo lb clean Rebuild your live system:\nsudo lb build If you\u0026rsquo;re still encountering issues, here are a few more things to try:\nCheck if you have the correct sources list. Create or edit the file config/archives/debian.list.chroot:\ndeb http://deb.debian.org/debian bookworm main contrib non-free non-free-firmware deb http://deb.debian.org/debian-security/ bookworm-security main contrib non-free non-free-firmware deb http://deb.debian.org/debian bookworm-updates main contrib non-free non-free-firmware If you\u0026rsquo;re behind a proxy, make sure it\u0026rsquo;s correctly configured in your build environment.\nIf the issue persists, you might want to try using a newer version of live-build:\nsudo apt install live-build/bookworm-backports After making these changes, clean and rebuild your system. If you\u0026rsquo;re still facing issues, please provide the full output of the build process, and I\u0026rsquo;ll be happy to help you troubleshoot further.\ntest with qemu qemu-system-x86_64 -cdrom \u0026#39;/home/yash/Desktop/live-image-amd64.hybrid.iso\u0026#39; -boot d -m 3000 building and modififing chroot Using chroot allows you to enter a filesystem environment (in this case, the filesystem of your live-build) and interact with it as if it were the root of your system. This is very useful for testing changes like adding or removing programs without having to rebuild the entire ISO.\nHere\u0026rsquo;s a step-by-step guide on how to use chroot in the context of a live-build:\nSteps to Use chroot with Live-build Prepare the Build Environment Make sure you have your live-build setup ready, and you have at least done the lb build command once to create the base filesystem. If you haven\u0026rsquo;t built the image yet, run:\nlb build This will create a chroot/ directory in your live-build project where the root filesystem resides.\nEntering the chroot Environment Once the chroot directory is ready, you can enter it:\nsudo chroot path/to/chroot/ For example, if you\u0026rsquo;re in your live-build directory, it might be:\nsudo chroot chroot/ Now you\u0026rsquo;re inside the filesystem as if it\u0026rsquo;s the root of your system.\nUpdate Package Lists Inside the chroot, you’ll want to update the package list to make sure it has access to the latest repositories:\napt-get update Installing Packages You can now install any packages you want to add to the final ISO. For example:\napt-get install your-package Removing Packages Similarly, you can remove packages:\napt-get remove your-package Testing and Configuring You can also modify and test configurations inside the chroot environment. You are working within the actual environment that will be part of your live system, so this allows you to test changes immediately.\nExiting the chroot Once you\u0026rsquo;re done making changes, you can simply exit the chroot environment:\nexit Repack the ISO (if needed) If you are satisfied with the changes made in the chroot, you can rebuild the binary part of the ISO (not the full rebuild) to integrate the changes:\nlb clean --binary lb build This will regenerate the ISO but keep the same base environment, making it faster.\nAdditional Notes: Mount proc, sys, and dev: Some services or scripts inside chroot may require access to /proc, /sys, or /dev. You can mount these as follows before entering chroot: sudo mount -o bind /proc chroot/proc sudo mount -o bind /sys chroot/sys sudo mount -o bind /dev chroot/dev After you\u0026rsquo;re done, unmount them: sudo umount chroot/proc sudo umount chroot/sys sudo umount chroot/dev Using chroot allows you to make changes quickly without needing to rebuild the entire image. This can save a lot of time when testing packages or configurations.\nadd set users, change os name , and configure calamares 1. Add default username (fusion) and password (fusion), and make fusion user a sudoer You can achieve this by editing the configuration of live-build to create a user with the required credentials. You\u0026rsquo;ll modify the hooks to add the user and set up sudo permissions.\nCreate a chroot hook file:\nmkdir -p config/hooks/live nano config/hooks/live/01-create-user.hook.chroot Add the following content to create the fusion user, set the password, and add it to the sudo group:\n#!/bin/bash # Add \u0026#39;fusion\u0026#39; user with password \u0026#39;fusion\u0026#39; useradd -m -s /bin/bash fusion echo \u0026#39;fusion:fusion\u0026#39; | chpasswd # Add \u0026#39;fusion\u0026#39; to sudoers echo \u0026#39;fusion ALL=(ALL) NOPASSWD:ALL\u0026#39; \u0026gt; /etc/sudoers.d/fusion chmod 0440 /etc/sudoers.d/fusion Make the hook executable:\nchmod +x config/hooks/live/01-create-user.hook.chroot 2. Add root user and set the password to root You can add the root password within the same hook created in Step 1 or in a separate hook file.\nIn the same hook file (01-create-user.hook.chroot), add the following line: # Set root password to \u0026#39;root\u0026#39; echo \u0026#39;root:root\u0026#39; | chpasswd 3. Change OS name to fusion instead of Debian To rebrand the OS, you will need to modify certain files that show the OS name.\nCreate another hook to replace all occurrences of Debian with fusion:\nnano config/hooks/live/02-change-os-name.hook.chroot Add the following commands to replace Debian with Fusion in key files:\n#!/bin/bash # Change OS name from Debian to fusion sed -i \u0026#39;s/Debian/fusion/g\u0026#39; /etc/issue sed -i \u0026#39;s/Debian/fusion/g\u0026#39; /etc/os-release sed -i \u0026#39;s/Debian/fusion/g\u0026#39; /etc/motd Make the hook executable:\nchmod +x config/hooks/live/02-change-os-name.hook.chroot 4. Auto-start Calamares installer on booting the live OS To automatically start the Calamares installer when the live system boots, you can configure an autostart file or a systemd service.\nCreate a file to handle Calamares autostart:\nmkdir -p config/includes.chroot/etc/xdg/autostart/ nano config/includes.chroot/etc/xdg/autostart/calamares.desktop Add the following content to auto-start Calamares:\n[Desktop Entry] Type=Application Exec=calamares Hidden=false NoDisplay=false X-GNOME-Autostart-enabled=true Name=Calamares Installer Comment=Start Calamares Installer 5. Remove Calamares installer after installing the distribution Once the OS is installed, you will want to remove Calamares from the target system (the installed system). You can create a post-installation script for this purpose.\nCreate a new hook to remove Calamares after installation:\nnano config/hooks/post/03-remove-calamares.hook.postinst Add the following content to the hook to remove Calamares after the installation process:\n#!/bin/bash # Remove Calamares after installation apt-get purge --yes calamares Make the hook executable:\nchmod +x config/hooks/post/03-remove-calamares.hook.postinst Building the Live ISO Once you have completed all these customizations, you can build your custom Linux distribution using the live-build tool.\nFirst, ensure everything is set up correctly, then start the build process: sudo lb build This will generate the ISO for your custom Linux distribution with all the changes.\nSummary of Changes User Setup:\nfusion user is created with sudo privileges. root user is set up with the password root. OS Branding:\nOS name is changed from Debian to fusion. Installer Autostart:\nCalamares installer is set to autostart when the live system boots. Post-Installation Cleanup:\nCalamares is removed from the system after installation to prevent it from being present in the installed system. This setup allows you to fully customize the live distribution as per your requirements!\n","date":"2024-10-01T00:00:00Z","permalink":"http://localhost:1313/post/projects/fusion-flux/","title":"custom linux distro"},{"content":"1. Compare Two Arrays in Java While comparing two arrays we can not use “ == ” operator as it will compare the addresses of the memory block to which both the arrays are pointing.\nA simple way is to run a loop and compare elements one by one. Java provides a direct method Arrays.equals() to compare two arrays. Actually, there is a list of equals() methods in the Arrays class for different primitive types (int, char, ..etc) and one for Object type (which is the base of all classes in Java).\n// Java Program to Check If Two Arrays Are Equal // Using equals() method of Arrays class // Importing required classes import java.util.Arrays; // Main class class GFG { // Main driver method public static void main(String[] args) { // Declaring integer arrays int arr1[] = { 1, 2, 3 }; int arr2[] = { 1, 2, 3 }; // Checking if above two arrays are equal // using equals() method if (Arrays.equals(arr1, arr2)) // Print statement if arrays are equal System.out.println(\u0026#34;Same\u0026#34;); else // Print statement if arrays are equal System.out.println(\u0026#34;Not same\u0026#34;); } } ","date":"2024-09-29T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/array-question-placement-java/","title":"Array question placement java"},{"content":"1. Tower of Hanoi [!Rules:]\nOnly one disk transferred in 1 step smaller disks are always kept on top of larger disks public class Recursion { // Define a public class named \u0026#39;Recursion\u0026#39;. // A static method to solve the Tower of Hanoi problem public static void TowerOfHanoi(int n, String src, String helper, String dest) { // Base condition: If there\u0026#39;s only one disk, move it directly from source to destination. if (n == 1) { // Print out the move of the single disk from source to destination System.out.println(\u0026#34;transfer disk \u0026#34; + n + \u0026#34; from \u0026#34; + src + \u0026#34; to \u0026#34; + dest); return; // End the current recursive call when only one disk is left } // Recursive call: Move (n-1) disks from source to helper using destination as an auxiliary TowerOfHanoi(n - 1, src, dest, helper); // Move the nth disk (largest) from source to destination System.out.println(\u0026#34;transfer disk \u0026#34; + n + \u0026#34; from \u0026#34; + src + \u0026#34; to \u0026#34; + dest); // Recursive call: Move (n-1) disks from helper to destination using source as an auxiliary TowerOfHanoi(n - 1, helper, src, dest); } // Main method: the entry point of the program public static void main(String[] args) { int n = 3; // Number of disks // Call the TowerOfHanoi method to solve for 3 disks, with source as \u0026#34;Source\u0026#34;, helper as \u0026#34;Helper\u0026#34;, and destination as \u0026#34;Destination\u0026#34;. TowerOfHanoi(n, \u0026#34; Source \u0026#34;, \u0026#34; Helper \u0026#34;, \u0026#34; Destination \u0026#34;); } } Time complexity is = $O(2^n)$\n2. Reverse a string using Recurssion abcd dcba\npublic class Recursion{ public static void ReverseString(int index, String str) { //base condition if(index == 0 ){ System.out.print(str.charAt(index)); return; } System.out.print(str.charAt(index)); ReverseString( index -1,str); } public static void main (String[] args) { String str = \u0026#34;abcdefg\u0026#34;; ReverseString( str.length()-1 , str); } } Time complexity O(n)\n3. find the last occurrence of the element in the string. reference video with time stamp =[[https://youtu.be/u-HgzgYe8KA?list=PLfqMhTWNBTe3LtFWcvwpqTkUSlB32kJop\u0026amp;t=1929]]\npublic class Recursion { public static int first = -1; public static int last = -1; public static void findOccurrence(int index, String str, char element) { // Base condition: If index reaches the length of the string, print first and last occurrence if (index == str.length()) { System.out.println(\u0026#34;First occurrence: \u0026#34; + first); System.out.println(\u0026#34;Last occurrence: \u0026#34; + last); return; } // Check if the current character matches the element char currChar = str.charAt(index); if (currChar == element) { if (first == -1) { // Set the first occurrence if it\u0026#39;s the first time encountering the element first = index; } else { // Update the last occurrence last = index; } } // Recursive call with index incremented to move forward findOccurrence(index + 1, str, element); } public static void main(String[] args) { String str = \u0026#34;abcdefga\u0026#34;; // Input string findOccurrence(0, str, \u0026#39;a\u0026#39;); // Start the search at index 0 } } time complexity: O(n)\n4. check if an array is sorted (strictly sorted) public class Recursion2 { public static boolean isSorted(int arr[], int idx) { // Print the current index and the elements being compared System.out.println(\u0026#34;Checking if arr[\u0026#34; + idx + \u0026#34;] \u0026lt; arr[\u0026#34; + (idx + 1) + \u0026#34;]\u0026#34;); // Base case: if we\u0026#39;re at the last index, the array is sorted if (idx == arr.length - 1) { System.out.println(\u0026#34;Reached the last element, array is sorted.\u0026#34;); return true; } // Recursive case: if the current element is less than the next, keep checking if (arr[idx] \u0026lt; arr[idx + 1]) { System.out.println(\u0026#34;arr[\u0026#34; + idx + \u0026#34;] = \u0026#34; + arr[idx] + \u0026#34; is less than arr[\u0026#34; + (idx + 1) + \u0026#34;] = \u0026#34; + arr[idx + 1] + \u0026#34;, checking further.\u0026#34;); return isSorted(arr, idx + 1); } else { System.out.println(\u0026#34;arr[\u0026#34; + idx + \u0026#34;] = \u0026#34; + arr[idx] + \u0026#34; is NOT less than arr[\u0026#34; + (idx + 1) + \u0026#34;] = \u0026#34; + arr[idx + 1] + \u0026#34;, array is not sorted.\u0026#34;); return false; } } public static void main(String args[]) { int arr[] = {1, 3, 5}; // You can modify this array to test different cases System.out.println(\u0026#34;Is the array sorted? \u0026#34; + isSorted(arr, 0)); } } time complexity = O(n)\n5. Move all \u0026lsquo;X\u0026rsquo; to the end of string (\u0026ldquo;acbcxxd\u0026rdquo;) Given a string like \u0026quot;axbcxxd\u0026quot;, we want to move all the 'x' characters to the end. The result for this example would be \u0026quot;abcxdxx\u0026quot;\nIf the current character is not \u0026lsquo;x\u0026rsquo;, keep it where it is. If the current character is \u0026lsquo;x\u0026rsquo;, move it to the end. Recursion involves solving a problem by breaking it into smaller sub-problems. Here\u0026rsquo;s how we can think about this:\nIf the string is empty, return an empty string (base case). For a string that is not empty: If the first character is not \u0026lsquo;x\u0026rsquo;, keep it at the front and call the function recursively on the rest of the string. If the first character is \u0026lsquo;x\u0026rsquo;, move it to the end and call the function recursively on the rest of the string. public class MoveXToEnd { // Recursive function to move all \u0026#39;x\u0026#39; to the end of the string public static String moveXToEnd(String str) { // Base case: if the string is empty, return the empty string if (str.length() == 0) { return \u0026#34;\u0026#34;; } // Get the first character of the string char firstChar = str.charAt(0); // Recursively call moveXToEnd on the rest of the string String restOfString = moveXToEnd(str.substring(1)); // If the first character is \u0026#39;x\u0026#39;, append it to the result of the recursion if (firstChar == \u0026#39;x\u0026#39;) { return restOfString + firstChar; // Move \u0026#39;x\u0026#39; to the end } else { return firstChar + restOfString; // Keep the first character in front } } // Main method to test the function public static void main(String[] args) { String input = \u0026#34;axbcxxd\u0026#34;; String result = moveXToEnd(input); System.out.println(\u0026#34;Result: \u0026#34; + result); } } time complexity O(n)\n6.Remove Duplicates of strings public class Recursion2 { public static boolean[] map = new boolean[26]; public static void removeDuplicates(String str, int idx, String newString){ if(idx == str.length()) { System.out.println(newString); return; } char currChar= str.charAt(idx); if(map[currChar - \u0026#39;a\u0026#39;]) { removeDuplicates(str, idx+1, newString); } else { newString += currChar; map[currChar - \u0026#39;a\u0026#39;] = true; removeDuplicates (str,idx+1, newString); } } public static void main (String args[]) { String str = \u0026#34;abbcddddaaa\u0026#34;; removeDuplicates(str,0,\u0026#34;\u0026#34;); } } 7. print all the sub-sequences of a string \u0026ldquo;abc\u0026rdquo; public class Recursion2 { public static void subsequence(String str, int idx, String newString){ if(idx == str.length()) { System.err.println(newString); return; } char currcharr = str.charAt(idx); subsequence(str, idx+1, newString + currcharr); subsequence(str,idx+1,newString); } public static void main (String args[]) { String str = \u0026#34;abc\u0026#34;; subsequence(str,0,\u0026#34;\u0026#34;); } } time complexity = 2^n\n8. Print keypad combnation import java.util.HashSet; public class Recursion2 { public static String[] keypad = {\u0026#34;.\u0026#34;,\u0026#34;abc\u0026#34;,\u0026#34;def\u0026#34;,\u0026#34;ghi\u0026#34;,\u0026#34;jkl\u0026#34;,\u0026#34;mno\u0026#34;,\u0026#34;pqrs\u0026#34;,\u0026#34;tu\u0026#34;,\u0026#34;vwx\u0026#34;,\u0026#34;yz\u0026#34;}; public static void printComb(String str, int idx, String combination) { if(idx == str.length()) { System.out.println(combination); return; } char currChar = str.charAt(idx); String mapping = keypad[currChar - \u0026#39;0\u0026#39;]; for(int i =0; i\u0026lt;mapping.length(); i++){ printComb(str, idx+1,combination+mapping.charAt(i)); } } public static void main (String args[]){ String str = \u0026#34;41\u0026#34;; printComb(str,0,\u0026#34;\u0026#34;); } } ","date":"2024-09-28T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/java-recursion-problems-solved-can-be-asked-in-interview/","title":"Java recursion problems solved can be asked in interview"},{"content":"Java Recursion Recursion is the technique of making a function call itself This technique provides a way to break complicated problems down into simple problems which are easier to solve. Recursion Example Adding two numbers together is easy to do, but adding a range of numbers is more complicated. In the following example, recursion is used to add a range of numbers together by breaking it down into the simple task of adding two numbers:\npublic class Main { public static void main(String[] args) { int result = sum(10); System.out.println(result); } public static int sum(int k) { if (k \u0026gt; 0) { return k + sum(k - 1); } else { return 0; } } } Just as loops can run into the problem of infinite looping, recursive functions can run into the problem of infinite recursion. Infinite recursion is when the function never stops calling itself. Every recursive function should have a halting condition, which is the condition where the function stops calling itself. In the previous example, the halting condition is when the parameter k becomes 0.\nIt is helpful to see a variety of different examples to better understand the concept. In this example, the function adds a range of numbers between a start and an end. The halting condition for this recursive function is when end is not greater than start:\npublic class Main { public static void main(String[] args) { int result = sum(5, 10); System.out.println(result); } public static int sum(int start, int end) { if (end \u0026gt; start) { return end + sum(start, end - 1); } else { return end; } } } ","date":"2024-09-25T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/java-recursion/","title":"Recursion in java"},{"content":"(HandWritten Notes) https://drive.google.com/file/d/18mldgbyPhkf1BfqvwKSYSM9WGcZsYaG5/view?usp=drive_link four main pillars of Object-Oriented Programming (OOP) in simple terms: 1.Encapsulation: What it is: Encapsulation is like putting data and the methods (functions) that operate on that data inside a single unit, which is called a class. This keeps the data safe from outside interference and misuse. Why it’s useful: It allows you to control how the data is accessed and modified. You can make certain data private and only accessible through methods, which provides security and avoids unwanted changes. Example: Imagine you have a class Car. It contains data like speed and methods like drive() and stop(). You can make the speed private so it can only be changed by using a specific method like setSpeed(). This way, you can control how the speed is modified. class Car { private int speed; // private variable public void setSpeed(int speed) { if (speed \u0026gt; 0) { this.speed = speed; // control how speed is set } } public int getSpeed() { return speed; // getter method to access speed } } Here, speed is encapsulated (hidden) inside the Car class and can only be accessed through setSpeed() and getSpeed() methods. This is encapsulation.\n2. Inheritance: What it is: Inheritance is when one class takes on the properties and methods of another class. The class that gives its properties is called the parent (or base class), and the class that inherits is called the child (or derived class). Why it’s useful: It helps in code re-usability. If multiple classes share similar features, you can put the shared features in a parent class and the child classes can reuse them. Plus, child classes can also add their own features. Example: Let’s say we have a Vehicle class with common properties like speed and methods like drive(). We can create specific classes like Car and Bike that inherit these properties from Vehicle. class Vehicle { int speed; public void drive() { System.out.println(\u0026#34;Vehicle is driving\u0026#34;); } } class Car extends Vehicle { public void honk() { System.out.println(\u0026#34;Car is honking\u0026#34;); } } In this example, the Car class inherits the drive() method from Vehicle. This means Car objects can use both drive() and their own honk() method.\n3. Polymorphism: What it is: Polymorphism allows one name to have many forms. In OOP, this means you can use the same method or function name to perform different tasks, based on the context.\nWhy it’s useful: It makes code flexible and reusable. A method can behave differently based on the input or the object that calls it. There are two main types:\nCompile-time Polymorphism (Method Overloading): When you have multiple methods with the same name but different parameters. Run-time Polymorphism (Method Overriding): When a child class has a method with the same name as one in the parent class but gives it a new implementation. Example of Method Overloading (Compile-time Polymorphism):\nclass Calculator { public int add(int a, int b) { return a + b; } public double add(double a, double b) { return a + b; } } Here, the add() method is overloaded: one version takes two integers, and the other takes two doubles.\nExample of Method Overriding (Run-time Polymorphism):\nclass Animal { public void sound() { System.out.println(\u0026#34;Animal makes a sound\u0026#34;); } } class Dog extends Animal { @Override public void sound() { System.out.println(\u0026#34;Dog barks\u0026#34;); } } In this case, Dog overrides the sound() method of Animal. Even though the method name is the same, the behavior is different. 4. Abstraction: What it is: Abstraction means showing only the essential details and hiding the complexity. You focus on what an object does, not how it does it. Why it’s useful: It helps reduce complexity by allowing you to focus on the high-level functioning of your program without worrying about the details. Example: You know how to drive a car (you use methods like accelerate() and brake()), but you don’t need to know exactly how the engine works. In Java, abstraction is usually implemented using:\nAbstract classes: Classes that can have both defined methods (with code) and undefined methods (without code). Interfaces: They contain only method signatures, and any class that implements the interface must provide its own implementation for those methods. Example of Abstraction with an Interface: interface Animal { void sound(); // method signature without implementation } class Dog implements Animal { public void sound() { System.out.println(\u0026#34;Dog barks\u0026#34;); } } Here, Animal is an interface that defines what a sound method should look like. The Dog class implements this interface and provides its own behavior.\nQuick Recap: Encapsulation: Hides data and gives controlled access. Inheritance: Allows a class to use the properties and methods of another class. Polymorphism: One name, many forms (method overloading and overriding). Abstraction: Hides unnecessary details and shows only the essential parts. ","date":"2024-09-23T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/2.-oops-in-java/","title":"OOPs in java"},{"content":"\n","date":"2024-09-23T00:00:00Z","permalink":"http://localhost:1313/post/sql/sql-handwritten-notes/","title":"SQL Notes"},{"content":"Bit manipulation is a powerful tool in programming that involves directly operating on bits (0s and 1s) of data. often used to optimize code for speed and memory usage in performance-critical applications. Java provides a set of bitwise operators that allow manipulation of individual bits.\nBit Manipulation in Java Bit manipulation is a powerful tool in programming that involves directly operating on bits (0s and 1s) of data. It is often used to optimize code for speed and memory usage in performance-critical applications. Java provides a set of bitwise operators that allow manipulation of individual bits.\nCommon Bitwise Operators in Java Bitwise AND (\u0026amp;): Compares each bit of two numbers and returns 1 if both bits are 1, otherwise returns 0.\nExample:\nint a = 5; // 0101 in binary int b = 3; // 0011 in binary int result = a \u0026amp; b; // 0001 in binary (1 in decimal) System.out.println(result); // Output: 1 Bitwise OR (|): Compares each bit of two numbers and returns 1 if at least one of the bits is 1, otherwise returns 0.\nExample:\nint a = 5; // 0101 in binary int b = 3; // 0011 in binary int result = a | b; // 0111 in binary (7 in decimal) System.out.println(result); // Output: 7 Bitwise XOR (^): Compares each bit of two numbers and returns 1 if the bits are different, and 0 if they are the same.\nExample:\nint a = 5; // 0101 in binary int b = 3; // 0011 in binary int result = a ^ b; // 0110 in binary (6 in decimal) System.out.println(result); // Output: 6 Bitwise NOT (~): Inverts all the bits of a number (1 becomes 0, and 0 becomes 1).\nExample:\nint a = 5; // 0101 in binary int result = ~a; // 1010 in binary (-6 in decimal due to two\u0026#39;s complement representation) System.out.println(result); // Output: -6 Left Shift (\u0026lt;\u0026lt;): Shifts the bits of the number to the left by the specified number of positions. This effectively multiplies the number by 2^n (where n is the number of positions shifted).\nExample:\nint a = 5; // 0101 in binary int result = a \u0026lt;\u0026lt; 1; // 1010 in binary (10 in decimal) System.out.println(result); // Output: 10 Right Shift (\u0026gt;\u0026gt;): Shifts the bits of the number to the right by the specified number of positions. This effectively divides the number by 2^n (where n is the number of positions shifted), but keeps the sign bit intact (preserving the sign for negative numbers).\nExample:\nint a = 10; // 1010 in binary int result = a \u0026gt;\u0026gt; 1; // 0101 in binary (5 in decimal) System.out.println(result); // Output: 5 Unsigned Right Shift (\u0026gt;\u0026gt;\u0026gt;): Shifts the bits of the number to the right, but does not preserve the sign bit. It inserts 0 in the leftmost bits. It treats the number as an unsigned value.\nExample:\nint a = -10; // 11111111111111111111111111110110 in binary int result = a \u0026gt;\u0026gt;\u0026gt; 1; // 01111111111111111111111111111011 in binary (2147483643 in decimal) System.out.println(result); // Output: 2147483643 Common Bit Manipulation Techniques Checking if a number is odd or even: You can use the bitwise AND operator to check if the least significant bit (LSB) is 1 (odd) or 0 (even).\nExample:\nint a = 5; boolean isOdd = (a \u0026amp; 1) == 1; // If LSB is 1, the number is odd System.out.println(isOdd); // Output: true (since 5 is odd) Swapping two numbers without a temporary variable: You can swap two numbers using XOR.\nExample:\nint a = 5, b = 3; a = a ^ b; // a becomes 6 (0110) b = a ^ b; // b becomes 5 (0101) a = a ^ b; // a becomes 3 (0011) System.out.println(\u0026#34;a: \u0026#34; + a + \u0026#34;, b: \u0026#34; + b); // Output: a: 3, b: 5 Flipping all the bits of a number: Use the bitwise NOT (~) operator to flip all the bits.\nExample:\nint a = 5; // 0101 in binary int flipped = ~a; // 1010 in binary (-6 in decimal) System.out.println(flipped); // Output: -6 Counting the number of set bits (1-bits): You can count the number of 1s in the binary representation of a number using a loop or Java\u0026rsquo;s Integer.bitCount() method.\nExample:\nint a = 5; // Binary: 0101 int count = Integer.bitCount(a); // Number of 1s System.out.println(count); // Output: 2 Checking if the n-th bit is set: You can check if the n-th bit (starting from 0) is set to 1 using the bitwise AND operator.\nExample:\nint a = 5; // Binary: 0101 int n = 2; boolean isSet = (a \u0026amp; (1 \u0026lt;\u0026lt; n)) != 0; // Check if the 2nd bit is set System.out.println(isSet); // Output: true (since the 2nd bit is 1) Setting the n-th bit: You can set the n-th bit to 1 using the bitwise OR operator.\nExample:\nint a = 5; // Binary: 0101 int n = 1; a = a | (1 \u0026lt;\u0026lt; n); // Set the 1st bit System.out.println(a); // Output: 7 (Binary: 0111) Clearing the n-th bit: You can clear the n-th bit (set it to 0) using the bitwise AND with a mask that has the n-th bit as 0 and all other bits as 1.\nExample:\nint a = 5; // Binary: 0101 int n = 2; a = a \u0026amp; ~(1 \u0026lt;\u0026lt; n); // Clear the 2nd bit System.out.println(a); // Output: 1 (Binary: 0001) Toggle the n-th bit: You can toggle the n-th bit (flip it) using the bitwise XOR operator.\nExample:\nint a = 5; // Binary: 0101 int n = 1; a = a ^ (1 \u0026lt;\u0026lt; n); // Toggle the 1st bit System.out.println(a); // Output: 7 (Binary: 0111) Conclusion Bit manipulation in Java is a highly efficient way to perform operations at the bit level. By mastering bitwise operators and common techniques like setting, clearing, and toggling bits, you can write optimized and high-performance code. This is particularly useful in areas like cryptography, compression, graphics programming, and low-level systems programming.\n","date":"2024-09-22T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/bit-manipulation-in-java/","title":"bit manipulation in java"},{"content":"Operators in Java classified into different types, such as arithmetic, relational, logical, bitwise, assignment, and more.\nArithmetic Operators These operators are used to perform basic mathematical operations:\n+ (Addition) - (Subtraction) * (Multiplication) / (Division) % (Modulus - returns the remainder) int a = 10 ; int b = 10 ; System.out.println(a+b); System.out.println(a-b); System.out.println(a*b); System.out.println(a/b); System.out.println(a%b); Relational (Comparison) Operators These operators compare two values and return a boolean value (true or false).\n== (Equal to) != (Not equal to) \u0026gt; (Greater than) \u0026lt; (Less than) \u0026gt;= (Greater than or equal to) \u0026lt;= (Less than or equal to) int a = 10; int b = 20; System.out.println( a \u0026lt; b ); System.out.println( a == b ); System.out.println( a!= b); Logical Operator These operators are used for combining multiple conditions:\n\u0026amp;\u0026amp; (Logical AND) || (Logical OR) ! (Logical NOT) int a = 10; int b = 5; System.out.println(a \u0026gt; b \u0026amp;\u0026amp; a \u0026gt; 0); // Output: true System.out.println(a \u0026lt; b || a \u0026gt; 0); // Output: true System.out.println(!(a == b)); // Output: true Bitwise Operators These operators perform operations on bits:\n\u0026amp; (Bitwise AND) | (Bitwise OR) ^ (Bitwise XOR) ~ (Bitwise NOT) \u0026lt;\u0026lt; (Left shift) \u0026gt;\u0026gt; (Right shift) \u0026gt;\u0026gt;\u0026gt; (Unsigned right shift) int a = 5; // Binary: 0101 int b = 3; // Binary: 0011 System.out.println(a \u0026amp; b); // Output: 1 (Binary: 0001) System.out.println(a | b); // Output: 7 (Binary: 0111) System.out.println(a ^ b); // Output: 6 (Binary: 0110) System.out.println(~a); // Output: -6 (Binary: 1010) System.out.println(a \u0026lt;\u0026lt; 1); // Output: 10 (Binary: 1010) System.out.println(a \u0026gt;\u0026gt; 1); // Output: 2 (Binary: 0010) Assignment Operators These operators are used to assign values to variables:\n= (Assigns value) += (Add and assign) -= (Subtract and assign) *= (Multiply and assign) /= (Divide and assign) %= (Modulus and assign) int a = 10; a += 5; // a = a + 5 System.out.println(a); // Output: 15 ","date":"2024-09-22T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/operators-in-java/","title":"operators in java"},{"content":" bubble Sort ✅ 2024-09-22 selection sort ✅ 2024-09-22 insertion sort ✅ 2024-09-22 example of sorting : select for lowest to highest and vice-versa amazon\nBubble sort bhari element ko array k peeche ko push karte hain and hame ascending order ka array ilta hain\nsimple comparison-based sorting algorithm runs loop n - 1 times import java.util.Arrays; public class BubbleSort { // Function to implement bubble sort public static void bubbleSort(int[] arr) { int n = arr.length; boolean swapped; // A flag to detect if any swapping occurred in a pass // Loop over the array n-1 times for (int i = 0; i \u0026lt; n - 1; i++) { swapped = false; // Inner loop to compare adjacent elements for (int j = 0; j \u0026lt; n - 1 - i; j++) { // Swap if the current element is greater than the next if (arr[j] \u0026gt; arr[j + 1]) { // Swap elements int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; swapped = true; // Mark that a swap occurred } } // If no elements were swapped in the inner loop, the array is already sorted if (!swapped) break; } } public static void main(String[] args) { int[] arr = {64, 34, 25, 12, 22, 11, 90}; System.out.println(\u0026#34;Original array: \u0026#34; + Arrays.toString(arr)); // Perform bubble sort bubbleSort(arr); System.out.println(\u0026#34;Sorted array: \u0026#34; + Arrays.toString(arr)); } } Explanation: Outer Loop: Runs n-1 times because, after each pass, the largest element is placed at the end of the unsorted section. Inner Loop: Compares adjacent elements in each pass. For each pair, if the first element is larger than the second, they are swapped. How It Works: Initially, the largest number \u0026ldquo;bubbles\u0026rdquo; to the last position of the array. In each subsequent pass, the next largest number is placed in its correct position. This process continues until the entire array is sorted. Bubble sort is easy to implement, but it\u0026rsquo;s inefficient for large datasets compared to more advanced algorithms like QuickSort or MergeSort. It\u0026rsquo;s mostly used for educational purposes to introduce sorting algorithms.\nSelection Sort simple comparison-based sorting algorithm. It works by repeatedly selecting the smallest (or largest, depending on sorting order) element from the unsorted portion of the array and swapping it with the first unsorted element. The algorithm proceeds until the entire array is sorted.\nHow Selection Sort Works: Find the minimum element from the unsorted part of the array. Swap it with the first element of the unsorted part. Move the boundary of the sorted part one element to the right. Repeat the process until the entire array is sorted. Time Complexity: Worst-case, average-case, and best-case time complexity: O(n²) public static void main(String args[]){ int arr[] = {7,8,3,1,2}; for(int i =0; i\u0026lt;arr.length-1;i++){ int smallest = i ; for(int j=i+1; j\u0026lt;arr.length; i++){ smallest = j; } } int temp = arr[smallest]; arr[smallest] = arr[i]; arr[i] = temp; } Explanation: Outer Loop: Traverses through the entire array. For each iteration, it considers the current element and searches for the smallest element in the remaining unsorted part. Inner Loop: Scans through the unsorted part of the array to find the minimum element. Swapping: Once the minimum element is found, it is swapped with the first unsorted element. How It Works: In the first pass, the smallest element is selected from the entire array and swapped with the first element. In the second pass, the smallest element from the remaining unsorted part is selected and swapped with the second element, and so on. This process continues until the entire array is sorted. Key Points: Selection sort has a time complexity of O(n²) for all cases (worst, average, and best), making it inefficient for large arrays. It performs well with small datasets and is easy to implement and understand. Unlike bubble sort, selection sort minimizes the number of swaps, making it more efficient in scenarios where writing to memory is expensive. However, it still performs a large number of comparisons. Insertion Sort: Insertion Sort is a simple, comparison-based sorting algorithm that builds the final sorted array one element at a time. It works by dividing the array into a \u0026ldquo;sorted\u0026rdquo; and \u0026ldquo;unsorted\u0026rdquo; section. The sorted section is built from left to right, and each new element is inserted into its correct position in the sorted section.\nHow Insertion Sort Works: Assume the first element is already sorted. Take the next element and compare it with elements in the sorted section, moving it left until it is in the correct position. Repeat for all elements in the unsorted section. Time Complexity: Worst-case and average-case time complexity: O(n²) (when the array is in reverse order). Best-case time complexity: O(n) (when the array is already sorted). import java.util.Arrays; public class InsertionSort { // Function to implement insertion sort public static void insertionSort(int[] arr) { int n = arr.length; // Start from the second element since the first is \u0026#34;already sorted\u0026#34; for (int i = 1; i \u0026lt; n; i++) { int key = arr[i]; // Element to be inserted into the sorted part int j = i - 1; // Move elements that are greater than \u0026#39;key\u0026#39; one position to the right while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key) { arr[j + 1] = arr[j]; // Shift element to the right j--; } // Insert \u0026#39;key\u0026#39; into its correct position arr[j + 1] = key; } } public static void main(String[] args) { int[] arr = {12, 11, 13, 5, 6}; System.out.println(\u0026#34;Original array: \u0026#34; + Arrays.toString(arr)); // Perform insertion sort insertionSort(arr); System.out.println(\u0026#34;Sorted array: \u0026#34; + Arrays.toString(arr)); } } Explanation: Outer Loop: Iterates through the array starting from the second element, because the first element is already considered \u0026ldquo;sorted.\u0026rdquo; Inner Loop: Compares the current element (key) with elements in the sorted section. If the current element is smaller, it shifts the larger elements to the right. Key: The key is inserted into the correct position in the sorted section after shifting. How It Works: In the first pass, the second element is compared to the first. If the second element is smaller, it is inserted before the first element. In the next pass, the third element is compared to the elements in the sorted section (first and second elements). It is inserted into its correct position. The process continues until all elements are sorted. Key Points: Insertion Sort is efficient for small datasets or nearly sorted arrays. It has a time complexity of O(n²) in the worst and average cases, but O(n) in the best case when the array is already sorted. It is a stable sorting algorithm, meaning it maintains the relative order of elements with equal values. It can be more efficient than selection or bubble sort for small or nearly sorted arrays. Quick sort popular divide-and-conquer algorithm Quick Sort Overview Idea: Ek pivot element choose karo aur array ko do parts mein divide karo: Left part: Jisme saare elements pivot se chhote hon. Right part: Jisme saare elements pivot se bade hon. Recursively, left aur right parts ko sort karo. Steps to Perform Quick Sort Choose Pivot: Kisi bhi element ko pivot bana sakte ho (generally first, last, or middle element). Partition: Array ko aise divide karo ki: Pivot se chhote elements left mein. Pivot se bade elements right mein. Recursively Sort: Partitioned arrays ke dono parts pe quick sort apply karo. Combine: Dono sorted parts ko combine karo. public class QuickSortExample { // Quick Sort function public static void quickSort(int[] arr, int low, int high) { if (low \u0026lt; high) { // Partition the array and get pivot index int pivotindex = partition(arr, low, high); // Recursively sort the left and right parts quickSort(arr, low, pivotindex - 1); // Left part quickSort(arr, pivotindex + 1, high); // Right part } } // Partition function public static int partition(int[] arr, int low, int high) { int pivot = arr[high]; // Choose the last element as pivot int i = low - 1; // Index for smaller element for (int j = low; j \u0026lt; high; j++) { // If current element is smaller than or equal to pivot if (arr[j] \u0026lt;= pivot) { i++; // Swap arr[i] and arr[j] int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } // Swap pivot to its correct position int temp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = temp; return i + 1; // Return pivot index } // Main method public static void main(String[] args) { int[] arr = {10, 7, 8, 9, 1, 5}; int n = arr.length; quickSort(arr, 0, n - 1); System.out.println(\u0026#34;Sorted array:\u0026#34;); for (int num : arr) { System.out.print(num + \u0026#34; \u0026#34;); } } } Time Complexity Best Case: O(nlogn) Happens when pivot divides array into two equal parts. Average Case: O(nlogn) Random pivots usually lead to balanced splits. Worst Case: O(n^2) Happens when pivot is the smallest or largest element every time (unbalanced splits). Merge Sort divide and conquer algorithm Steps to Perform Merge Sort Divide: Array ko midpoint pe split karo. Sort: Recursively left aur right parts ko sort karo. Merge: Do sorted arrays ko merge karke ek sorted array banao. public class MergeSortExample { // Main merge sort function public static void mergeSort(int[] arr, int left, int right) { if (left \u0026lt; right) { // Find the middle point int mid = left + (right - left) / 2; // Recursively sort the left half mergeSort(arr, left, mid); // Recursively sort the right half mergeSort(arr, mid + 1, right); // Merge the sorted halves merge(arr, left, mid, right); } } // Merge function to combine two sorted halves public static void merge(int[] arr, int left, int mid, int right) { // Sizes of two subarrays int n1 = mid - left + 1; int n2 = right - mid; // Temporary arrays int[] leftArray = new int[n1]; int[] rightArray = new int[n2]; // Copy data into temporary arrays for (int i = 0; i \u0026lt; n1; i++) { leftArray[i] = arr[left + i]; } for (int j = 0; j \u0026lt; n2; j++) { rightArray[j] = arr[mid + 1 + j]; } // Merge the temporary arrays back into the original array int i = 0, j = 0, k = left; while (i \u0026lt; n1 \u0026amp;\u0026amp; j \u0026lt; n2) { if (leftArray[i] \u0026lt;= rightArray[j]) { arr[k] = leftArray[i]; i++; } else { arr[k] = rightArray[j]; j++; } k++; } // Copy remaining elements of leftArray, if any while (i \u0026lt; n1) { arr[k] = leftArray[i]; i++; k++; } // Copy remaining elements of rightArray, if any while (j \u0026lt; n2) { arr[k] = rightArray[j]; j++; k++; } } // Main method public static void main(String[] args) { int[] arr = {12, 11, 13, 5, 6, 7}; int n = arr.length; System.out.println(\u0026#34;Original array:\u0026#34;); for (int num : arr) { System.out.print(num + \u0026#34; \u0026#34;); } mergeSort(arr, 0, n - 1); System.out.println(\u0026#34;\\nSorted array:\u0026#34;); for (int num : arr) { System.out.print(num + \u0026#34; \u0026#34;); } } } ","date":"2024-09-22T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/sorting-in-java/","title":"sorting in java"},{"content":"clone the desired repo (git clone repourl)\ngit clone https://github.com/yashbhangale/geeksdirhugo.git assign access token (password) to the remote repo sudo git remote set-url origin https://Accesstokenpastehere@github.com/yashbhangale/geeksdirhugo.git then cd into repo\nassign username and user email sudo git config --global user.email \u0026#34;yashbhangale9@gmail.com\u0026#34; sudo git config --global user.name \u0026#34;yashbhangale\u0026#34; Impt \u0026ndash; git remote add origin ( if we create repo and code on local machine and we have to push code from local machine to that repo) git remote add origin https://github.com/your-username/repo-name.git Switch to main branch git checkout -b main ","date":"2024-06-05T12:24:01+05:30","permalink":"http://localhost:1313/post/devops---cloud/git/gitconfigurepasswordinlinux/","title":"Git configure password in linux"},{"content":"basics of shell scripting : what is shell? A shell is a command-line interpreter that provides a user interface for the Unix/Linux operating system. Users can typecommands to perform specific tasks such as navigating the file system, running programs, and managing system processes. Thereare different types of shells, with Bash (Bourne Again Shell) being one of the most popular.\nwhat is shell scripting? Shell scripting is a text file with a list of commands that instruct an operating system to perform certain tasks. A shell is an interface that interprets, processes, and executes these commands from the shell script. It can be particularly helpful to automate repetitive tasks, helping to save time and reduce human error.\nTypes of Shells: Bash (Bourne Again Shell) Zsh (Z Shell) Ksh (Korn Shell) Tcsh (Tenex C Shell) A shell script is a text file containing a series of commands that the shell can execute. It typically has a .sh extension.\nCreating and Running a Simple Shell Script: Create a new file: Use a text editor like nano, vi, or gedit to create a new file. Name it example.sh. Add the shebang line: The first line of the script should be #!/bin/bash to specify that the script should be run with Bash. Add commands: Write some simple commands. For example: #!/bin/bash echo \u0026#34;Hello, World!\u0026#34; Save the file and exit the editor. Make the script executable: Change the file\u0026rsquo;s permissions to make it executable. chmod +x example.sh Run the script: Execute the script by typing: ./example.sh Basic shell scripting commands Navigating the Filesystem pwd (Print Working Directory) ls (List) ls: Basic listing ls -l: Long listing format (shows file permissions, ownership, size, and modification date) ls -a: Lists all files, including hidden files (those starting with a dot) ls -lh: Long listing with human-readable file sizes cd (Change Directory) cd /path/to/directory: Change to a specific directory cd ..: Move up one directory level cd ~: Move to the home directory cd -: Switch to the previous directory mkdir (Make Directory) mkdir new_directory rmdir (Remove Directory): remove an empty directory rmdir dirname touch: create an empty file with touch command touch filename.extension cp (copyfile/dir) mv (move file/dir) rm (remove): rm file: Remove a file rm -r directory: Remove a directory and its contents recursively rm -i file: Prompt before each removal (interactive mode) rm -f file: Force removal without prompt (use with caution) viewing file content cat: Concatenate and display file contents less: View file contents one page at a time, with navigation options head: View the first few lines of a file tail: View the last few lines of a file shell scripting structure shebang(#!/bin/bash) The shebang (#!) is used at the beginning of a script to specify the interpreter that should be used to execute the script. The most common shebang for Bash scripts is #!/bin/bash. #!/bin/bash echo \u0026#34;hii\u0026#34; comments: used to add explanation and notes in the script #!/bin/bash echo hii # this is comment stores the data that can be referenced and manipulated within the script #!/bin/bash # Assign a value to a variable greeting=\u0026#34;Hello, World!\u0026#34; # Use the variable echo $greeting important points No spaces around the = sign when assigning a value. Use $ before the variable name to reference its value.\nVariable Operations:\nEnvironment Variables: Access environment variables using $VARIABLE_NAME. Local Variables: Defined within the script and accessible only in that script. Command Substitution: Assign the output of a command to a variable using backticks command or $(command).\n#!/bin/bash # Command substitution current_date=$(date) echo \u0026#34;Today\u0026#39;s date is: $current_date\u0026#34; Quoting Quoting is used to handle strings and special characters. There are three types of quoting: single quotes, double quotes, and backticks. #!/bin/bash name=\u0026#39;John Doe\u0026#39; echo \u0026#39;Hello, $name\u0026#39; # Outputs: Hello, $name ","date":"2024-06-05T11:52:01+05:30","permalink":"http://localhost:1313/post/devops---cloud/shell-scripting/shell-scripting-index/","title":"Shellscripting"},{"content":"| certification | hackathon | exam | | AZ 104 | nlp wala (ajink) | sem7 starts from 12th nov |\nCertification hackathon Exam Az l04 Nlp wala (Ajink) Sem 7 Starts 12th nov github foundation https://www.youtube.com/watch?v=nq82V5OpapE\n","date":"2024-06-04T00:38:39+05:30","permalink":"http://localhost:1313/post/rough-work/","title":"roughwork"},{"content":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== You can decompress Drawing data with the command palette: \u0026lsquo;Decompress current Excalidraw file\u0026rsquo;. For more info check in plugin settings under \u0026lsquo;Saving\u0026rsquo;\nExcalidraw Data Text Elements Configure and manage virtual networking ^Kf5VM8Xc\nEmbedded Files 9aa6e99075b4a0d42cebd82850eb0fb0c458269b: [[PastedImage20241218220610_599.png]]\n5552ba1f3407ba72d11f0bc7e360cd51cb3018a6: [[PastedImage20241218220642_007.png]]\n60d93b998409f1890c3583ab27712cae41a7425f: [[PastedImage20241218220721_613.png]]\n46f1bef2211fc2917900b08ff7c79a3976a85439: [[PastedImage20241218220804_236.png]]\n5684b27bccef8a8438bd440c03e18a89fb515f43: [[PastedImage20241218220836_396.png]]\na99c86cd9d5b4076302f0b0ec4257a56a02e70d3: [[PastedImage20241218220927_034.png]]\nd4742d5ebb795628fd8f7ad8249fbc40a470a257: [[PastedImage20241218221013_972.png]]\ne9cca17dbe93c17bf11cf81a18b0e0274b91cdf1: [[PastedImage20241218221044_783.png]]\n9c4e2c0f713207bf8355398d4a30b375f71ebe6d: [[PastedImage20241218221153_787.png]]\n%%\nDrawing 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 %%\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/az-104/configure-and-manage-virtual-networking.excalidraw/","title":""},{"content":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== You can decompress Drawing data with the command palette: \u0026lsquo;Decompress current Excalidraw file\u0026rsquo;. For more info check in plugin settings under \u0026lsquo;Saving\u0026rsquo;\nExcalidraw Data Text Elements DEVOPS Index ^oRJVDmR7\n[[Git Index]] ^bHpF90Sv\n[[Docker Index]] ^JwTLp16P\n[[Shell-Scripting Index]] ^b6qEAFDU\n[[Jenkins Index]] ^jM1xo3Fn\n[[Linux Index]] ^64TIjtWK\n[[1. Azure Index]] ^JWe2xXeg\nElement Links ThhIWRVi: google.com\n%%\nDrawing N4KAkARALgngDgUwgLgAQQQDwMYEMA2AlgCYBOuA7hADTgQBuCpAzoQPYB2KqATLZMzYBXUtiRoIACyhQ4zZAHoFAc0JRJQgEYA6bGwC2CgF7N6hbEcK4OCtptbErHALRY8RMpWdx8Q1TdIEfARcZgRmBShcZQUebQB2bQBGGjoghH0EDihmbgBtcDBQMBKIEm4INgAlACkANQARfSr41JLIWEQKqCwoNtLMbmckgAYRhIA2AFYRpIBOAGYeEamF gA4kif5SmCGAFinkiePV1Ym1vYn4qe3IChJ1biS9xKn4ubW5mfnVpJ4bwqQSQIQjKaTcf63CDWZTBbgjKHMKCkNgAawQAGE2Pg2KQKgBiJIIIlE/qQTS4bCo5QooQcYhYnF4iTI6zMOC4QLZMkQABmhHw+AAyrA4RJBB4eUiUeiAOoPSQQxHItEIEUwMXoCXlKG0sEccK5NBJKFsDnYNS7Y1jKE04RwACSxCNqDyAF0obzyJkndwOEJBVDCPSsBV cCMebT6QbmC7/YHARAwghiE8Fgc1lMJrM1lDGCx2FxjWt4nmmKxOAA5ThiJ4jPYjCY8CajIPMBrpHqptC8ghhKGaYT0gCiwUy2Rd7qhQjgxFwXae8XTewWIwWc3iJyhRA4qL9Afw27YVJT3F7+H7iZ6mD6Egaw7qAHkAApC1AOkODXWUAAqvQq95Pq+76fjyvKcFAQqEEY4i8AiibgdkABiuD6AKVqoAC7TQL0ACCRDKEW6DBLyfRlqQUDmAQ+Gg kR0BmjyejZLgwZML6aDxoeia4qCwYEH+N4AQ+L5vh+xChlCuBCFA1ThNBsHIkICDbqxAASIJgreqBJNo/yFAAvtsxSlOUd7PgAQvQCy4RilYALJ2ZoADSkhsBQABabAAKoOk5Rg8p0sEYIKhByEgUKDGgwxLNoEwHFMcyLNMPDpusUIYc48TjHMLZ7HsazHHMK4LFsib3MQjxoMsczJIlUwpXM/zxBskKJsCoLgmgm7aCM8RNSMaxjM1fxYaUMKa vB2HSqqjK4gSJLEuFiYUlSdp0gy2JzSy5AcOynJZGRCECsKopBdqqbKjKCDyhVipVZdqrqpqSbYjqiZ6pIMYuia3HmpadaTaUa2Os6+Qegh3oIOxqCcUGoESLgKS6kOxBfdwxmlIFEKAoZibJt2vBzGuSQlWsfCJvmFZEfMpXYZThbVhwtbGglsx9WsZNth2wQLj2fbKctKOjhkB2ToCRTi5ApnoKQsp7F5RjEDwz4LI+AAy5mYOZAAaDpTF5VQj D+ZKY/AQWciiVDi/pgLg9hM5zrz2lLi8CVxVlRMqbu+4JthOIngT55hAZRmJtLECaKpcBIUTQr0AFZvdP+EVPJsulTC8fX1RMCx9XM6VDDwSSJGMIxfH8YxnFMo13AqTwJdoCxLIl/yrPEoxFVC7WaRCNfQhwsKwYDAgquis3MughKLaSA6UtSUYbUy3Q7XtXKHdh/KCk9Z2vRdeOj9ddf3fvV3bxU52RsI+qGk8pp/bAAO2rSIOTnbpReqhUME7 DYfw+guA8EvutNGHEDyIgQKeY0ExGpXHTAVciVMITXAQQzGssEkhJDdmXPYzYuadkgagIOAtsKDnWsLccOQwbTlnPOAhxdlyrnXJuaYXs9wSDyHkAA4moEC4lMBujdDyf26JA78yhNeLSEBAC8G4AWZ2OHcKgLwrAAjIy/n/OwrhPCxLKMEZ6CCUEYIQmHnyCCKE0L4Awn3CRNFCIVBIuvUo+ZKLuBsXRGScBGIQRYgaUg0Mf7YR4v4fi6j0CyPk Voz8KjJLSVkqwQxaBFLENKDuBA6kOpaR0npEouMSgYzKATCANQKA/jVnATYz4E5dBZMnRMkVtJTB0quEm8RmqNl6h8AuaA9g1RGMsTBODi5kxzlCcqlVtJfGSH8HKA1+k8A3F3DSnVeB93GkPB6Y9NoTwgFPBaPIVrzxRuPZebIORrzAsdM+4pd5SgPjdMZ5MpoH0uVqa5yM/CfRvsaO+lJ/rWmMcDJ0r9PSQz8WA3+fCwwLCAdGT5MMwVTQgQTO YxdkU4IzigzgTw1gLAxRwRmzNtLpl+EuXBYd2z4NEReJJ5IhZjlFlQxMDtaEE3oXlRhG4tyJh3Gw9AHCGjHnRKQJR/DdFcoFQQoh4iQnSLkXkflJ4hXaJFao4p0q+XisVZE0VG99HySMXo5CqF0LcCsXhAidF7E8icVRfArjugMShExKIrFfHf3haUQJfF8ACUkWEuVGrhVRMTFJGSVQ5LxNQIkr2qTFkZPTiHQoeTw6aAmAAR2HLhJCDQvKVKCh InkdTnDNgmNoTMmCWybmxZcXMiYMIkz2D1aBjZ25N1zvEHBIyj68BzqW9mOdNxfAWCNBZ6Te6SQHhNdZmJNnzWnktEhc81r0iOdtE5+1uSeguadc+ryT6qjuXdXgU7nkvUlG86+sZb6/R+Q/P5T97SAoZRvEFbrfYmT/tCKY0LUawv8aUfGJr1zHFpo48shZ641rpmBqsaCjEZxbM8dteCeYSrEYLMhdKJxPtKEyp2rKVxrg5SwrlwYeUQA4UKYE gpnBCmwKQUKlEB6Bu1ck8VlLLzYXzRIP1lGgj4Bo3RhjwZlDMZVT6ioFGqP8do/RuAjGRNKqDTq7IBjYLLANVAMxxq0CmpvHaiQlryLOOoua+1HjHVeJdaCt9kBPUcGCYJbjsrePUZk0JpjimWOQBDbEvVCTSBKWjWknuxp43ZNDthcOAArOySRMBsAWEhLg4jE7VMEinKKPBPjaEau8Y4zYi7rkgzsQuqxS2jDdhsAqrLO23SeBuRu9Vy71g+PW UsbVY1juDROtZe6NlLwkDsxaezF0LxXegVku1TkHXOVvbdVyz19cPnV4+jzT7zZeYt7CH0QHaW+RaW92kbSJgBaDNAU4Iaf2s1xSLH7cATG/btv9AhEXcCHSlKYnxO4U2g0RHgeVcX4tgsiodGYsrIYQE7SV6GRyYcoedt+kBcN0JdgRphnK/akYk3kGoWRUTBmYKJo8Aczxoc49Kv1uPdwE6J+9NRjneU47xzTzzYFdURvUwhUxRqLEmqlXp0zB mECkStUwYztrBcTYdYmJ13i2Kvpux6+jQTvUU9lVT/Hu1afYR82GuJCkAvUogCk4LSzMlTATbksOBS4o/gdFFqAsonK5qTul2pQx1iHCbllarRU3hF06agZwiUEgfBdg0suvwHmlFGYe4uJbsVzJaXM7pRcOYjpC8s8dg94RTvG9shaM9lqjcOTO1dU310OMgJvE6God5bf/bcrt0eR7rbrzuhvkAduwp+gE++dbjvYVO0Cy7PoFdwwhQjNYj3f3 upe3QgqzUGmYOMfTTFxo5mA9g8aEq/3MFvGMYQclKH2NG9IbDkWWGEfUMdijhhhHmF925djtWwYhCYG16xknfMqX899bK1/f0D/Vnb8VVBncjPIQA9/T/avdnNTYxRCTTHnSxP/fTYiYXKvBgMXG1NA+iczGXSzHxa7U0ZXL1cTJzDhKA4ArVHkXXcNA3QLEjA0U3ONLJMAHJCWSLApXAR8egWUCYQgJCOAQgPYYgSyOYZQZ8Z8Y8QgZ3FLKpdAL 0RFcgKgDLVABYbQLMH4VcbMUYZqdcPuDKc4UPFpaYc4d4JuT7Wre5FYZIDORsZsD2JhdrbCbuM3NOLLTYZFUYQaImc4bPSdJbfPQkDcJIbAQBWeVaMbMvCbFeabDdI6ObdvBbN6NbfdZvY9DbU9VI0obvS9L5a9A7DCTnIfZ+R9a/UfL+H2RXKWO7JCGffIuFGzJMV7FmDcauN4T2H7AsdfbSK4LfJmWCJsHgdtIdJIYrKWY/SHVDX/GHYgchelC o+2GhPDVHdlR/Vhao4nERUnWY7COANgYMeHV0cWAodoEoYeC48WRHMAM4840YEw6uPYcY8w2YTYW4EoYYQ4YaMuduHgBqYueIa4j4u49oZYSYA4F2QZJsNKSWItNYXSIrDOb4DBRYHKYE04yWVcBIIdBKZsfKTMV2Fw845wZ4zQuZcY2Yaua4XpNYDE840EkoFcWqNcGYXpa4MmJYEDdoZwauWKbpPQhsHOUYWYek9oRksAfKZIJcIZJYVcVYFYD 4sAXkhE0IvKdubpDcZ4sUkoCUt4RuUYf7AwjYTYVYJU5wHtL4VPZcDOdUiYHU24yWHtP4FcNPbpBpbMEqc0uKBITMeqGYZ43OBYauB0iU4wxYbFRKdtMufpHFOEy0jORqG0vKF4e084m4iU7qQM84AaPfPqdcb0jQl04Mj0q0zBUMyWAqRuQaLKSuD0zOb0uIOZXOAqT4EqdYf7Cs84sARYUtauVFbpbFLKfw+M8YHOZsYuXpSk3KLs+43pHLJMp YEmVKHBYknkz7HLDUl4Z4KM7U9MkEyWPQ5IA4ZYc4ZuTcXvEkjc54AaeKewg4IdWc9oDBDQ5qD4AqJYNcesAsuErMbQF4HKa4c4f4kmEYp8koDBRIDBf43LesWYIqS89cktACq4LMMmQrMC/czE7siuf8olaYGs8ct4c0vkuKZFXqIUodMYJIcCsAF0zQksN4FsvqTcfKEijQsPRYa4ZcFpHKC3LChkw8mKBwvqTBImFcRDEinSbpFsRKdYK4HBN M9oDMoSkuS4JuDBY4MYBsGuT4mYWKaYBKXimZDs2i54OIXpVrdtXKdtFpc07pHqesVc5FT4DYUwsyg4RrZYQaLMGYEsTmOEqU+hTMHKAjJfcsgS8Uw8l4HqUCocrMP3WE7s0kktBpZsT4FpF092DymqGYPywkl4IdJcey1Kv4c4DcP4y4F4MyhpBcq4bMFYPfFsEqzQsqjKyq7KyK3Uw8v81rFKHOF4DmK4FvT4oKmUt2MKstfi5Sg8nCpsUPCSn BdcLLZq38scwyiqomDYUyrqx0uaktTSvqBw1cWYf7EiuILkzcZhfEvEsyrKXSaBBKVYf4jOIdCYvShtKrPKjYNcFqNgkoFSnCpcTQxqai4c/4RPEi5CvLIC9C0CoE3aiU+PHqbFWBQrIqJqEi1UrcjU3cmixGw894f8tpd4Iy6YOy+M6S4UzMJPD2S4MyjYRtXGmYBCt6ws5II06uLwjOCKma7C+4qslYXqVmC4D4T7d65U4wvQgqQamYXOHOBmh PP66MmZEY80+6hKaZZskYpcBmmqIMtcNPEK8S9WjQmM3OPKSuJuMmMy3s/0vwjmDYBsEsdW1UlYE8ikxYJYBGvmwSnCu2/4B2jmG8l2uEwaTQ4DEC/taYJYW2ktNmduTYa4XLf480smXSHW0GksjcEqOO0tfKIdb28YrMNOjQx2xqTMEsBsdYOkgm/2xIK4T4Z4RfZqQatOw4auMYD4A4JMhKBYW2hut85uq4Vu5qNOktdYXqUuLm92fG32qK/2h Elm+s/tEmYisOxIIuNqjSxsQafuuu+4kPJuRKC4Xi+w0lZKomTQpubMGswqre22/W9cbus+hsC+kk3s3pNuK0/7RqIqWi5YcYScz7fteDE2uEiZBpROgdXpLLf6sAQG84vpRyjBEsUIphbFc0j4UtdcSE4qT4BqAB2YHBwZL4NG44c0kUzQsYJsJcFYPqFMohnSbFUhrMElChuE0YRpMYr4T7TYHWphkht8thrk7kz40YMumCq4FrGu+qIhuIfLd cTSpYJ4yhtcUtKRrKbpWRngeRgygEzYFR9FTh2w/KZ4tcXQn4XqPRxR7woi4x5K0YCexDFYeYP4+SohjQ1PFuZO8Y54iW4YAaUtRsNlZcEK+YIhhtOUhKFcLmqZMR5UjBTJD4IufKMqwB3Rg+sE2w/pBw6RtEimxxkmX0uqOZT06uYMohw4XJpsfJ5wyhzBf85ff4xPcY9tKpuwoUxwsuepzhjwjYaBDBAaMuXejpmp7pgptc8R/prwoZ3w0Z9M2 2KEOAQIWMEQcIbDAQQgfQAMWhZ8VZ5gdZ7gKNLlUIKALEfQNCGQFMaQo46oy3TgkyApAAfS8gxGUFwgoBqGUDVlRCgCqCiyQmfBmGVm1iqBdwkCUJTBUILW4G6hjpTxvJbFykD2cGDM0PbQbEwRbRRXzjKi7WxfKwGlziKnWH3wz3cLiD+H8tXA5nqiWAmP7hzzQGMWmn6y2knjcbCIiOLyiNLwG1iLXTOU3SSOegvinQPSVCWxPXFfeivg+UaMQ sqH731ROzKLO1dERz5BfS2PBVDARk4QaLjDnxaIIWuBwVmHrBbywJ6OpmQW6KpiBwhFGDyhGMamtaP25mmNPwHFpUv2OIu2WNvxZTWIfwx2SSx1AWaOERmI41KAOKOLFj9vOMuLABGFopLTikuHeHyhJTcoSfTayYgobVRLbMWBWHTGWD2CVMLfnu6u7JGOJpctqYaSAzOsllrYBtmvOJKk0IOGkfPp5t0sSYMs0rD3GM/LylosuFaoK0LtRIzgC Y0KWBSiYRXGOGeIOFotIoFIosbCotmHVv/OuE8OJf6k2AzeQsuGODEretOsoY0Ky0WE+y1LMOvdouuAYtBxAbJiKmI0cYRJGJWpCqpMDtrrrb2vOOxR6k+2bKuGeBkrjOSv+xRugSqo2GrirZ9q7f5vaGRUbjinj2DP3dWACbmR6i0azF+PrCq1opykblTOzkuCccQs+OxKXH4cqw5lgf3og6RrGGocbGzCbDeDZJGuVPY6HRE5ykdp47MtMYuBJ mgSLn+IcPNMk845k+4/+N45w+TefKCcGkI7GH+2xRKimeVPI6nv7eo7SfA704XvuL+ByxicpKcpaSsLhKy0RLFoODePmCAzMueFiirbQf4Y0os6LUSAbAruGPqk2DXqC6gr+DmRGLgp+HE6LW+LScMdWHWBi7MqLgeo9OjODJbGDPNJSnTgGoJKzBSnxMK4bU+2uCXGahYrijI/GFYuE9a45neF6UK9yvbiFtzNstY8SczbHZLAneWCeLMpijbLl JeJKi/ofd0jbJfesqzHfaLbotzh6nUrGK0vrGLjUceMYt3t4Ztt25vII4KitegQrUy+i5PZ+sTwPwvZu5wVLWzBi/oerpLt/PK2eOgowRwW6T6g8q93qmGd8oGmaky50hva8Om8Tycqh68th+mHh4CpwtHaU65qM/i904Qe7efJitmAZdzgSofIlpLaa2GZ+FgW6Q8oRIUvyjQ+06+CVIRPlIGcI3rXNZqvGEsKbSRezHqiVIePeGuB5tbNrIShq p0k2BbE+37dzaWCl8fbbP+GmHUoGgKiV7qs3EriavG7TgQxOCKzmTlpqriDJiXGRYLryjxZwsA/ZmDLS7+CymuBqo0PJpyiWFdcd4s6K6eueC8Plu2799ik6PHOD/M6VKq917GN8qMvaZu4zn/LpY67ft6UuCT8A+t9QY7nWF1sz4bVq9z96Xz4SaHQjqLmzEaiJPRMz693mBV/XZJhdKVPTBg/WESl6l/qbkyb456vb+RQ3ZKm7/be7P2/lpSmD tV/bTnoc/rfuL5KHUn7imn/e2raxJqlbMtayyUbJj2Bqon8793578lm++DK1IuCk7OAv4NO367736VLyj7OHs6JrvEpqoOoQ8cyn5BquJzGodlxy8pOZHMAAHHkOUe9U8iZyVL6UTg6fLaiTGu5j8cKvVQaP1XTDNRF84neqI3EcL1VamPdUfmv0g7PkcBvSdsoNUIHICiyTFe/p7gFL2dSeuHCCrQLwEMDhqTAnLGgytYId6oU7TPiWj6r0CCB/ AyWFny+orAfqZLF6rAMkEDVpBfUZAYkCopGkvgJpGOioNwFSChqGg2QQiRDp3kGwD5VfpwP07cDEgb3EliuAw7DtswsUFRkOTZhGdfemfewT4UcFktq4SpFsP+WppNYWk2CJSlQKRr6kHBObAIS4KLKc1SyQ7Gqr4OJZxDnBQQjiomRSh5RbSqZVIUSyHKktMhTpQ4Mix6ZFURi5wQobEJKHksnSV7YDLezc7YcbBjnGgWkOKFOCGh3ZKWr1BYaX BvgRcNoYg06FFD/BpQ7shrUSjZhtaLSEnmMLsETCMhvQ84sDXNrmMfKxLWoX4NWGBDJY7aBIP6Q7j0tq65/HwSsPqEHDphHdbFO0haZGlIh7Q9fuMLqE9Cbh6w5Ckp0Ghn9i4hDS4e8PiFKlmoFHfKDMEe7aUWegIvYdcOHZE1HeNfNhqjVWC7D0hcInnuMCzAEUOYK4JcB8DRHdDgRlZRpKETeCokd+KwQkZMLWHtBGaTCbFhSIIzTUAaSzRMCs 0NDrMR8U0bZrsx6D7NORgQY5obm3BnMLmVzLsLc25BRt8ADzJNAUgdC4A2ANQLyKQAACaDQB0JWGeYABFZQPoG1jmRiADQYgNgHBbyEgoULTwKoXdxRQG4dXWJjgj9wg5A8JaJfOmHOCekyuA0awoekbYxd/gcyVxn4TXJSBOsxoeYLFDgq0soGi7JDmNB6y54giMRAvKEXCIjY+W60fPJNlXgzYRWteMVrujSJygMi0rLIrK22zytdsSrM0DemK L/J1W3I9+DqxlET59W/8VSEa11YIoCEQ1JsFi335QZbWaYV3qBltZOsukKnIuA0kZaesKUuxONjSgwz+smxSOFYnfjZRht/2Ebb2K2LFTf5CEZOeNocSvwnFbBabGtrRWcDjB7huhJ6hXX0KDikG/5ZFDKUQxLgFS1VXbryWB69Qh6z9CEVL0m4q9VgKTL4GuCvE1QlOzxTcMRxzgxMk+PSLRv8RaRZR/i5NK8RghC7OCEe7wDmIlE/5jkPgCGNB qfQG7fjgupbNEvKUrb1hkB0lHKCryE7twfcmE4CdAlR6flVGTpJslxVbJJQyWmYNibFCm7tw0e3EvoU0JvZ91Whwky3uO3EkON1hWI2YZZW9rl8sBJJYuP+RwSrsFK8wC4IqUOEcUi4GNeqniIGiYT3eJ/eqFlG97zAQRCJCiriNmBzDZhmEmqF7VCJkwAuuccbpmE0Jslu6eJe/hwKWGWcuucUJijBIKjD8eeCJEsEaTJiWVS4owsnp8TD7lwaS zSZFDrSVJFRYoBUD0tgmgH01vxmU2MZT3eDe8LO9HfAe3Fi7YsIJ5UuIGilMJN8jqjYfKQlNwZvB8Gi5K8f8X/JNRmEvxQBgkyoZsk+6YtDiRuEGmtSRpWlDcONKl7EMNKPwPhrQziiDSG0r4hpESXiglRh2R5Z4LZPwGrgRivNKIV52y56Dgy1tTdhLSGYhCLyS5QqH8EWHpTLOqVZqNMBJhlwJyQ1KXs5y+DPtoJilDOINJ+lFT/pMCcYvAkPL FM3yXwMpqyWepQyMWMM1cHDKBmIyG0TYFYMiTq6KcMZbwLGQDJbC4ycKjTA4Bgi0L1QVOnwUmb9NbYUz4ZE0mZoMx8IjMFa5U6GX9OxmAyEZ1M5LjBTS5YsEKzM8mTjOFlOdEgGNT4E6MSj5RKBLw6gRlP5msyZZHMhEgsKdGtwhk9YQadFwBkM8GkIY4GbrJdipdq4hsi4ZpJ5L+jTZQY82c2mBk1RfuX5MtOa2xTGym2gYomK7P6KIyPZ0YgaL GILrXE2R+xA5lyM2ZJheR+APZrHKFH+ZGCfsMUQYAlE3MTxWkTiHKOtwVBOEFANWGqNlD4BhwxId/GqOYCPgJgCAcyM4GwDYBdgFoioFaJhZqFooCjNuJuBZqAUlJkADKM2Dwp4T1wu+W0oPIgCx56sCeAuvDWLoISOso6NABcASDaEcwraIDgEV6zFjp0ArVMe3HTGREDkWYlMTmPiKYEa8MrIsY3iuiStVsd8x6OWNvld4qxPefbL8jgj3oZw5 RTVsCiuzj49WdSaEA6C7F7iexBMaqNmFJpdSHW4GKBKGLXx4pt8qAZ2u3AQxPjJiXrKHEeKXEX4KEq4iAMjhDb350c24yAM/ggVf4diP+RcRAATanjGSEpVNp2zVkSki0L44Ku+PultYk+XCt8ZnF4VfiHZ4jaLktTGCg5f6OnKXiWwMnUSK2Fre2ddOQ5F9fOKJALlgpKBDS2prpT4Gh3B5XjPKwFA3sXGJTDIsSF1XLCJ1PKL4t2342qjJXq7D lK0vUXvp9QuBsljgFwECo2CvFXBdIyeamuRXTwH8fug0Q0pGXGKdlvxWZH4bmRgkNRP+F1IymYyf651vxAUzumXE8W91Q63ZL/mWg56/98JRs78XVMzjzAVqTU+Me0HAGykUojVRKJhLLhuCfehs7agDlkHrV+yxlbapgJUVaShpMCXOCsDLJUzzixAy6mQJuqNRMJ9ferv8G9qXB6wHDbslMtIHXUopcyiiftxLDQJvaslBllorACOLGJWlY4Cx OeCYTPKnvRDLNwwF09D+6YWYfMFq5lxMJ+lUXh9hobYILO9S5sHKSaUwCKJMQjuPWE+zyUKFTJBtDXxcqMJwRWbNiWz3Dn/BzGbXOvoB13qWCK4vuZRews4ZHDdJXoqcgVAIlYlH2q7VcHllZh+KKJ4dfqucFRLBkZatS7RWop8njFS+JYT6VwMSbQd+ycK3OP8EapJ9bpxLNcJYUzBpS+VwwDmH21/r5kgOfwKXp5PTCVwI+oMv4B5J0hrglqpH CFYZSl7iKdO5nZ4mBI8lRNfK1wF0hXDij5ScshUcJmXEuUEiKJEyNpvHk6ndIO0hw49qINMJLdtGLIglY43o4XAWGRdP0t9gbYCKyWQiz8TKvPHDBw188qNf2ROVI8EMR0mcY2GJ4eT46gJfQmJQR6VcBFGpEerfRGL4rwpKawtahJYZGVceJJenoi2Pp4lpuBa2Kg2txIbhm1PJTNnlCuBFQeVcDJuF2oTrFqm1z3f1ae3e52Tnhtan4MkGm5XV AGPqzLlBJKgwT4JJHdYB5I0L20PxnhZtlg0dV2SkyZcJMkXA8njBlgoyq1pCX2WUNviP1UIjp1fFJqOh4jeVRnEVXOKVOlDE1cWmVk6cnaVkxIInU+BZhzOzfShtZNbKsxMEYHKyUrSU670Yy2bShlBL1WkwtKtsxdV9LlWHrWY1UYVXlUy4VSzFVU3KarKXXp12Y5q9MKBXGKVcdI4fbKSSxS5WTmGfawEg+UWBsaQalUnKdxvpW6rhqCXH1XFB SiVcFpbwUactNLi8rk1lJREt4uZUgMVwcm4aQpqWmdTmpoixJkTSFLtIyabwaFZZ0fYwa8oOferttIomgjROg1MGllnyUklk+NmqvvZprVEbASCQF3gRgzDL42VVm6rmE0zAwkGujmyDYFtXDBaXylXWFWSvQ774sOmE7qKimY0u93WFXLzrtLMWIY+pFTSyY5vjpDkkSz9MrklpyyFaDpJWsKX5u6jpDKtclQHsh1unKM8uhkkFUZuGCfsllGAi GiEzHo3SAtd07rQV0c1xALyDYN4obQxqVcTZsXF6o30S7TbJgN5ebc3F9WqKfOhJDRWiUI2yri4OkctnhP2lzbIu3nBqAdv85HaMtyvEzvBM+wMzRxjspCYats60dHNd6x7rJWk7PFKunk4/niJt4IcMtf2nKADsDpA64SGnPEh10JItdIdD1aHTTFh3jc0W7GpsG8v+yDVgyvmk7fdWbDo6comO9TlYuqGBjd6NQ37Wjpvbk7XOlOxuNYpp2eiw p0c+NinI2ZLF/0ic5OYKIYJG4k5SIcUWoElG5z7m4WRNIXIkBzAdREwWUDwCEDwA1YzzVSCMAdD0A9g+gflNrDmDzpTYChbVsoUoCwsoo81d2vQgU1vLPhQ8oYPdQzDPtelZha1jPIjGvkvsTWcps9QpYZJaqKvF6i6tI61KmWgRPecES5bHzeWp85dOfLiKV5ZsBY+vDkVbzpEVsR6MsckU2xp6IAeRb6J/MOwlEgYjY+OR/DHzdj30k+f+DUHA VNEaiprAmAy1cawNcU9cJVsgonFwQuS25WcVMVwV7FSg5+eYnDiIUkLFwZCojE/kjYN7tisbI3IwoDZ8rWFmE0dveo77SrsRkXZdqaq1IlQ4oBvK8YcCdp/im6VWwTX02wn75cJ75HBJhKR6eFqSDvMPJmBq17Sit7aBrZ8t9Idw/iAJQpiSSbgZ1W07SaYETDpV9btJrrPSSvzAnqctBm4ZVdP1/Yqbv1lnZLYMyk7Ia4oI5ZKjFVSjDbtyEPNA 68Iykg6r1FWG2bLPXLlDd20ZYUtRSvHrBdIu9VrkuUgqZdpgIkpvhF2qGNbZVzJeYKyRM4cl7N6taShdIhVZY7JzUIxVoNdIg54OJ7dWncLGJoqhkIOY/RdU2X5ZtlmXcOtiOGKGM+5sdBxZ9WLoKCJGf1Yds4HTooSOS7cakn42P2H8a+ubHurSQCYlhdI0FM8lRWAH+KG0S+f0idyDLdIsGjSGTS6uHJN8rx7cPCu4fqglhPBWDKCgj0YoEzym V4ww5HUb5R936PJQ0kcBRQsTZeHXHI2bUhWek6ZlcBJoE0kbNlhVAkwzYMp5JX08uhHXBi13tUmNnGLwYMe4yZnlKy6/ZE0vlxGGhbAm8sxwxCOg191IJPUv3KMQH6rsGm4wbNuV0b6DNmwLSrETQ2E5NRNSDTZJj5LSYFZK4LS/GacHukBy/GDTQ4LTJS6tMq6dGvzY2ANKFVvZO5KY5pXW6zNuZDtFpQlJG3AYCS25BpqHOrrhyzF+UB/Rsfqo sb3psmzhkNMjyGCfg5aUg+rMSbOdqWAzZ2ouwCYfTjh0CUSiDlTJfqyDuJqlm5s2CEmCSlDRtkTHfJTkYyeVB/V7tKbTISymvThsJVoYcxGlKs+xVAaRne7UZvJxHsAfzK6DDS37TkyUxRk8mKm0pktNOMe4iqWsvsiieKe5O+6+TjjfbqsqTy5Lfp1gpdXqeVMGnEeZJeYKDRAZPFjtqmq0z7rRmGmtJ33SynfRsqZxFTyMt01KcoYztolThtJs IJDWWmuT1p907aZLhxVqeaHSGbqejOBnVTwZ+wU4MzCe9Xj/piUyqb92cMpS7PM4DIZaRlSxTqZyU+maLO5UhamHf7ODSJ0umqzBZj00Ua+VlcflbSQdHmf1OxmX1yvfLCKr4rrBsTHCl8kqbTOFnHGnZursRx7OoiUzU56szOa0lzmYSXiyPIsK52QAORazVZvHNYA7Mk5/InncKPTnJJM5lzCXTnLuYyiC5XBCoNrEICcI6gkgQ0QsEkBqwjAP ADEEIFXCVhnwqkB0PgU4ypZFCgQaFubq7lZZrjbST8kaQL61pC4nlP4r1DJb6Fvyvo51tlBMVHUGoVJf3W9kP45lSdK4RYEq1WRJjI9KY/EDwF5CG68oGYuPYvA5bQBE9wrRIino7x562Wy2e5JkRz3ZE94lY95NWKL31if5L8cvS2Ln3AKwwchOVsAlnzNEAM1oVLnTPTDt7V5kveBTBkGJGJK6YtZ4BDkH30KR9CxJhVqwn3GhQ25CmfbuPkt+ w2MC4xfbnKTboHV9u3Vqa+PjULDE1NbHBgoODWT9YGNVX/b8RS5KNADYJARYuz/H5QhOADTrblwellxe+JA+rrSyOlr1IzX0vvriLy537UyoW3aVWj/pPEzOzS3bkIaJgLmRisHJKucUHXXs4GHHW0uOdv49InKbrcYh8EBIJNeeCgrkolCK2fcjNDcXATRy/1Ew3NwM6/c/rdZ9cM25QhLsWgNpJLDyrU5rkxTa7VDkzRm4Go1Dx3mTRlT0na4x V67tdDrbRkoLkeHMmHkoE0y6y12YoHXmz6Bnw1vSaR/Sem9uiCq9b2uJS+5n16k72WjXjGfF9CBa02Bwkv6VrN3eci3CKx6zsz4nZzmDmBs3WwbOJnwsE3dhgncR7cKXkDeusfWgu+M2bkTLhtw7qZi1smctZLBJdJkYsrRvBTptzlzuNJcqrbLeN8q/gmSZKOqq76z9zink6Rl/Q9ik1nT6B73hR0osBcUS7wHno3BGuk7UUNq2W9SepYBanKEa plZgz9WuxGzsElKD8fysC3e204vOAfmFrNX2grV/LA71xJsoPK/vFk5bTiokxkBv4lpOftA0WmvpiGWKlTyAqJU6eggl5TbzjHP07eGjR3vSarQRHb+dhIMRErIatcqTeNv8juTsnLUxgrlTKyuyBUoi8rZlYIYH1yW5CYm4nXfdleJYCyQyN3bg9UuENpcGGCTXy7CZrLtojO2tvG9Ajwp+ELGwGPLlL3x4cSxJk7XG0jWBp4kwaDhSFeJxvF89 QrmwcKzd0y3PBstmpf4ictXshXn2YV/4ndRqimbSaHKBTZeJu6M0MqblL/ePPNKH21ex9je6fdvsza4LmiljQExfui17+79/m+eOLoZ0qSfdwOSTbhL/317cw4B3LarLB0U8cFD8k2EoaT2FJn5BhgzSXrg9lp3tQDZwwwecTlg2D2+/rTobvkVqmpSLlmtEkzch+s9w8tlgNpUOZaUZZ+8FdfuAO4HttO9RY29yeKRi/az4jA7fu8PyHjcSh0Kf YfzIO2ODhVRDwA0qrDyxD6e1WyYdu8v7inRYIGTTyf807W1eCiIxaQM071B+k0s+yKkGPkNRjpnlnYruQbeKi/ZuuLQMcfBo7vDAunHZhEjMMwUKgG5KSjveMqrx9XrXdbooU8Ez4d2nu44qsx3vHNVozd30RJp5jgRKM4L7dP3+2QcgdwrhsY9FB9UyqNcbk7bhsjFXbK4eTjMd2uXd+yoWsp+1cqddWcKAnKaWiUi0fA5H0w2dZnEgEW26OURn dXBPukS1hry96BJrY9K0UslQU6u6FNVt89RrUziaxE4RErdZujdbdWM7VsTOxrrsVZ6GuUkg0taiwHWqFq3WEdYJEI0Zxm2CN+kRVgZR3g6uglEcbnpHbdmYOdoWCIVQ6F59ured7qBD54uQZYb4a/UUuw7S58M/ef7rduKAswmMT8ExqoOuzxPJM/GsD2JShShpKqbeUASgh/JNqy7f6RVParRE6rG0xfq9IsnN5HJyTDye7cWDti9g1vX+G0uG w9L5+gMlop98K2Zz5ajOIuAJNGnJLzq7y8pWgGaVEBhJifrpf/jGXRmmKMtVJqGT/9FnOV5y4VcY0g7fKhHTAlq4vAOXZ+3Jzq4AYUGxrTSwOqd1kF+3tXPLny59ps4bgaOrG219k/tc3qmXqVftllEHbPFh29d0u7lZLLTsiy9VsTmIYdsQU1HDDsQZNeYGO9Gor22ynRNUfI8p7cbzRy1cSFZn8oZDMkxPYzeYONHH7M2hSe5l+VQt3dn2Ylf7 szOsReRp69nBscM8M7Jj7OxKWyxZR1ibDt/e6/lcB2zXu3BrIMk/JCnw5GwQl1m2dsVPSXLTuco8cU4lQTrqnNB8bZPZ9Og1z7Fm9BVS7s23l43F7gGrNug4d3N3Irs2DOHfkWwYt9oMe9Nv9Pg183V8g1FRR76coII3p4GvNvPuvu0PVJkdVbYTK8OyQAF9c6BdG9ZhQyZTtmzTfdkJbtZfqBuDIY1Vz7R1EHmVzoYWdpe7RC7rzdg4V2ZtJQ+H l7ScOrTubcxq7vA51s+k7yar1Ei8Axtdc8PPN+YwMqOfPkAlqEpMk7UroS1EPJnA/Ch6zAV3z764BC8BhjoXOwPVz3dfBLhfJOEj52ky5bWFpfuTbW739+e6U8zbco1FCRjb1C0PutPZ7yplvcPWg02YS9yGgO61dDuHXSnyvi9QP246Vuw7TVya4ZfDunPw0pZZHXQ3Dtyrnj0Jz46U9Q7GdgO8bjW4Svln63Ld/3r/TP4ntwDB9l/lvyv7lcb+ yHeK0lbi/YJs35PCynMh9OIYGygVKOyzVV4yUN7hXiCgty9quV8SSTAJp579z7TBbZMS2yA6q7h3yTgvSLsF6q/9JzlZS5J60v7QDDmwJlWw0G7XYH6QeDmozSHklukaUm0FMtQKVrf5eiodXsAN26/JMI+3thsRzw83tHW1Dp01sinks2neEoQD1azwbKr9oLpP5PHsW5Ifo94XibldxDT6laNi7OnRpWXdDe1XyhyU4OtxXjzvamShjxnpnbbS 8uekFtAaOYS6fxQ4nIX2O0k4ifKvcsugzlyl3+XBPKr2P8J5x+0VOuqOLruzpj5Cdk+AGms2GYDLKsk+En1V8n+FP+Djaut6VmH0E48f0/EnnPr6Shw/31aFSkdwX6T+F8ANMDIOBLtnH9J0+ZfHPuX6hwV+q8r3rUdZXa4c9eujN3Pvu7z/y4ZXU70v9n2E95ddde1+JOlka6xJZXg3Td7r+gbqsiH2STVv+1w4Af3eJHRmgFZAOBXoOPv6jxh5 8+PK3kOilg34Jt72l5e+7BXj9ipNOfqSpjMXhP0ld28ftN6rrM/n0jeLXbcvvdrP/G4if2GdazXG/Q5Ogc+/YH538vwlIYYdkUpQ0IK/cO4d++G/FPnsmbSWWk08HKefhVt9i+J/jg8nbhgu02mV/AfDdkH83fG81P8P8xy/XPyd/A+Q3C/iJ2DxC6Ez4otN8bkG438u/CujxrlfDwkp/rxOGfkv/F+ScCnhHnJGjne5jeh+s383XWRRRHqDI9CR b+SZ97L8e/EO0f46WHMxX4cPWNzR5AA8KUwQztGThA1/saRkzVIAmezQ9j2KthfIRGNxUlgb/Ot2SsW7Svg6IGPN5RME1/Eu2P9W2LfyACh7Ci0k8x7JuFn9nfSgNd8dbeeys9JyETls9Y1Ef0z87/bf2a0KtMWiq113bgPj9b/fAOSdGaZtDW1pNJanb817cR278YAhjW/tdHX+xvtJAw4FU5sWfN3oYsdO7xPsaPPGx8MoNMhlg0X/SzmL88A7 Py3sJBHe03Y97CwLYUYA44EmRhqY6mooLAuhxR4w/aAODsHKPKgN5bSDjmKpHfcgJysT/G7mNNDuTSgaoYJFX0t8wvbf259/GHwlGJZkcTlFc53cVxu4QZPulbYs2K9xOVoXQFwU9gXdAwqVMqRqQPxQtXD1mM6nQj125ZnLunmcEoC6yaYrrd61BsM2GqBgZKeUmFdZzeMmy6C9eDNjHJ3BUZUGQ1ORGQZtb9RGwD8zBGUkBVGlJrH59BPKW1+J UPWq3Y1NLfAQU1PsIyQQ9z1IT2lstgpV2+IV8cqjZR+/RZ3VsMXA5yxccAqnw6lXXCWk88uXRVwicxfOrRa5DpH0VTtbHeHw7dbaZIFw1PRCXhAZh/MQLwDx/FuxEkfAhhwkl7iFANLcL3DoLet9rJAwLY6/RQI/tlvWTxhcgXDQIicnbHNlHVOSULWcCvpVtVZoDCB8X0CcQs7zxDt/dfWJgXKUTkuVOHDv199DAq8UPs7xUGRkMq0EP3/8w/Mh z60a3fyw/F4tIvx4DxAmwL605vffQ3YDeOPx7trAvwMENDHQMjpCZDLHVwCdvTUPPF+QqkkFCaWE5TRYnfebw3ZNKPb1JCR1PNjWN4dK0OVDCOekwisfid9QANZQ6EMNC9vTzX7Rkpbbh5UuQhQKZCjAiUidlk3F2WENyuUMKPtww6dh2CTrPYI84fKYkJ799SbQQos+GU0kpCy3HLFMlFKVinOt4wzv15Cmgqo1RpiYFfF3oywnkIe8R3IZ1KDR nesPr9mQnvxW8FeOa3W8VHZKgMDGw8bziAUbMPBdh0bDMJgDDOUEw3ZibcbipCBbV01XN2zK4lyCrZF5RfZmuDiQnDg7FIPP8q6V21Tp5HKIPVNsWG3lrJuKb325D2wiMOioPbAr0p5PCKYwHD/fbfzKwA+ePlXJE+Ihzf80ecUNfD0PDALXpYEbAMcYUQ8PwICmmW2UJ8SAxHjAi/woAL6hNtObSGZm4M0lr8rw3EJvCgaLQN+AOyA4Nz42wzCL uo7AlcAcCW4CwOvFGQrvw7CYAlpAC1c2Q/QODZgC0OfClA4OxM0SaUGT7lYrURyoiKwyQO0cmNPRzdccvOUI1C9vUB20C+pT4D0D7KQx0QDVXSnguBFaUtBagioFBxzgRAltUq8XVEbwqEJIkwNQYzA4dQoihvXSMTJ9IvWikdsZGRzIpunEkntCNeMdQXdnyK+nvUc4FshPJS1eMiJdh1JyIpDbaXVUrZRnQ1XqNHI8kNXYVIpB3UjnaTSMy4zI xiQsjavBmgk1RKXKD/Y5Air1scFI3QSUiJItgMAYOAiGmXCJOF0NGIbQ90JbsReXpBk0OOXQn7d8DeSOzZcojAQkjA9Ycyq9SOQoz0pfxdrwj408eBhgDrbU8K+Bzw0jiPYTbQoKKdW4RrgYoMQkGw6406NF2WdMXILlpMl+Bk1CVL6AkJbCPnEdyWM8Ga2kXIlopZw1tVopoNJE+oFKGTo0OeDwcjfIskMdDx1XbkQjpvIziyp5Seoza94ofqOi UWAnE2dIkpCNQLd7InkhpCcog4Najt2Cw0zArDCFxeo1Q7b0T8FQiJwcpsUEFnLhd2ZFkRjR/Uvz28v+OFQ9IPsJJjWUPNKwL9DeXRA1oZCsSmWbJCIxMKZdYVUCTlJk3eGWQt+wviMHDcfHHSLD8dR8QuB6Y6iKwie2G3zEo7fZHUFj+Ir4ItdyKJrGtdIuViJojRfZ4O+0RIkkkVjhYsEg5VkSe7SAxJYrmJ78owgOWDFGwH23QiwwoWIAZtYv ziSYjtfWJfDDYmWKoNk3V8Xti2IvVw8UHyIrAuBSrEUPodfwmJQD9kwwrCJIOSQ4PVjOYh2PCkysbFl+8U3AYzS9dubg2RZnvTaze8U2SOPdjzxY615izrH3D/9/Y1AKaDG3R62joW3HAPJix/R4O7IDvXtxkcGontnX8Ig5gLo4J6SpWqCe3Vt3TtjHWBFMckbRozI84OHQgSCvHNX1yCqbPf2rgD/Y1w+CfPZIKFtr3UWxOUTPH9zM9/opGkbZ 2kHhmI5IKfn3Gd0XfZy1tCuXWUsEzGVsgnZ/nOTxGc9o5J2ZNKDXhXUj16I4NecIPMoMK4F43IRvdsvcW2OCNgkT2ri5yD2VGUEeW+jXpL4wkLfiR3D2W7DvTLekyDfI8pw6s3bF6N6CNnFYC2dFosIKB9m48uyTjegptH6DzgQYKhD1Q/L1hCjNYIXUpi6WmmwQC4hEKgC9vGOKYplOeOIB8O2TOKVi+VYxQh83KcxX595w88V7ZkSAdjfoh2HG N4Ck/Jl1FjEdQ1x9DSE5GKND0DEeTJkBZNmSNtkqJUPKi3Qpby+D2NLKW+AuNQxnU4yo9dm0SJInDVShwQwmRoM2OExIW9bQu6h0lTVfSXgNnQku2tCzEj0LfV/9GK0G8mo4dUhj8uDyhc4WsTDlwMSvPxOyjmowJOUiog9bisdX2bbjN9GoqJICSIlIJLRCsbcmyxC5I1JMUioYpGxMICZTQy3o7osGP8T8kjJPxCX4+T1bC3EvfS0TFvPbwfcH Bc9nqMDQhRMYS9fU1xd5bDDpLxjp2YJyQMrSWI3qNvAzNwDj8Y7UOXIzQqB1AifwrB0DjUYoZKbARkoTjGS4IpZM7DjgqpWxlr1BkIwiGYpTycTYDc1V/Y3YzhPPEAwlsk2cNeeQITDLYx1xywu6WWJtlXY9N1FD3/JlypjkDWmNX9nxMSLISAEupVhVqoImODISYhJhpCgQ3uM7dTBTcgQ5caLUnG53gz111dzxVwKHV2YVdnNsbXXXw9d9fdFP QN1nOYXQT9CTBIKU2fUeKt8mg3oMO8UPeuMDcm4xuxbiR3dIzR4J3Sumi9K4pK3ITt/XqGPIzpQqnZJMEe5PLCDYmAKwkSvVJhagCZGl3YTDkx5OSdOZbwmGYiYJDAVSLYqWKADIxT2RjEe7SkI4TNYwGya5OgzEIpSM4xVO1SYA8jnJERuB3ghMPkwuNRD7/ewUrQb2I2hr9RA+RN5TgU4tjvDdvB8O2oSEpGN9SoPeAMKgFIspNf9PkhhJqo2e AN1NiZeQdENSrUiVODsaAiT09IpPceyPClPEiN3tyIxOIEiEgVQOY0lyCWgESEHNDWQdYo3fDFSGwqOODtf1PByVVRKFeyNSrI1h1siaHOhImSi4yQMg0jImDRMiTlfpL4CgAu+z41yzZmJDTcYidNoiIvGHWZ0K4wFKriK7aqPxI53eqOHZx0iQNfDL+Kfiy8LAvdL5SgAu0xbgFBQynZjkQhZJdTkg9U1zYJGCT3UTb02NIHT+UoBPaU3osBIB C23HuIcd9oxyjpZIVPLBLIR40Lxx8e/b6xfJXJCPBd1p3IdUQTmnD9m+FSYBJX+F04+92/dT3AZxejJDJIxkNUjDdxPcn3HTxJCmhbFJH4xiCzhXjcMv9woTsha0jyEUyERzAA6MsjPM9GMjmjzdoNQqFoycMzjPXieJXSD4lyqdsi+oNPTd1Xi8MihLWtb3dJzoYtrfFMHcekg3zWcmyW+lNjEAz6K7i7HBHz7ijNekWWlrot2Bii50iRLPTwpf DnA9ak8aM1SHk61ODs1pHhltl+GDzm3CFw04xlT0mJAXNjHM9NIXCoTL2QjlX0nkg1jCuEuAsJNNQv359KItNKbSrbT/2spMqH4gs4q0nWyicw7Gnnsz3vd9PvSgAzfg74j0mfhOUj/HBNB9knVwMOpTyRpVOoTlYLyF8x43TyQiDPBbTQjKUi32pSkghCKXpzWVpDZgn2MASpTIMkXwFsBVUjR6Ys4BQQgyGfW+3joZgZOlvIxaLaMmVuk7z0c9 t/RBzUjLBVH3rS7PLz25d1MydKHT+rEdPeALA1FMJSFHP9SUcCHPsLWyCUtTKJSdbAKSkiIHWSPN94nbrKgzaIgtLIj3WBrLh923WFIrtleEfmuDuKfdgbTrw9L2Kyd+Y9JYjO0r7mK8rKZjheByvDRLsSKonRJ1T5ZHBEVloBEdUy5vormmeIBo4TNacl/Nj14Z/kgdQeiHQhlkiiR3DulO1ofWBi68JolL1dZpoqgPCl5VE7nqtGzHjimN94la IeCG3COlLiCjeozFyzoiXLwTJgCA2XIiEgZBOi7gw+Omck43Nxrp83bEVBjPiB9ymj8dGaPhctBQ0hzC9BDrJJIjcnnJNy+cr6QRcYNJJmJYUXHkltylqe3MpzziAg0UMlOFiX9ILQj3Pq5XWB3K4TPqXF2ep8XOqC5ymOT3NDzvcupRSUH+CShjp6jYPN5zE8pkmDjBefYPTCfImd0eimc56KDjySFMNDiDg2w1JyOvCnLDcWSBqyjdWvXqJ+jy cv6O3YfvFhOlUE4kimbyyczr0GjHctw1C5ZrLwzkiPHYbySjfuD9k0zhmW93152tK8l7ya8tvJejc/AnP+wC/SCm9IGc/yOZyjMzelgzTSUvkCdMoWdWNyE8ujnZTx3CHz4ZY8/Enjy0ULPLoo8TOk0P1CSVbJ5I5c+4KPiL3U1Pmj2uNijDplo+XJ/z7/V92fpzKVdlmE788/MfyPKe3k9lIHAHnqMEo6r1G82okXi7MFzJvgd9RI30M6Swcx1X y4QpHul20U2CuwkF76ECjbJJFGHKIit7M7WpVVPK7WOkwIxRNYC9PLbRQijPCzPECrM9iMs9Co8GmXteCmEL9S6KBIxFJAVW2Te1GAigNwSqs4jycFSPb3FFS/07uPsdEfL7kzNZGMAPiDV0/ArDTjw3w39xRooaFyzLUrVMCyevIbgqxC7atTmTyCpGxBNCbGcNPo5wujixEb6QMiKgejA+2RyjrEyVOsSw/OLzSSQ+TNTilMrDN4iEsrOPQMNy NUmIM8aP2PoTFkxhJ6VhSOZlwYLk41MlII8/fCXJSWGPKdTUigrPClmXNgyDI2XUgJ9yRsubKVcfXNhndov6ANykzSM7dy4zcfJmPHkGof4DZiEmEoNfjbnJl0lcm4MA1pUBinaKGKb43Hyp1VXQnxQkHVQChODNg0TykScSMWKR0M4HDxY96ggjw49yi6RINd7fHD0f14bJmzhSG2J2Ktd7vHD214znXyn15kUJ/Ju0kSG2OZVP3aKhCT3SJjlW TFeHy2tjDtPWJ6pIrL0Jit79Hy1SsFPU3358LeWINAlf2W3h8t5fbvi19koY6QQ1PeOyQ7sXi+TXakorZWQmk1VObQ68tVXIqo1ONaqSMScAyKUhJmNX6X+xStQ31pLopaEkX4k+PRJE1DEsbJAcLE9dgKgIQmxLAAKSgxKpKeShB0CUbJL3hxKOS4TWo1RNCJi3sTkm+jgNzknAM5L5S7kort4Q/tOpsx0jUspLvCcUp1tX1P/WitP1WUo41RSo 0uCTwJH4vxJVk9zTBIDS60tRJ5ueJJZVEkw/X58RSmjTdLMk3a2yTamS0v0S/SxUvG8ik7ylJ1SkzNWJKNVc1Xu9ciwYrszo3Oij5LWSFZUYQMlapNszr41MvGJJS9GOlKfeJ/OTK8yp6WA1CoDGhcc9vfeI3slGPYMzV2JGOjAkkSo61nVWkj7gmlTSqKw/Vi4CEqMy0XesopNzWWRUmQfGEVX7IOJILlmCEbHxQo8ZeWp32LcigsqA4iy7EpLL bgvZxWdxC8ElYpWShktTKv8zXMOcufKEvukYStosfcOip/Pn4kDUShQM6YyWDLLYXcoOpMCYsFPC5l8FXiWLJbZDxltoY8rFhjwXJQR18ubRcuX9qPDNh1zcRPjMLdDyXYqXL2PXIs/ZIVK72Ao/2Y6UQrIKvmxmdgjJnmI4pVLwOwqac3CpHdRjNoJfJobUIJwphg81NusgA+cgS4ZeQEinjB5erw9LdeeDGxkrpHVNbMbTKXh7KwS18QHL544r k/il4oCR1KWyxEtaMgA7EixY/pRulQoP8iCkxLbJU6hLL5uL3DLQ3WFfmvYpedSuLLhaeAp6gSvL/zK8eIuimbKESm3jkqYArLJP4YnCwvJ5vi3hgdKbeY0pzt/eOPmmiQ+BctY8qPMiuScNyQjghFSjFNK3KD4ncqI8FqSejQZVCoLzqLZfLeyXSMdFdLyznUr7yU9BCxe04CSoiLK3s+s7YsGhBsghhSLdS8CJLTGNH+wrTxE+UPYLjAhbOFot qQcjccKvcfPMiavKfJu58OPVQ+xJ6ftnTyz8u3Ivzeq6plXV3AlrEALtompPLK86CNULpLpSLTO4IK0ipbBH6BjnjKfgF0Sv04bf4Tz9lGckoE4OAhUjS1D2Pas8IGGAnKOrBGFhki1SHNtEs1hgM4oOqbqwxmOqFGGEjsYjGC0Kwl9q66s8IPqzxhfFoBRqxcp/GBpmv1Aau6RXKj6Eks1V7vKY3WD/ys4O383IgR08jbJNjNPzJo0argLP7UtJ 0dy0/RwLysUxnOci7qHCMLouvIzjMYx89GK6r0Cu6jSqmdBCgZriORKO6qxvA9Nf5MvUrNyS5Y6JPSTYk5JxDMHU7jicY+5QWtS5havKO0rqyNKhl5N2UmKKNNkiSIUq4MpOkXx2qjmNiLLkuWxHlTOYbmPpiWOgqOTt/XVLDlvZOMVEKgUoLkeNl8emRAon2O2vXTcghE1eltjXKVZ9AQkHMAzxvFwtTI3Cx1MpS/agDK0LF/TciQrac32v/TNC wzMtrvM5ul8z5UsgOwSWUhQstrRZfd3S52agwp9SF0ncJPj9bDniqxq3HlKLqrbNSg8jYg7SjxSAUwwqrqQHL/ni5hEgGRFJI7cOoTrLi+4mLNMWFLS54PPdbKOyXsnO3t4KnJ3mTt+fLIKQSyXEKsr4c+Mxhr5EAq8tM9ZM18IkE96b0wsJTCRDOJdsg5BKqyztHOHmdSC4bO7qDM3uq48tAylzmsfeVeqwS5/TfyfyVeHLCoK08ctjXA3aowqq ynHC7PjV+PH+ubq5bYwlvowcH3hzVgG/dOoClC+KosI/JXdMrqYGmAKz4q+ZeuWBH671NDSQGzLIA97lVxhroJpNgo1r7eRrxSY3QtWOfISG4+L1tbNMuoviC6nBpQbg7Asr1ldBXQQHQu6+Oqvr5Oa43ulnqJrHuNKyYAu/ytc5byckgg0DMD5AnFGuE8AK8ir7JKK1qMmMAqvYuQq6OKll8LeKIYUI4JpEiqCrGg5b2bDpi/MoMaGgg4ucyqWC tFCIPOR4qirxc0Astr1ogk3DlGTL7Kx8Uq2+NfIEqfr3qloG/gurqDuWuqYkTudLICLXwzAvnMtzXws8yQHeagyEVCxBvNqlUrbPMcNNJW2scn6pgKzrJ0kjTmspsycu4aNC3htvstAvpGkjIHcbmhT/ayOq2zmqpbNFogG9Qv0zgQoqoxYSq1zXKqmG+dJYaBbbj2cdAG3Wq0l1ajymV5L0x03gwoagGpNzYawrgspRo8qmVkiYM2McZ2JIMPuF TCCSIeJNjJEx2NfjSssmddJFsnEKuwyuB7DOVRHgQ1zZJpCKwmS8vzpS64smDpYgNE5KrLjm36RmcnJc1UNoBjU1UoZ1m2bk2bWKGZwPz/pI/P+tbDOEs2ANm6lRBamgsFt+t4M8DM4YhKnxJEqkyrwoBdujCzT+q5FCcryozMt8pxNR3fQm8ob8qdyLNxylOkJacoN1WVTParYxV4fa4M2pagOWlunLcg4LP1SfZX412k8qTr3dh/cQrh8ayTUy QG9WW8CTSoXiIkhXL0WT3G95kUgyqpapWwVtlb3bWKE9ssWBllWbPTNlumypy+lu39HK+KiTNUy4YHxaaWwmTpbiW6ISibNzX5Vib+TD0qWpngBHM3AjeIPRHMY6IZDW4n2YKLdb12D1sz44A4CkjS4PP6vuKA2qqnM5xC2ALqoYPZviQCmTdEOxsKbL7gOoJaiJWbRnq/6qurZm26qiCNjLWuUqOSAJjkbTgtYtviP4kW2n4KIjPK9z5OAeO9wh 4uBRSShatJPlrFGr+hJZbsv+mLS1nYI0DzVyfqma45CirLDzs4lPzck0/PTJhSA6kkM3oglN6hCVkUOdtqbE6nv2Tj1rRTNe9+fGpojrN28KR9IQjR52aQvSFpvna6mrdpgrgY/XOJ8us0bIzYqaN6jCE6aGeLRSI/cwWj9fnUpwQSmned23Y6DcigYMD2FFJHrPgzMIyKkXV3KBzL6tpoD8FDZuH9yzFNFT7SS3bKtRiKXEiTwk/muJvQMhE312 aK0VNQr1qrCxLKuTriuWNuLjE9xNdCmkxn0xlVEnGSmNNE0xIY7kS2rRtUJfWlhlqk2ypNFqvgvEsU0GpP9j46IYkWv9CXSsMosV222Ws7aCk5JzjL8uWSmFcyC8pLySWoqpPRrQQyxIFLrElAoqStOwTsnTCyrEs0r1PLKI7aBO/KOVKzVAyU3wrO+Tps6AGazUDDbkkMKc7+O4zr290WJw0u5rgtuHE65axTtRj8ivFyKLueepKgLGkhxPhcdD eqi2UKBeqvEiI/RIqRSV+Cqow74I49qYykyFjNs1MuQqqOsCMqtmSNZDStILCTrMyRCL/g7sgyycTI4RPZbSIDiOknSlcIu8v2dCt/YhhfDupM4ldDL+FZTPrsa7y3etErcza78PyyqqkkN4kTmtslPri6LLs+8cux3I7zk3LvLYT5k6btW6uEnPNTCw4qFtGbGY1SK9iSrWCRyLrfDYpkSTiy7qeSIDS12o73ksjoCyKOpRJViafKrDu7DfQEt1 jPil7vFS3u6kys5KOF4Np9/MwHriLqTPl2ZjeioVxvSeSNjvsTKogP3C6o8yLtsNwop6JciSgJhKTc/vVNwtDjymKqTiX26hIqpaEkxko86nDapeixu5jVh5JuopmhqC24GpeinJPu0Ml37aAsuq3KVnvHIZnKsJW5U+GhnLbf41Gqrby/fCrMC5aFlQoiXyyDyaCO6OZwoEFnIAtOixG08q+kqySelrJCZekysqLSHfIiiS8qXvXkZeyVVg4LQ8 GJC7tO6DMuidOG6PMyIextKh7GutDJzIhu5TNqLH2+orWdp2tSXOcHGkAvEaSQsnppoKet3OLZ9WycqJbt2c3Pz5jSTSmtyuPaStsrwJHHtOV1ugnu7zCaN5qOawNa5Xi6SBRLr0Nku5hzM6NK73hMr4XaDpdzIyWMt06AeTMslVxCtGOI5wdLGPeJDyOMtcYEy3KW3YGJZFmE5lDUyx76m+jMs9JW+9vMEEZeNxrloU7N3kr7jK7wUmtsaRFJ3J kUqSst4ZKuysz75qZsl+kFuwSWOl+W0JN+LPK6Cp4zdcuCoNzInGPo5ajWm9pc5mMg4FYyMbS1vZbrWzlooTxg4qIq7pg2itTagyhiujih+piUuVTtTNVeqlrPCWZttgsvJDiWuQ7t/KkPeRrRqe/O8upilOaJTpySgBXsgSlXT2OKtcRX2OfKpilMttasSHmLx11SKtAFjyBuatfKrujq2OKJY8geWK/4hRsN8qOt5IbrQPTgYl7dyj7q0YvuhC up7ly81wo4vtT7qoaIKGAcZs4B6+vZV9tHWNtjgS+m32rYB98mUHhS5bWNig5XVufIFBuYPgGeB6QeddRBuQefzZyi4olcQDMYulcaGUm2AGRg0AYKssVcwiqKkmGoufI6KhaPcGuE8H3JazFIqmgQXBrJLcH8Ynq2D4XKAaz3qhKTiseKc4dkyA7+SEDsooRSc3ijauKp4t4ro46GhdcIDMDRVtEh/1tyGUh54vj6DSRPrlM8wrXiSG9eSofyG1 u2fpdc7tF5THLUSK1sNaqBgpRiHnKfqwfsJpM/vtLwk0GWnZk8vu1TzMnQ8hsrreDPt5caBjGjoG4ETNSMqNymvqVcji8WO2LVVCfsJ0p+m+ikGHu15Jdj+BiCnTLDhw72zLpYiwep8rBp6SuH4MG4fEL9XXYdwLD6A4ZeGsyt4caKRElotI6BaZfs2HV+rDs1bKXUiTw6K+tcvM7q+sEZ78PyyPC/LIU41Xz7QNGsu3Y6+rIqj6JC9EerL41Gfs 4ofcHWM6G5htPoWG2yiJ2vJvnH9qsFt++EspH7Kr6RPaHnAMnPaRhtyrCTLgS/peiA++YRoq+6h/u/6n+8KVBFA5fxlCJ1UnD38GcbQXpg5qwkXrrCZgrQcUGdBmZ0eaH8Y71hsn9NUfmCInCGzGMqKgZEFGDOCQY0agMwuz9JihF7TUaY64Kv5Sl3bMlXdasu0ZwqjGy2sdq6ZLX0ZlYS8xskHcg/HKfYlZYnLdHSKj0aACUOQMpGCZqpzlsGlB yLOeSxrB+J0pTi+MfVGogprmRJAVBHkGQMbHIeSGeK1+r2V3U293hkvU+4gLGmhosbGbaoB0yKkpmr4u6Gv+3odMr7uP7j6lWSTkebGDWuPv/cvKAhuA8hSyiXtMWxvsbFrM26tUlqc20/uFHWx7QtDsnKnLPzLP+3sZtaPKHQtADyu/QpwpVx2PvXGFxoNMTMI7LodHG1xn/uNamuacWdci4Qu0ErQS9Fv7K5WrMZPJ3OvMbRGYDd5sL6JIu+OT GFSR+Jw8NhizoRHJU7lphNeWwypBHgJ1+vUZ0KQeJaMJpQ5oxHCRkd3xkYZHAtKlEJ/EeObwNFBJxJSU5EW2d9h3R22qySjNlVIVO0+pdV3YYifVU++nau1V4XIfJmtPDea3H6JGZvqOHbhzMPX71STfsy72JvVUn7Xhr9tpGniX9v2GOJ4Sd+Gr+4slgqQYnD3mHWy5kb5UAlHWkBV+rHwjXaQSz0MfH20FCpnz3onTPQSxyu0vcrxh/4qOs3aO XilG/xU8YJaRRvoag4y6fCVkoKKG7waHyhwsdSGmg75uEMg+NCSdCgByIfoq9vQ0eUaJjGG22tXB0KcvzpSDlIpahgmKYCGwp6BPObYEjb2imQplKfk5+jcaigH86zQd1HTB3QegoOaDaLcbVKmwdVGSp9+PEra2ufJ1HzihMYvcosxW2fZYssMcMbLGpLISAv/VLJ+papcXvQHJe89PGb6x69MmLBBkabjaAgoWnt9CqKKefjcy5gYr5s+SLQwb a+cBN2jFPbf1bs769kkYcEmDjJvKxPYezoCreBp3/axXI+v4DYtBiJ0pSqsfvTrn6yIKU9z7TiPM0rK09LjapAyTXSiqqFE0yrSizDsnTBI2qtJrgZyqsaqkaCbIKauKIpvQ6AAgyKiZ5jF9newuAt9KyqYZ5h1RneGdGepYSon6ZSimaGQIyigZ2ovg7Qcre2pqhtfCPprL2jdtKnK7U+tV7z6j9uuzM+e1u7McCjVwg654+SrdTwQzrw2B+fK7 Oez8nPCnUo+Ys8lWpOs77KfakbfhpuM7jBgZemcmyrINHWc6BibRHhYdmK61nenq2F5p9P2QaUYrdvudMOdkaDJ2ks2ZxmClJDopJzOVDvYrlSG3oU67e8KXd8G8r3w5qJ87mt86Lgqj0C7c4GAvxrTcogf74BXVmNxFhqvGofyI53H1GKmC8A2cG4SBtrGqlXOYoJ9eoInzDmE5ydoI7k58Ypld1c7cvOiA/UqnSoKqLKk+GijV6phrC2hNzsJ8 e1hOjTEmWUfTbOutCozAMK3rs4ZAWkaz/Fcc/nOV6Wg1XraDXmz8YL7row3iRthwpMlHC4ENcyKMkJgkc+alZ2PgEaVGCkjVmtJNeY+a558bzymFW3Gk5tV57Ccd6j5/lKgovI86RFSoWg+avm42gVNOkKnYVMukoWwechVh5iSLadzmpElmlaHNFvNKnxmZwnoayaenrJDe4pn9bXWmNvqoP2IdrRUR2trsi4K21YvELKE0IRoTcRo3sLyKagKN qtw3D30atOSJdmxzPEgEtUH3igLn+6nC5kohIDy2KVTKGusMmN7se77q+C41J2gCsZQ5brFCtk2tSR6VQqqctC6O2LpR6InUkmmT21ekNo6Gk9jri6+tRrOGTti9ZIUWYupRakWe/H8SeyNs90mC6PZkztrUse4vKmN3ZlztiVZ1BDldIxlRwvKTOqrmuZrrFk21sWuJUIh7zT9PqNbyuveIxsWUyDxYcXPiMxcprvxERbfyxe6acra421kIy8t9 TkNRNkpuUaVKYDFUrOTHOo0xdbf3d1t3Lfu9QfoWijTue6DarKufKpMqRALrnxGf0b4yx6vUmz625i0IwX/4x7xTiNrKIriyM5gmooT8E5XJvofYgPDJrmo3fNN77e1nSujqeOlssE/ZpmssiEW3w3Ba/rBDI6rGa5xbmXxvZtuaN2yNtvuiCFkZcz78bOmuYQkdUOptyRqgudfrtJPd1goJZc+c+Jieiuctq1w90mg19lDpHV6Nckntvi/8tNtY oAmLpcTnIx+WXvj/x1MfzmQ87pe38H/AgWFMz+bfL2WTeg5eGjTCu2wvD4V8mv2W2xxAv+4ux9FeGXEVjyknHOey1nqpMejhfMW4ct/mv5TInSLWXko8QUEEvyCJK4pNwGZbpWeqkKoTTLgiKtzTGopxbQL1lvafByinb2gVJZO7SM06YkiSJZniC/LtrsjFqxcUK4q34QQbyPLzok6u2pVcSaEq5JvVXbekxd3MGFHnSIVjzPkQQABRA82F1RRM XSzlbzYgClE85A8EfMnmCoGNEFgTQAdAMQZgCixhweIGYA1gIwEwBiAIQE4Q2AXkn0AIWSCzN0bRbCDqQyqdablJDKbOFZWULTLAFSKNJuFTHXWLBWnkCWEnUepB0F6jCpiLKqHl9UtTDjTqExZllQBWWA+GCIGLJiz2AWLJdDYstkC+ST18xG+U7wkwJvEz0c1/iy7W89AvSvQ+8OsVVZSiB9A1ZA2ZsUAUq9Wohr1oQNWHr1nsJvTTAXlvnh0t eAfgZtZHWVBWbpcRbfjMsF9X1mXFCFeOVstnYKfQ2ImCHlBXWY2H1nZEPLfIBX0Rurt12d20NEi2p5aAthSsefNK1N9tLKbuxnfO7oqKlN3RujLDgKJbK5JrGWqzR7Ciii0+BX17q0cpYhoYcYb6u4KwFCO1R8SJGhBAZDyF8dJGcEW7QubqP6BJSTKYapQi8v36zBAYXdhYY+Wn58IljjqOsPeiPkU4Q4kNOo28uTPor8B0UhwrWG4uKy28eN1t C+aDufyeFz/mhzOw2HxKtDo5JGkDJtGUW+rr4at5lWaEa958LK4coN1mBg3SpvUyGpPyeLSyxEYsTbawguUOSAwBkSchbIBFr5Nvi2p/7CawZKCikg2HefTem9SpzWqPzS24ZvaA2FoShfHs4G5MBJkNnChLHh1EdQnZUfCLb7qECuCiQLcV2TdNCcNhTYXGQA7M23GLhuimO6Qqoc1V5PFDrhJRiNhh126QHHgSMFGBbJo8TWN18K5WcwtdgJz1 2gDJ0pX64IWXJ8dUVZ0I46kprYZ2twgqrs2Z+VcZm2twmQrtCArmnSCd7PA0pmeGgbYm2W7W+oQx76o6da37HQbZbsDqJOlqyTqb+LqVgc8bcLnaPSgpJRqCr+r63WmhSiW2/6hIEGa+PALdh8qZ6MhO3B7FFUjJCsXekCcD2zbdu29p8Ty+xhVG9idENtzOy22qsj7eWp/pc4B+2jtv7be2kaarN22PA+rMYC6t5RYa3+SHe0HQtSFrdq36OzHc KyJ6xOw65lwfdvh3wd/7fPSAPLHj8pvI+Wc5qBV+lddTgm9aWO4dKDmZ6T3SILnVMBmVVPmZxV9oHFmDFr4Gqdo634QJzxKKqZF3uXHnaRtJ/algQoLNYJdOV+Z3pLo40JrNj9xweecoOzZ4jXabCCOCBLqSVM+z252xd3yck2hcv5qCnHs1TNF2n84zImWne6Zf137XeXbY3/yHAf8ZW8wDb6FyVsJcCKeoCt0Z6wskoBOntPToq3bel5tHgEUZ IazRd2wo9pZGl2vqGCUtJ/yST3cQlPdUnb2vXP4ztp6YsCaQXNwwc6KsMtHRjUB+CkaUUbY7K9mBhvq1coMNuMf2qm6Wkh0FM+7hMwbMET3kSWipqrHIo4GCi0z6KirwZJQfB5j3NGyGOpaxJPY7NjgQgMTziODli3ZKvV6uWfYbY1FNrmqxsVECNRdyO9kl0GUOVH018cDatCirk95mZ1KsHTQwaR96vyIJWvualol4/XMtDy0zdw7OVlPdtZw7 K/BXXlBkudx3e3Z+Zp+3d2HPH/cRGVkm3gGMm+IA7l3LdpVyys53Cxn+lFKeA+/3ED7hYFJ4ORbKITA6ULVl3MD1+riXN9DkODlP9g3cgPwpE0LEp0t/3ft3zd4A925U2Ig928sD3RdoP7xIUIYPhd9XeoOCrZA445UD0zahTaV5nY5Xf9k207KC1sHcW3EdpsftNX9hQUoC5Dm7YUOl+2Ear6ZSgnckWR54O2U7hXAyUBn0dwnZ0Wzyv9ehLDJX g5KAWNonfKLs5tXlzmQ8srcmTKYqR2wHHyvAbTYsNtLfk30wadkWCIBIFQVITvXTc82hcmBUAr5BECpsMHNuNKYngmcvZUOJ2PpJ4WeFRNTudfSZEi56V2BfMdl0jhNRlCM2NPY0n29punM3eF6UMs3FcmBmHVK0BPcqOMj4o7p7Cw4Ip35QivAu4Uijmo6smwRNykmWh6Jo56ORFM3oakZKD8mpVKNQo74Xejxv17Rro8tDgt6rYY9mPRjzsK0b M4HNjfZu+ro8EU1j3QcqDnrZjjGUKFiRfY6j9IDIb6+pI6Lt3EeyhedonJgzmsb6ECthpJEyTRePpGky46jq353enPI5ZoAweOfjy2sZa9mllq86r23PZAcrllLhuWObLHTYPNsyMYXik6ZAt/TkqUJeSlRTZINsL7Uhwqx0CB4Yvv8QtnMZ8kYFmpagqog5LKxY/xG6L+qTBuctErz0xLY7HSufI/EZil2pg8orxxDH0VnilY6SXsp9rl2MvuXk 8Go6WsSm/reem/SZOVy25Rh4fKbHn8pEeRk6ZtmThyvjNsss1uJM1TuAY1P/AtngHrOeXASi7HGLk9FOxaus3ypggoql+MLTuNrnMp4+7hkK/qh089bpJYraciU24U+p1HTwrcwQvT0dR9Pox81MtPWROtiNWhdE1YF0zzIXQvMRda82zl7VqXQfMZdK3CfMJAIwE4Q1gThGUAFgegAaBMAZQHoAvITAGeY4AGoB/ADdQgFlBI103WgsY1gYEXB9 jXLFsl6rNrkDwNyJ/SmQ0ubOHe1c1zPVPJysJX1ikZeBgOXlM8evjq5veX7hJRDF7rGrXa1q6HrXGLBAGYsT5FtezFOLPMW4tB10SyfkSxPtaEtCxbteHWCiUdaKJx10vUnWiFCvSqJqFedfbFoQOyGXWTWdS20hzbAYO5Id1hBTggkFX7G71O6FvSoaygAfWPW5iKywDYbLdcVIVNxBy02JHz43Fcs6Fdy0TZn140Pi2RNyfn87K0PEXzCAys1I Wical+3XDmuBYSePKfZ5MoMbirUk+O6tkE8RGphtJTzDVa0ajTsq6SZzl5wzzMOA7BSfdiyH6L+jsYuxRmfPxEzGToj0ttul8kMppyfNSaCIFqejrIDehWK4cyLksAovNdwqW123+0zhT6Ou/lMV3gx7Fng4yw9S9QldpnVLBO3pLAyO7keHNTkvCsXnf+MuZNVPc2vOGY+qP1jm1OHCcxsZRsnpj0TaqPhFHzYspsB1mAkoP9iVe3GuL/xh4uho murcY6WOa3iiOL6yjqg4r2abvCNLqosYRDO5DU4uMr6JVmnNx7LZkN8duTsKvxleK+DtaqWYRN5GqZ4kBONOmK6KuhkAwToE1BYwVSvBfNRdgOPlTPgAiTuICOw8Oa1MhgPhyAa61XSWcymWpqsMa76vJrryqR2Vt1EkOnO7Ba7+L+r5a7mGztldk/qTqCxegO1kuIxbsodlMO+3bDVRa2ulrlmrR0nqPI+LWgefRYv0Dl5TyYKilObV6NkqNg/H liIlGnM4lyXBjVohlx/bzZ48O6mKqXNQbPAZMTwPfzYSZ9qmXxFFbyjxWwbnVuDbJAkjWg0nRUTuerfrxYAZo8ZogMos4LKYwJuDlwWkWyRaQci+jQDwm/mzVIonzm0WoSLgpuGaU7Oeb6rzdjZv6bym85un2QCh5vNria57MGabG5/opRvilWOvL0qYG0FSDBUpIGXbjeCuzgFoYFt3r9pE+uaGMrIePTpCu0S8BSSFXi5F+9YT/2z2LsvjTsdp rbx2zNkRr54hkaqUrpWeWKGNOR1bev0bIy3MmU4hmDWpPCUVsaJBvItj0s25dGnblvjH01lUmc2Q7saUP6GFQ4HyFwnOvhOMuUyYDJzJnkbDx5OJ0aU4XRwAfuITVQ6/MptGXODo40psZQymKZ58iAn7JMw2W8KK0+krot+e1n9ocsdVRU7jD3Qeg5HaaDUcJPI6/1pLD9ehgpNE77OLUNTqcWiqUKDpBmk7RNA2upNsF19twXcXJPkHuSS6qUrY n8jZWkZDSWHUYpaJ6uiMOX6adnyLzVaiS40JpGu8uk673H3+G/XURNaK8+nnMkVi7sj15cqdfLCo4WwOgQZGQZubk47T91EpwNl9+4nYkMO/+6U6m+vDUFKJpMB8+8IHy2vTH8JWEpAW+y6E+JT/VPk+JhEyNjMaZdJ0BfQfoeoQ6opr+GDTTvz+jyqzuWD3w7oP/DzNUtblD17VHv0DcRf3t92IclgDM1+yemQD8Jh6fz8FjFfJD48bh8Yeaafh +hcfFG1TfnY71SV4exHm5Rf34717QxPKxkO4yow7kvZYe8Hu6SQNg+StefIo20O7fZNH6kzlUoJ+EeOlDH9R+MfxClNSgerEgjU8mNuax+24THnEzMetDlfuOkuTnqdU0rHr0s94mp/4g3zljx2n8V4b4R8YGVpkjn/pvxLg9mThQ+24UFHb9kMou8tm9kbAxrMxVtlCliPfNv51VyXk5HiOXleJNKDA/YOXijUpa1oyKu+e3XNmZLxIK6d+9Z1i 0XXlNif7qjdVvp+W8uR9rZNrAjIpLrGY312QoCiuAT7syuRHNzPd3uS5Nng8YSh+q9UUpgMZJMsK2kWh7mft2QoY9gTORflKHMN28T8ONnpOMtmMwbVpeof1vkZOdSzFOh+AsLiPfY3fdwWwR6DLsZaYQ/HS+1Ic7n/byb9Fj4mW6RpTgHvMvNL1Ce0vAtW7OzMUihy6J4nL+eYXIcU5clIig7oE/OOFvES+cyg6qQu8dRtSq/SvqruNrYalwXfG X4W73ZcEfwbzG+SC/8y2kWz+y6IsloInil8jG8TtkgdTVdgR/xXyXuNuRXbbQO8i4H3dxdm5QiD/z6noyPQg84OUO/IFf7FzfYS2fuJLZxWvw2auifCB41tp2lT+ne8Pg8CgfmrMtrM1OByru2+2jodFGVZgEKaoWF5G4EsjQpBS12a1fjX+2mwRZz8NPqpTeJq8JPHVR6kDpHX818z4Sd6fjJ2XeM9XtevXs18ZfUGv16nrydoN8KgHX0N8XVDV /c0OZDzPnS2YTzQXUtWEz61fOZbV65hTP7zBvWdWpYApFwhewTAErAJgdyEwAhAIwH0BzIOyAdB4gegCixeQeIGIADzjoAgsGz60Qt1MIEAwGhGJDvi75A8FfGPZVk+Hn9eBzj3WWRPJFijZhcoKu7DEV5XgBRLsDX4sZZqLFljzw6LBtfXOm1zc+iID5dta4sN4LdGEsKxQ84EtD0ftaeQX5M8/flFWSS2vPIAYfFktZ1pC+DAF13AErA3ztS1a JUAVui2cp5ZBSQRV8QC9QVkbpF370cFCC5IQ/WM9ZTfiFWC8n14L6fUQvnLGhRg/jxdC/OwX1sIt0XYF5x69LlWvY4s3vLojXI5Th52MDoNUuG5ndqWJj2Tx7ZhyLy7chN/vVIdloo3uLUuTNYl4DT2VTXlxjmTg8ih+AFpv3SHO/ZleijWCZgoW2hCannjm+zotVdTIMcJzEoUMYHmxPqb0epJP8Rm5ezw8wqReijUYYzvHS3Qa+JCt4PVHNfWq lqolx5FG55r8P1wQulaoqThzAoW/FrLYaJJRWRUoxTxQ0uMLI1Rs/5FOz9WBvPxzQ+mYFLiPJpaHDz4UVQvqtlQ0YOFquWzmmxxmM/uR0z48kFGQdAakV2YUj5auRi/qoeJQ4hk8D4MMHgJJgFh8YIezP2bkEFhUvwmRQR1UT8t5b90nQaRBpB4maRhqRALSoqlibk0+QE8uE6/qmLenBEzk3jo0/Wv8T/a+dPyzm0lb3PsQyoJ2Yk3Yk2v7T/mk dIPuWea1JaCnc/Cvyh7MHpFl6hRoBmVCSTxQv1lts/y2eL4c/a1c2xxI4LdPcO8hd3T/iTuPj0XdpciotF7YMFaJmpJ9Jt0+SX+Db773xNW4iTIopkJ6mmbipuct+zyPmdn8NVyRfBOAxkxCpKeUjTSh2leeFMgQbpVUHFWr2iDH7skte2VRFUcGA/2kKzTj+g9eTXz2y63BpYgQh4LWRuh/KIGbV/edYniUKz5AzmEhSM6BEB8/yhyz0gpMTSRn 8zY5aAmVYqkNj5c2kBeOBAwRGfqCQGRqKPXhWHJXwJcQEssJX83IveWbVqflSfl81+2kbX/KkG4ZaVkN53qYydt6Plimuqdfi37nfZrrxYd3Xrxn7lcOUYQXuEsda69FvTr7n/GA6jLr3i1qVIS++OOYHaRvFlODrkHRlDMy5+KNLmUkGl0WOlnJM2gt/v1nk/7KFgYhqvEXBEZnw5/ND5pBtCahsRQElWUOTnw4Of1nov/Kk04BHghTCXwyW+vV n2Z9r+Sv/Winphyb6lJgC/mv9w3ypYhhYZhGchmxDq/7g/b/pFmmG7VE6VChToO08f4SeAj8TVJmpNcmdTSdCQv4H+oDbe1IiEOItK+fhgAZoAbHtsRe8CoXvNRheoDGVeccq0dITD+LjiP9BVD0hHO74jB9i4KvcX7i9sfgAvV70LctmRa9XG65i3XZRCzAUoizCsbrkPm7zKTJAVpdJyHSMKK+RW37qTJj5FLSO4m1F9LW/JAFPfFAF7eF6rPL G2SwcX7ga/a4Im/NJ7TGCXbhjTV5EnGJh7GQTjTSTpwZUaN6evU146hb76f0fvw/0bxh/VdH7+MUp6k/ZNT8bRwzV+OLJ5tZqbvkeH6yqAbqe9PMje9IpbA/StDffGYSp+IPpCnUM7EXb77btBTIveWBi0OLj6LkFZR/qY/S8TJIpb9IL5dOEL60SPAGguYCqKCOI7mAzz72fPAGB+EI7ykK77BfG75WAoxSn3MDYRkF5oOAuL5eA78QNgCEY4da ly2mccqOA2754ArAa/JXAYFfa75efBL7hLYgbH0UgYXdAIGWAsL4ShEQauuA34WtSIGBA7IHHfc8qTaPVR+tAhgGA3j6g/Nzqp8Dah4XCoF/0VdiGAvj6qaPkrQPAzohnIi7tcXx5aPYDTpLBzqiAnx7ffaFqVVJEL1zJB5fYBR5mTDL4RJGH7iA5B4P6SYHkqZno1TOH47XJV5XxG5yxjCYFrApmySA5NQtJf/YJUBKCE/WXh8AzH4CAlh4U3M4 FPEF4iXA2x43A9n7BvVgEM/BxR83M9RMDGJ54Ausoi/etDwVZKhG/UgFzCcgEjjCwGeApRQP/VF5P/CUIrvRXwOlStI0PCf7b/Y765A84y1BUg4jPbfRGKZi6P8PMKuzFjZovWVQ7sDIYCXaih6ZHUKzJOb4WkFj7Jkdj5iHWxyUgnDbUgnOLtHCyQS0QkEwg6Rbija3TLfaUamHcP7kA6DgjWGoy1hObbYXSkiDUf2zwSHIx+TVGjCcd9SwlTEH F0UZ5mfGzJbAokKpbfv4ZbPrTYMa44rGAhgTnfZ6b/bUHL/KAz1gDTa3GLTYDtfD5SpdbznGOVIr2B/QEA5NxEA9uZBbc04/LIMo7Al55LqW1LDcFl4EnPv7IgnUFT/BrxHRIZAg8awbxPeg54ApTgmFHl4GfcJqL/WME3KVHKleDHJWVOhzDPFUHYgiiQKnQDwPKIhoFxHMEJLMZ75g605TkcSg5kCAIepNkK5gy5SfKbmbYFP5QkJQaBSg36TR 7JdR1XCNKweZNoF1dsFtcTsH8PXvax8MDIm5D8Rd2LhSDgjS4fkEcFoNJeqGSTBo2HMACcg0EFFZKlZZed/6rg4E5cg/D60CC6ScUJ6oCgx/7rgtITiUSFQClQJxrgz5RDXTDxYBCzg3giiROfGqKfhDexLdXQ6ngtiTCrbraNWXrYUghp70hNiSG3FJiTRJeRh1ep5yLPUJsSf+q8eVxxVTIbxOiEsiN8DQ5aSTNIj2VzzSeTHx/qF3QoQkcGa3 C7QIccwrYQpCGYcU0j4QqG4DZf4TdNSg7auP670qcGZqBOqpOkBl4//FtL/qe7LwJBFacvHVQ/cAuhkmU+quzLE4Q3d1T1qWf7J0IDhECaAGD/ZhhFUPjLsMWVzSQkr7VMHmjNkDuDqpcp70Qkr4IkVMiXACUZq/EiHNkMiGGUTr5eMBqjdDOd5w7RkGAQ6CF1/Buj4mbxTeSVMpPgiULgkF1iDMTOABkU0a2HXcHkAkCiTAWDimndQxINdgRtYW cEyglqReMUnRRSE0hFqNsFhQ6UFdg8j4ocUv43scIS6NEsH1gssG1fbnymKEeh5wbijIBOsHxLcg45Qw4AuUAdCkwcSgPZQLZIgpf54Ak74VQg5TlUE7hOglqRuibRjfkRsyizdLLzSDqHlsV0iDUNxjx/K7gWXPyG5Qpfjnfdogrg+LJefUaHAvCUIFlNlAEkLLDbcDBQjQ22RjQwaQfGDDgj8EFgRqbqLKkUi4J/LaGD/Lxh/0Ns4Q1aMEeSCa osSKao+qSrr0qYm45PDGYlRWaGKKeaFJ/RzS5VazycBIrpqXE6ELQqf43/C7J3/IciQvWS7QvEmCfKHyrjghPiV/Vh5aLaEGgg9cDX0IziUWIMhOtH65KQsMGwAtJwDUCpiIAuj44Axj5xg3cJvcdIJX+NG7IA0mEP6PnYAmNy6vfel7Ew0+i4Ah/QuNekyVTAJg2/EmH2/CiQfGUHDwcfz4eOOm4vXOSgM3XUHspNFQb5PVSG9dm6ZKTUZHeRlI u/Jg5u/WJQe9X4SyAul7svRb4MfPmF9acMiUTSejQ6fr46wmmH6w6RasjK2ZhGF2BxZHmGsw2mHfiVwREUDwRTBLSL05FmF6w/HTGAhFJ8TGhx3LZmFDqc2HewhxRfOKPziTekag3YOGoAvSgJ9HQS5hGOjUw3mEhwvrRZhC3JJ9eoZRw5OHQBBN7GrI8yxnc1bnmNOSJnG1Y3mXN4OraXTsECLAurCQA/gSQCSAB0CygKoB1AQgD1nDuQwWW0RB 4e0xt3CRh0tdVIDUVFg+GKegNUXKLCcPuBTvYQysGB9Tg8MmROlRd6Z4SMQkTeiZklHeQ0WC96rnRtbNrA97sWI967nE96isVPTtvHtb3yLtDXvNvCnnIdb3vQvSFEL+Ql6Z95l6BD73nYggKWBGAVIN5AwoRogrrD84ooOxZv0TdYnUAYgEoNeh0Ma15HrB9awfU9aLEf+SMoJD52WBhAoSIqTGIKhToAZQBsANgCDwXQAGAIRAoXQ8RD6PcxPr HD6YXPD61qGkJMgv+jCbC4jhHcGqG0KI6D/CEhD3Toj1oMCqBbZgyOHBjwuHYhFEadvoYxfaTkUbGL+ZNv4og3RYJFHGj8TR+4vdQRGhg3Rb9CX6Sy0NcADoeI4fpXRYDdWyiAzXISiAmhqZKaXowaWXpW9eMKSIs0HSLAqSeiWDguwYjhPxCOIpguh7wmF6TDqSLT6TGaExg6xEUScEikRD8KVoafj6Irf5SIv0HMvewpjcMI5WIo55QGFgw+8b NgsSQaaKIsop+ab7jtjEZidjTxFAbEGYxwxJj91WzQmnAF5kxIK7NHOY77gwATwCQ2htIfR62JFF6iLUEGdbCHKukKHJ+JflZ6RUCgwQ+7Yn/eCHtdZUhInAQ7E6J7Q1REsg00LAHcQilYbaWbRtZVCKi5bPZMhQh7uPZGgtaIQJyUd2GfEGgGWXJdROafrJPTdmDvLI1473S9R17akFcqUtDTpR+znaW4HujXoGmPPxjVkcnRLKIqiLaKnprVbq YjA7bLoaHMia2RHiUnB0b4fFhzSOZ5rY8LHR1Be0YRjJdQY1aeEubAgS0OF5F/IvzTvImyKfI74CHI8MbHIiZFvZCpofZckRo/afavIxZH/Zff6A5aN4XqWvb7JR7SghLpEyFfIHzI9cEWfb1qh6GpGrLZnY33fD7MkQZgkrXjY0rWpFJRGlFLqUJH9TCJG/+SE61NaEQhIshoRg5rzbgmRYvbF5SYScmGhDcSRvQ1Ap1I1lF+aGmRO1H0ZCo37Y I+XlFT/AWGIYU+Y7kAOGIwr45fg/mGT+ArBR0AgQy3EK6QSK/LktbyhjtDy7ZIkY5qgrFpdGXwrX2JJHQzH4GKXPXoz0THIjNO9KgzWtSgiZyRc9KfoXVaS7JIvAEbCVFB/iamx4LJxHBIy2EUTYVxUTE2GqXIJGT/aRFkbfiQSZAi6pwsOG5SN5QuqJq6H/MrDEjefoZlG0EkIoI6VAxgwxcTP7BA+DZFhZCKH/MfY8qCfaQUGj6rPNCjUIgzbM GborRzPoqxzQ/6vFdRT3aB8j9o+Xx4ScBz3lLxGmghqFr3SuAb3NFCTokMGGI/cHVfNB5yJfY6y3eZRqPIj5sXUqKlIyJaQSHZKbIpMjYvbSLMomryyo/j5ouFJ7F0FarPXV37EHfxbSHY4GQNFWFf7Cp7hPPpFwMO2Hw3PfLSLTVwiCb9iEyGdSaeGTIMZP9HA8ADGnSIDFlzV3oCMYIGVeUiHxcStAwYq/ZGKBDFGQpDHiguZEc/RXoqLWRa6h MWifA5V7EnaRaIQjDEjCLDHKkElHH6CDF5CQDGYcIjEaglV7SIn9FxZajGuLV7jPojCyMYk3YzFXRb7xa9GV0BGHsYqAxn9Gc4nAG8hvQkTFT/Qu4v3PBze4HjE7TUEHtAhx6QhWX6wY8ZEcKE/ZkqMdHYsCdHqY1DHlSfJaMefS5UYnDHMY4RbdolmK9o4VwoYnPZmfRtGsuHwatooX6H7ODEqLfboV5IUq41aTL0ZcjK6LGdhpUcpYdUUzE+Y9 opR7fh71KP+iVoyPBo3IvJB7P9EJdK6hl9Seag3eLFELVOEJ9KiiUVeqi9Isl79Ig2Hh9N9rIjKvL8HDg6mLWPb1HXmyHQvRb3o99GxKIIo1dDo7PTRfJiw+rF9aElLw8cT6MUJvJtYw3Z9afjbB/KeIwUC0JtI8rFEaAT4EVXRFwrO9Gqwh9GZKH54BkHxTlwGqE9RPrHtI5NQcA7+h9tcm5lY8R4HRG46rGA4Cvoqg7jYk7RMVGxplGNiqjYvb EtKE+bfGH1SInW7G6mDmFv5IkyiwurH9Yqf7yo70bIaQrBsralEjAgl7rhV5bhCOLLSollEjAqMbdAj6x8dK9qqo/D7+guwqjcbchXXSnYiMBHFsosK6rQ3NgVsKK4tXfrbM8DYFaSPT5mFe2wBMZVEY44nGcfGurs7OIIAAynFE4m5Qi8T0TbPaHSc5blER1THExI9MEWVDHLh7XdGKLZGE3KXk63uaRQkSKEFlIm5SlXfV6vGTLguQqf5pIjnj u3TJEFHG1EHHJsGWvBKjMRITj0ME1GZHUFRkozqJjmWhyaIqAw9gsNp9gtVbBol1GfKEnbr5DmB0hP6pm4qf5vhA4IleR/iNmWCLeolJFfEHyqmnXEQBTf6HJooRHdgxeobTJcFbTARHeIpdHdgl/7v8A7aUIjvx6bSI6wbc3Fb1JlZHghIbGg9BIRHGhFp413EZ4w8EJVbPFYzENGfKc8EQqbFBXg1go+4uMGhVRNKXYyKqdPHJFkfE7QN47lbJ pXlaNxPdGPHW8HoBMV4tcPfBqHV7Yjgl8FbpOqLwUbCGzLfqzfgogpn1GJh8zdbFnY1TQJNXbwHOPwGHQyPZrxYCEhcQciNmbOCJ7NzGaYgearXSLTwcD7BH417pH7NiQ7bRujp7KAQrg6TGOfPa7BPfqwnUATzmYkjEv4twL7WFIZnCIvaUDXfH9iUCEpeSYpfAizF+aGVYL4rGE/xCAnf47sEARQfH+4AOH7xQzHp4xlbF43eoprGuKjI6iIn4 2cz24uBiO40GTLxQTKnTUFT2tFZpCkV/Zr1UDH+YpdRZZQip9wyzTb4jeq0o0XEpcVPAS4kjLXlCLFpguV5snaujNXPJ4gYvzFJQk7QXpHoZGUduZsEsDH4fVGEGqA5TntWAnYZMQlCZeZQ6VJWpKtHdFyEhgl+aGUxvuSAp0TCWh6EiQmqabzivbWALpUNDgP7dLG/oxHHoA59JfrDj4lALE4OEv0G+XDo4fYPSG5PNXbL4kcFomXQRlcAwgg8N 4LPYqAyuIwpwyzEpzlPL7G2g5O7iyYxzDZM9GMSYYximL0bloP7HbgxnGj4h/TJ1B0GAMYnwvbCHZqo2+ahfN4jUqUWYj40on4fC0Ex0TTae0GonU7JdQuZdJhGohCHo49Q7iPcu5reHyQG/CHE1edIlGIg7EGg5vhJVVImUyanFzItuJVBapTCeafF0rYYm6LYxFFSF2yxMPXEeNf2ZpE6YlUYzY48eMO6HhWiEQHFfEsPWuJajGRzaTY4kW7fh 4C5H5oBTEXJxEjbFnEt1FQLFS5PE04mmPbu6uTYQz6TMTrgHG4k5GEuLGGMuKhzAEnMHDrFr5Yfab5A37uE0Za+osbpauSNEnKOEmZ9C0iVYmXjVYkVw/o+ElEaNSYLCaVICnan58HAIn+KfPbyQurqMHN9HxE0xZFY5e5AjEkmfY54mmPEREb9f2EMk3HoREv9FbPEZg8cfwGM7bYlTE4/QwxFAkBkOUis+SYmz4hxTYjZFxwdBbbdE+QwMcZDr OzKHzNE1CFgxUFKTPYmIpcE8HC48JakWbNon8Fyg28XUlS4/Uk9QC2jcULLBwUSv4K43RaxAh8p/JZja+Q5gyNFVriUkKARMpXvFEg5NR+dTh5QReWj9fO0mWY07okDH2IZA9WYMXPcEhk/lzWY+Hp18F0nhLUYpmHQ/yJkxULLDcHgE6V2aShLp65I4RYZkvmLoxIqHTdX3HTnXHQrDLMnFk4DZRySM6JvOOQIfU1anmQuHxnYuFZvcXTlw1M4F vdM6PMIt4VAGoCygBAA8ATADawBADKAes75oLuQbkDCwM9XfjMIVFhjFC0lquICjwYBHqDnGwhRMKZBKZRAKU9VwjhiLPCLnCPTrwuiyF4I3TkgEvBnyQ947nBIj7wniwpEI+H8WB+RoKE86HwoBAXoa+GXnL+QikaSx/yadbV4OSwrrD97PnXADmiZSwfw41i/vAhBgcHfgO2X869ERkqAIoYhUUGWgno7BTziVC4nrAhRQI38mIfYNjIfNHCof G9bY4HSCoAXCBGAdZgwEZC4HiaHDk4cAh+oYimkU8ikgEOnBgESRAcIeilkUwIAUUxAiqYJ94mIQ1DmIFAhXgM1C0QOxAYEUXAUQHAiS4PAieIZiBWYIBQBIUgj2YVXC0U2VDsUxik0EaJChoegiZvJggxoJd7m4Qt75ICoBqwBABGACYCVgJIBRYZQDOANWBIQUgA/gJCCbAZwDEAVEBrAbWBtwqCzdvLuQBBNCTrsVuCt0MPQZQN6i9odJG3je UgkvWuBDnB4h99WzSJ0LajWsNwhaQVGH8MJXY5cIUirwzd7JiA+T0WNc4bnWPRbnBPRCsPeHvwU94Xw+8m9rMZBnw5+RnvV+T56K+EjrD1AqsKqANiW86vvSvTvvO7DGwd+E/oT+HvnP95FQRKIpDf+GDLIcS7rQywRiAyRckQX5gXaD7gI4fRwfLCkwXXClwIlD7XrTHBOWO9Y4I6ilYfJhS4fNTZMuCOhzvFpiLNDEEvEFriIYMKyMTQ3xxAbY osmR3i0yaVQT2M6nkiACjvg3IrosXQgoyBqTloV2bK8HWoakaqS6EXIqeUdEwwReqzENZ6kA0y6m5FLPgvsT0ToSbHhZgldSoUKGlvUko78kZoxkaJ0z8KcIzAYQPEmRJ/J0RZpBskPuzvYXY6NxKjjx4Y6micDSQPNVDaQ+PtS5SMdLWRa9jnAR/gE0uKY8McNHCqD7A40l2B409mkXZGCZQSC7LJ4BVo+EL56QUbPin1VXKVsawbDAZGkewewg w8VpBxtbzhJ0S1jWUU3hlqXGneKQWnJuBWoyGdsj3qUGjHYjy660tmlBtA2lfcTJC3jNuBEZd8jGJSmlIGJ9g00g5YxUfpCYsJZSakULGHqXQgu06DRvWWAQdcXFwXZftg0rdK6toStDHqNJ78MBihruKoRDVOSKR073BeDZIxnTNCSbQrWwAyHvJe0GTR+WUlhTXfgKPsOGwXSfqz9vXOneFCkjiXbGRn2WqAyaTDgyRSlrYwvOlOiehCF03Yk7 IhKgdORsw3Y1unV03Bi10wmqjPNmAqJBGHlQqukF0gjCd0nXowtElCuSJTiV07dQD0jukc3ahgCNQXjLUJen509unT0wKKNoSejk0CNQsSZOl6QqOlp0035KdJsgBkWHaaUb3gU4gLQHKVOk8qdOnjVIlj4iXhgrcHAnaRFOny0F+mX09GoUOGMiUyCSjPNbelt0mulF0w2JtOGmkmkTFg10cBkr0vek+WYhjwMvvanAZaSIMqelD05krDhKijN8 eGiC/HqL907BlQMrnwWgyCii0LQib6Om4kM3ek4Mr4K2EeLTL4H1RFUU2ET05emkM3YnDnAUg2EhT67YuhmQM7hmoM0JhK+e/i+DDKQs0gWlW05h462Xshg6LiooyWKRPU/6kXUtGm32V4CskCFLnSRqCZWZ2nDEQOlMUf65P+EJiDUDdjicYazDcHh4sMQM53UEukn8UlRbUNYIviKFTcUMbjQw7bbHkRfhoqAmQrgh4g5kCzQp4RwiKyNAKwML 8gG8OkyzjRkpPTHQinkUUa1XEv40kQChg8U6TdlYaRJM+DgR8ACgY8QCjjsaxIeiNEalVDlD38RQYeUQP6VsPig1kdSK1BewRd0a5yjRB3jzcYcIMuPKDPGIcGFMupnwSBpmYUW+JNkLeSwMQWwWaDpm/ELpmlM3ILqmKMi/0UHjk0YZnFMp6i4SeTgi03LD5kMtAS0vPpFM+pljM8byV8OUhOCZFgW0WEq1MkZklMhZlQJQqQ80GjilWWEqTcJZ 6izf7i7ExqAR0b6g1RY+lpM1chVeROg83B5lAMZ4r4XLhiw7e8bvMmIwpM7JmVhCjiokb3hUUXLbFMZopOiB3irKa+ZjLUgbMaXtFkPRIaws6VJaMT0QFhBTRB8G5rIkWoJjkHyjDJYsIhMy55swZuhBiN57icc+wRkS5RtwbcgeMihIN0MHSg0F3TPPHsguMgUpuMxln79MhppJIPhVYCziWMjuAS8GxmfYMYLkkHVpnAMigUI/bxq2Kxlis1Ph pPXqiMGBW7KcI0EH7XOYuqEax0yFVlNkZioBcGZCcXL9wVwObR5qEh5yGWqyH8d5nLHVCQfgnpxms0uAx0CRhWsgPyHAUGm+FKlmKQwRmD0tx7YudjRlcQaG4MW+i+2X1mksf1lYkGpx+SJ6YDWdubBGM+nP0j8RCSE7oBuDaSVUNrBA5X+nR0llS3lG8Sd0TRSPCXQR6M/2kGM0aJGMnyyb0EdQSULra2kPmkeiPWkyM1+qqkHK7EcD9a6SCAKQ 0tRlA04JLRM6iixM4WisFLtmvUntkjuLln0sy0m5bD0FrZPOmBybqFWkL54XUKEjoCE7haEdBxnUyPA6UcT6QGCJypsBWkbsq0iNUAYQ7s3RZLs5jQrsgNwiEywIW0/GlC05gyHUqmmu0rWymzG9n602RkTIxWkvU6qRPUNI6vsptm0UPdl/U/JjK07dlt9R+le0P+nJs39n80xtnmBLe5t3FdyNXYRgWhM9ms029nW0wcrUqUVm6s6cQ60mDmW0 uDl0ccdmoUSdlF+P9mEcwpI5kb6quSYUjMIyRnkcjmlxJDFkpMLFneY1DnSMijli1XSDO0ftkOEQdlO00tnU0oOmZ8dJk8jfdjWUUzgCco6lPsitnHJDZmjM3CRScx9mGM2mmmdJeZtsjdSGfWxL6MoTmycxhnSkHMKW0VTqas+446cmTmqcrnxRGOmQQ0bLbGoirzZsi+lpPXrwNsgjms/U+lP0yDk5mRjrcyEKh68KbICMyen0Mshmi+HSH88G qK2qJhBYMoLm7E7Eh+keCiVsL9FEMw34c0OCg0MX4CG0Ob7CUGCSsUFZpdOLHRQUKtjOs9LlLkewYtMJwRLUPFkzqJ1lpckh717AqxuiPrg5KaRhZwI9jVci1mGeTLlQSXHTBjE0jpU9OYpc81kusjLmTDUtIrBcv4YKOLIisnVloVLhjTsPnamcJFiWUU8jq5RVm6s2bnWs/OiNWO1mZUOVl2GBVnYcmbmikb7zE0VLjqpHlSmwgrmpc9rnDc+F wSCNVnUqDVlTGS7mDc4rl1c1SZbfEUjyUYrZ++VrmFcmrkdcy9hNMMVqmxEfaTc/bnTcmxlHco6yB/KAa/sB/DFI5UhTc6xljEKHlrOcqFVuYOgziMwgrcg7mQ8ub532H2IosmcRos5KhI8pVlDMfHm+CFqBVUKMhNYHHkQ8lHlzfGzJYWHHhnObwzg85HkU8rS4RkSpQDCIXL08znnrc8bw3iNKJm2aLbs8rDkM8rnn9xbjloUKpSrMmX6k8jnn k8oXmfpaUjLMxfjI3MXraMblkMsxOgHLZzjiXUL4KUWHZsY4jk8s/Xks2Dnhfc5aGQzLSREs+hirJUllc/Sl5RiM8i0yLRhXUKGqL4VtCDBSMgnsm1L60NuCN0NEgqcMZJVGSwSYshFlcvW+qO8Ezam0/b6MlZrqLKeDA+bBKSuwQellmO/pfEdJkfMkFnz3PGzfcTlwUwz+54LGmSNWYFlZMgvlI0D2nbFUPIvKQdAtfcyhVKWIKqcA5b6UXGih cIFHhxC+byck5k+SV+p8kZjjZmEKhjFJmFmPMPCm80uBdOT4k52HpBt8q0aRM+DSz9KfktBOqCEFUIk4HM5wpMSrhAMTFhBaCJQk0g26TAfRQeiD0hLTDzR78wJY0cKkhDQRxwkCXJxocVEh0ciKQGczcRJWWsLMzOlIGyDzgb2XRlecK/nv8w/l38izwPUBxmf1CumcMFtmVoWlQ5Kdfk0zNwQgEonJy0KFrQC1flwC2flz2SRpzM7pmPzYJjHM +ZkD8sxzVkN6ikCTkhl8o5k4Cxmzq3EByM0bunW8DHKvNPvmEC6cTi3d+pSqSBxO0PAXMC7pk0C6tIGkLwZ9IcrhjJG5mmSLejDmFSa0CzRkb0nRmI8UQUt8r1qSChByH8dKGF08kTfIx4wV85JlV8uGoSaQ+lkyJ9JVfIFnaCzdjV8nvrX0hFnL4W9woU8RiaCjJmfMyAq20Lxg803yhKM2ZGJMOwV58nQVOC0eTnPJ6grUCIFJ8/0gp87Ni20K mzW8O+jqkNbjMc+FnVoONrGI27TWk/fm0OZhiwITNYDIf3nxCvQVE8VuirqM9Q68idnuMym446cWHJeC0J+06Tkqcg5ZD2TOnkXYqT/8/anH1VnS2kSfjb8tjLsc2DmMcgrbPJQM574PmyWaDhk70mumRs3cb3OOE6LNeqgWM5XlrciVlRBBui30csy08/qi3BVbkzc2YX3+LESR8ljnR8h1QFCkjlFCuqYV/FIYkoDhziDAJkks4Jku8nVLVMeJ iBqE6hYVQqSO8oJkh8v+byyaMJd0fy5BouMY+89IVp4LNJl3c5nmMMxiwSWEoR8q1jbCuIWaNJ5kKCF5kMRMcp9synh8ci8bQZR4zsfZ05keWoIl/HjmIirIzxMvlTh0MkzJ4KpRrPeh7cc4Zg4iuJlpPJrpv5FXizvCaRgiuFniybFlJxHqQC8Yu6+EY6SpCwl7LgP4V+ER7xpcVJgg4M4S1BLkW+8jIX/CxI430AHSskJIQUec4VO8y4WMJO7n ZYh7nHRM4XEshUUvCtIaBqNJjp8aOi7Culn7C3lnbsA1kVoI1lCsjlm0s1xl68l8iBHWPia0D7jVYA35Wi3XmTsplmoxeblpMUzSpcVwmcsvYUW820XkuBjiO0JvhT9bcEuiwoXGi75LR1GNnUUONnFBc3k2i90WYDSviwBXhgZsxgXqip4U1dMlnmDbxQFYfFyS2QlmPCwJk5iq4Vc+A6jDMXzn2ELigiin7jciv3kSiw3yvkFzm3s5unfCtIU8 iidh8inyw3UgCi/EbdTE8u4owcLYWxC5kWMLWl5WkIUiTU2oIMiqPmQi2+yz9Ql6LZTTnDimIVMixFnKBJcWWECijVlHDxYi8kUw7SkXaled4KCxRjk01yoIio8WZPWOl2CsTn9oHkY+guiieCyvlfM3tnYi68Wy8QFlaCzJlviyjlGcQiwq8d7DHSUQUaaJAoPMxMWkchka3M4Qx9SXYmXcz3iQkZ4putWZmbM05mTWBDlNoANQ43VCUKcxpm1W cDnn0l+lys7SQ8CrZm4+B9kB0k6m4S/vk9M7hbhGYQw/US9nm8SgVoS/CVIHMzmB0pmGkSzpm0S3QYIS0QSMI/aRYTMiXoS18KicrIwW0fsRPSNAUgcF5KNUABhWc5DTi0U4B2cpfqT8uSVXqBSU+WFsVocwWnti6u4r8zSWD8ORjrFOLmFsxLkySoyWwCkyXvUhrkpGYiQP1Y6SsSvCV0SxEYi8Akj3cHkyU8GiUsC3QbMkFkzHUJLysUTNQuSv iXTsD1lymL1ng03yXdM/yVs8fshmFF4gfSWKXkSxEY2srbmi0e1kkS0CVMqcCUmi3wxmi8tgWi2B4iSGCX5S47lv0P+gDCF2CKTMqXFoO5lwS7UWwSXUUVUfUXkjed5gS+5miTYiQubKjifI6CUNS2CUfrSVn0sJ/QLeQjEglYwW/ii6nPtdeSSKVsj9sH7lTSn8UOC0FkUJZLREoUwhUcPuzfi+wUgs94D8itCQ7kNei5CWoIvikwWzSpOLIUXx qnkHHZ0vcvn7SrJmHSpOIsszGmQtDlmPSrwV/iihKsipRjsi2LErSp6U/SkkJ/S7wi67QGXYCXPmviq6XKUXOHRnfOFpvOM4ZvVsmnMUuHJnCuFpnKuGy6TM7oAOoBOQNED0AGoBJAVSCogZgDSEB0BeQJyD6ATgAjAJCAYgDynRrHt5osBKT6KNxgAkFPoQAIwg6QlfiYcAjARqceFdoT9jgScqKSKRiQlrLda5UKwT8MbRg5sDKk1rLd7ZU6PQ 8sBdCZiePSXkoqnXkkqkHw3izlUk+FDnZ8m6y18kKsd8mNUsdbNU78lTrLVhPw+SnV6ICl1AH96N6b+GdOZui8HWCl2sUD7jiPdbd8MYoR4MBFuWDCmj6FcTnrWBGXrVanhsShSz6TalUUvBQMKAhFniLyxfPQDmK0zdlHs/Mj+Sx+nV4/hjEsHUkfLVYV48op4BM4DjmEDaxMC3iWEC2xnP7JPktYQM6Hg9Py7SDCiQ+Eu53fWq4SS08hSSyTnw 6fNnfAXRyPCH2Ini5vknWIPRScdTjlCZInfU7bhvXfAVUCxTmBUDyWO4iNQfkQagM0FfkdkWChl8CnGRS23QNjdIQryyflrytLgby+yjRcDVl+kXqRXA17Kry39iHy/yj2UDKV+uDfJksTAXrM8uVxSkijfEFqUYcNqU1Xfpr1Ss8UwkC8UhLLET1cXaEbsMWgRWVcj3ijuVPii0hvSplSfUyxjvi6zjPFe4RPlQEGHqAkm0yZ9gPkJBVaMFBV1y 1QwhJaqSkOYhVzfYLjVyo26oKzV5E06ngF0akhD8WOkHivBW1ytSSu0EgRtSfRQtMXBU1yn+ZoKkkgEiiqgubeNFwmJjn3kecWeiNOjMMQnnk5Ynm8yCMpFy1sgly9Jxp0Ev6dEQuxKcfewHLB3nJGDnTp7cfkBSFMjvhXvbV4ojmyypwwD8JoqRcAxVDqOPjGKhZFfSK0WZUUjiZ2ffaf5TNiF0VChIid1imKllbGKlxVWKqnm1zWnnjEGZzTCw 7mEnH5liUZciKcNxihKyXmC8r4XtGA6iBiTe74RABnQZMJV48tRiPsftiEGSFJO7TJWM8tRhrWcigikT+k4nbZJmKvxWWKh4ys2UGj74OdmlTbRXFyxKTKKvpiH8NoIqzf2ybi4OxziiEUSK/kybC8EVjikCb+BMkXMK3hWavFJwsUF4hakcnRhvZtJXy3OpHy/kzp8xwxwUCpz3NaBkGczfmmxDxx8tSzzqka0ntECHScdFMJ0mD9bMaYkwBBTw geRIlAxcJzlVszMGuUUL5rI9cyPGSmRL2JWyx4gqwWUJq6s3ewgbTAFqkiFoWR8JPC8uMeW5gm9yhsgeb8tLAK54xAJI+I4C+jNKm+i/rQ3iNshixB7lwo7FwcUHmQh5SfldKRxjA0ArAgJOmRARQfpmVBCiDUIMRusIDRQSUKitwJ9gPCGfpv0MzgfkXbz44n9QlCghiTGI5WbPIgoVYVUV3HH9TVMJpAb2M4CvsbdhP0ZKBZmJv6iAnwwoCh1I hxH+UYpD7kLSohKuCwBWJMPqqgMZb4xkHUwUJflm1kCtAeQ75HyMlwXgGHRW5FTFJoUPC5gK9uYpqMwSKcfTaH6VgWvSjGkeRZWS+UbDRAMxDQCbZsjkTYKz/SiGXEkjKQwMpAwoE6vHlir6T3UClkqyeqwuuSjTI2fBl74UVYWc2NWZICFw8cBmT37AAVyKVpDaEGlQGTVnRkpPyROCJLlFoAVIj0PjSebPchHWKxRlqjUie4MjjRUy7RPpRiUo VYIw0iy5RpcdpLFMHfopGc1jtkJBYQkGZC9q4chsaYIweOBHi8pFJHUi52i0ivtVsacqHv7UCRtBK1ijq1ijjq4aiTqrzhXLMSQu8I6SnUD9jo8iigrcQjBXsotAHqvxjaML5EoVM9Wiyy9X6hAsosqUlI+xU7TiFYWUrii9VAYF9VSy34AyyrigxqvlTfq89UNUP9VsaADVHcYfg5sGslr8KM6WrGM5Iy5skoyyNAiiNGXZvMuGS6fN75ybsnyi CoCyweWCKwZWCqwDWBawXWD6wQ2BdUq8CdvC2BuQZmX7caljJS7viswFzFcyoYDBcIP7FoPyjManCyhYS5TOfW2SZrWyQSyyvjMcVuDw9HwgrIRMSZU2ixKytMQqy4fTnk9WU7wq8lXyUqkvkiViliPeT7nY2USWG+HF6Fqm/yK2UAKdqnofJ84gKXADuU7qm7YDGAdvBQiUCDgjz4ENjDcPLyMsYD4b4PuBd6VBTFQHewvEf2XoUyC5j6OdY4U5 lDIfZOhPqQz7G4KOUmse9YByx9bYfBOXUmbyzJOAyhKZQyhmcLyIGOIOGSatmLSa+DUvCY3BJnO1aYy5LXpPYCJXuSFREoLTnia29wdEfLXhyQ1ZIgTkBQAcyAfvYTDowcWDBQf1jQwCAANACyBWQGyD2QRyAuQNyCeQHyB+QE2AmIbABCAF0BAMZ6hAYbMxhtM2nnECADKAXAAeIC84nvTAB3maURdk7smQALIBiEDrUDwULUtaiiC4QUgCWwYE C4AW2VHa+kBXam7UhAbgjXahjVQgIICDgCgAL6QynhwJyDawKLBVAXkDDgYcAWkQgCogR8CSAOCxOQOt4OgOYD1nejVNnSACFoZcjE0CrmJqshiDwvth5qUIaUkBnYx4IWXJxFdx0LF1gwUxKncADnis6DnipHLyXyy5c4zQY8mKareH8sNTWayjTU6yu8k3IfWWCWbPRlU/TUfyQzVSWNVitUx+H/kk1iAUqzXuQevT2a6AAQWJzXgIOhCm1Eli q1d2XcABdn6WFBTjUz85w2HFiH4cC4EwE5gQIzCmniFdYXrVlD0nH3ADnZBHRy2hS4I+hRL6TywpaxdnYke6Sgyd7DkUR1XECTBqh073VXRF4oh4alj5YK7yuK3HqjGZFLtIXykw0jwimcWGJkUeqj5Se3hOUUCQ6CWKRhuQP7eMMjxsob+mrzWFSu5JlQu8H17Ni3wQ7kSuCo+VLHIcPIJSKCAx/KJzkFSJqTmittDlC4hi5QbJSHcH5Wgagpw0 wHewBTN5WI9bSQsqWl6maCWH8pe7YGSVJnCuPKT5aLQLlLAGTWUcTbPgz6hJQQnwewJOhsaYcK/AJ0TT85eVOw4cLwMzJ5CNbPn0cIyItkHRw8jHaTn2CuCEGGBTuCi0i76odTjyWSiZUMVHlQ/NzCOWUwVMWRRR/Awjf3UV63iktgjCI4ybOXvUQUIeyj2KugmvC+U4mLeiiZJ6gDCffAMY566SKN45loeHhUiVJaL8xWS1MMQb4GAjJsMMUlon QrVasUXRYajGWdkxkjQGDA1/sdKhyDUki4GzxWp5DPgIai7Vta07VjktAAy69IAUIPrUDayyDWQWyAOQZyCuQDyDeQXyD+QD4gzaubXwgWKhMI02I7xXhbvUdbWbatMBgeOlohEvKWranbV7ax1aCgHGAfa+kDta+kCda9g3dazg0HQbg2Davg0jawQ3jakQ1Ta8Q3gQWbUugSiI18CJEtcaVRjfcQ0barbV7YbrX8gXbV5vfbV4aw7U9rVrVPat yC3a+7UYAR7VvaigARGsMAxGnkCfatyCYfM8lqy+1YogOQDHICvBnIAyDgAO2DQgOABwAEUC0ILrWYwYECZAOxCjobYAMAQgAIACgDmQFTWtrAkC8gFo2tG/oAQAWbXXasw09AfQAigFc6M6o+RKajo0iANeAOgHo0NGtI3bnNnXtGzo2jGno1IQTTVGy6o2zG7o0ZAPo0Z6HnWlAFY3ZAMY1rGm941UhvDDGro07Gno1VAeqnbao41zGjICPgJq nfyQoCXG1Y36AJCDc4ASl84e43bGqAC7Gp41wEa84PGk40ZAH1C4EQzDvGkY2PG4o2XamI1xG6hR/Gz409G4cDRG57V3a+I2WwGY2gm/436AMI3FITt4Lwdo3MAOjDYgfADuUtAC4MOwgR8BhinkEB5JgfE2CgNURvYRCK642rInkFFwQAIwBoIiNbGGumAEAJSBPAOwgcSOegcEGE1fGs40qWRoh1U9aDtGmkAkAHikWy+42Sm4gAigBADeG0aD ra+jDEAOyBsAcSDwm3ACaAYIBzUlU0kAcbB5IcyDYgApCkAZQAUgAAAUIwmoAW61LAtpptNWIgAAlDyAw0MoBdmFsgzTZabGlDabvTbwBVwA6bNCM6aHmDCb1jeiAbjZRBOAOBTFcNqxP4GGgQwPRgztRybSgFkBtTbqadKdhBsAEQBvDYbrSgPZgKjajKAkNJAUkAmdgzXYAosAgBsADkAhQPZg4AOqbNTfZgdTZh9oQJWbCAIwAfwGgj8AKUbj dGdB0gC2bMUI6g5tTJB9AD+AILDbqCEDmbKFGcxcIC2a2zR2bK4TbBsZdXgBQLzpUAMAAbYPpAgAA=== %%\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/devops---cloud/1.devops_index.excalidraw/","title":""},{"content":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== You can decompress Drawing data with the command palette: \u0026lsquo;Decompress current Excalidraw file\u0026rsquo;. For more info check in plugin settings under \u0026lsquo;Saving\u0026rsquo;\nExcalidraw Data Text Elements output = false ^KNwDrMnN\nEmbedded Files a8ba5f3e2a552f2d671ab98e0e7eec126446b3f0: [[PastedImage20241220161127_990.png]]\n%%\nDrawing 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 %%\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/dsa/drawing-2024-12-20-16.00.34.excalidraw/","title":""},{"content":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== You can decompress Drawing data with the command palette: \u0026lsquo;Decompress current Excalidraw file\u0026rsquo;. For more info check in plugin settings under \u0026lsquo;Saving\u0026rsquo;\nDrawing N4IgLgngDgpiBcIYA8DGBDANgSwCYCd0B3EAGhADcZ8BnbAewDsEAmcm+gV31TkQAswYKDXgB6MQHNsYfpwBGAOlT0AtmIBeNCtlQbs6RmPry6uA4wC0KDDgLFLUTJ2lH8MTDHQ0YNMWHRJMRZFAHZFAEYyJE9VGEYwGgQAbQBdcnQoKABlALA+UEl8PGzsDT5GTkxMch0YIgAhdFQAayKuRlwAYXpMenwEEABiADMx8ZAAX0mgA %%\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/excalidraw/drawing-2024-12-23-22.40.59.excalidraw/","title":""},{"content":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== You can decompress Drawing data with the command palette: \u0026lsquo;Decompress current Excalidraw file\u0026rsquo;. For more info check in plugin settings under \u0026lsquo;Saving\u0026rsquo;\nExcalidraw Data Text Elements Build Image ^eWZJIjPV\nDebian Docker container ^OpwgQ18c\nvolume [container:host[dir]] ^OnWoIrDT\nbuilding / config scripts ^9xtscxSV\nDocker image debain ^EIDtegh5\nlb config ^CXzuDqJ4\nlb build ^YEPIXlML\nlb clean ^6zt23472\nlogs ^hVXl1ZNx\nFrontend ^0klfj7B5\niso ^PsWxE1q2\nbootable pendrive ^F2CXSO8Y\n%%\nDrawing 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 %%\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/fusion/drawing-2024-12-28-23.42.13.excalidraw/","title":""},{"content":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== You can decompress Drawing data with the command palette: \u0026lsquo;Decompress current Excalidraw file\u0026rsquo;. For more info check in plugin settings under \u0026lsquo;Saving\u0026rsquo;\nExcalidraw Data Text Elements GUI Application ^5rnVm2Jv\nYour OS Branding Select Architecture select Kernel Firewall Preinstalled Applications Repositories Installer build ISO Image or bootable pendrive ^YYXwcA28 Configurations ^lqPvfcay\nDocker container ^GoQHR4Dt\n1.live-build 2.Debootstrap 3.Syslinux 4.Genisoimage ^ZZKlr7GY\nFinal Image Build Directory ^FJLjEC3B\nWeb-Application ^ho5KgHGa\nAWS/Azure ^okHTxd90\nApis/Middlewares ^7honZn0d\nGUI Application ^vTpdx0Pr\nWEB Application ^hbxvBbbZ\nDocker container ^kgEpoKvh\nBuild image ^TDxZVrHW\nTemplates ^3TuhlTcF\nBuild process ^iKsgcXCS\nFor AI/ML Engineers For Cloud / DevOps For Web Developers ^51Tfm7GK\nFlutter ^5ehGsGs2\nFlutter ^IsZKmhmL\nYour Custom Operating System ^lXmwy1yv\nEmbedded Files cf744400beb6c9cb89b2482af38f39f08b6557a4: [[PastedImage20241224154925_916.png]]\n1b77ab20df4430027a81dc71aec82b66b4257be3: [[PastedImage20241224155201_905.png]]\nce351d7aee1da60352c9a54fdabd8cbf5886ade2: [[PastedImage20241224162835_172.png]]\n9857b557d7518c0fd45a007bc5b3f824261a4ff7: [[PastedImage20241224163007_469.png]]\n%%\nDrawing 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= %%\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/hackathons/diagrams.excalidraw/","title":""},{"content":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== You can decompress Drawing data with the command palette: \u0026lsquo;Decompress current Excalidraw file\u0026rsquo;. For more info check in plugin settings under \u0026lsquo;Saving\u0026rsquo;\nExcalidraw Data Text Elements BuildMYDistro ^33QdO5AM\nGUI-Based Custom Linux Distribution Builder ^CEqVrQIc\nobjectives:\nTo develop a cross-platform GUI-based application for Windows and Linux that allows users to create custom Linux distributions based on Debian. The application will simplify the process of OS customization, making it accessible to users with limited technical expertise while providing powerful options for advanced users. ^iqzwLqwB Key Features:\nFrontend (UI) Backend (Automation and Build process) ^JQK0Erk2 Target audience\nPrivvate Companies Developer and sysadmins Educational Institutions hobbyists Startups ^enjlpkXp Existing Systems\nlinux live kit linux from scratch cubic ^hHMfAh8H Embedded Files 563cdb681f7467852123f0fe1392d30058f6fea0: [[PastedImage20241224125949_518.png]]\n76b8e46064aa63ada3a439c0ac3c5dddf58657bc: [[PastedImage20241224130059_801.png]]\n%%\nDrawing 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= %%\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/hackathons/information-flow.excalidraw/","title":""},{"content":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== You can decompress Drawing data with the command palette: \u0026lsquo;Decompress current Excalidraw file\u0026rsquo;. For more info check in plugin settings under \u0026lsquo;Saving\u0026rsquo;\nExcalidraw Data Text Elements Serve a Static Site with Nginx on Minikube ^gDTWeZ4I\ngit clone https://github.com/yashbhangale/shaids-static.git ^wG64ObWG\nserver { listen 80; server_name localhost;\nlocation / { root /usr/share/nginx/html; index index.html; } }\n^put5acNh\nnginx.conf ^pWQ4Kn1y\nFROM nginx:alpine COPY ./my-static-site /usr/share/nginx/html COPY ./nginx.conf /etc/nginx/conf.d/default.conf ^DFESnvZ3\nDockerfile ^FDefYq0s\ndocker build -t my-static-site:1.0 . ^cN4MHe3g\nLoad the Docker Image into Minikube ^JKMawLpw\nminikube image load my-static-site:1.0 ^oL8X1jJf\nDeploy the Static Site on Minikube ^eCvVQYPy\nkubectl create deployment static-site \u0026ndash;image=my-static-site:1.0 ^mGQQb1HS\nExpose the Deployment as a Service: ^TKj1WPij\nkubectl expose deployment static-site \u0026ndash;type=NodePort \u0026ndash;port=80 ^UGsH1I4K\nminikube service static-site \u0026ndash;url ^FMtHnuzD\nEmbedded Files 5dfd8b01ae2ec861084bf8736886cf408651faf3: [[PastedImage20250109154252_053.png]]\n%%\nDrawing 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 %%\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/kubernates/drawing-2025-01-09-15.31.34.excalidraw/","title":""},{"content":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== You can decompress Drawing data with the command palette: \u0026lsquo;Decompress current Excalidraw file\u0026rsquo;. For more info check in plugin settings under \u0026lsquo;Saving\u0026rsquo;\nExcalidraw Data Text Elements Making Fusion Linux Walkthrough ^xEDTOcHJ\n🛠️ Tools:\nKVM SHELL Live-Build git ^60k1eisf lb Config: ^ZMWbBhFs\n⌨️ Live-build basic commands lb config lb build lb clean \u0026ndash;binary ^yY6epcy2\nCalamares ^xyLT61Wk\nElement Links 53HkJLM1: [[fusion flux#0th Config file]]\n%%\nDrawing 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 %%\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/projects/drawing-2024-12-16-15.56.23.excalidraw/","title":""},{"content":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== You can decompress Drawing data with the command palette: \u0026lsquo;Decompress current Excalidraw file\u0026rsquo;. For more info check in plugin settings under \u0026lsquo;Saving\u0026rsquo;\nExcalidraw Data Text Elements Self learnings and improvements ^R3IN4nL3\n6 [[Social Skills to master for a Magnetic Aura]] ^CpqeR5So\n[[Greatest Comeback]] ^Noj51VWr\n[[how to be a good communicator]] ^xHxhjZmw\n%%\nDrawing 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= %%\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/self-learnings-and-improvements/drawing-2024-12-18-11.31.58.excalidraw/","title":""},{"content":"Access modifiers in Java determine the visibility and accessibility of classes, methods, and variables\n1. public access Modifiers The public modifier allows access from anywhere (other classes and packages).\n// File: Main.java public class Main { public static void main(String[] args) { Person person = new Person(); person.name = \u0026#34;John\u0026#34;; // Accessible because it\u0026#39;s public person.displayInfo(); // Accessible because it\u0026#39;s public } } // File: Person.java public class Person { public String name; // Public variable, accessible from anywhere public void displayInfo() { // Public method, accessible from anywhere System.out.println(\u0026#34;Name: \u0026#34; + name); } } 2. private access modifiers The private modifier restricts access to within the same class only. You can\u0026rsquo;t access it from outside the class.\npublic class BankAccount { private double balance; // Private variable, not accessible from outside the class public BankAccount(double initialBalance) { balance = initialBalance; } // Public method to access the private variable public void deposit(double amount) { balance += amount; } public void displayBalance() { System.out.println(\u0026#34;Balance: \u0026#34; + balance); } } public class Main { public static void main(String[] args) { BankAccount account = new BankAccount(1000); // account.balance = 500; // Error! \u0026#39;balance\u0026#39; is private account.deposit(500); // We can access this public method account.displayBalance(); // We can access this public method } } 3. protected access modifier The protected modifier allows access within the same package and subclasses (even in different packages).\n// File: Animal.java public class Animal { protected String type = \u0026#34;Animal\u0026#34;; // Protected variable protected void displayType() { // Protected method System.out.println(\u0026#34;This is a \u0026#34; + type); } } // File: Dog.java (same package or subclass in a different package) public class Dog extends Animal { public void showType() { System.out.println(\u0026#34;Dog type: \u0026#34; + type); // Accessible because it\u0026#39;s protected displayType(); // Accessible because it\u0026#39;s protected } } // File: Main.java public class Main { public static void main(String[] args) { Dog dog = new Dog(); dog.showType(); // Accessible because \u0026#39;Dog\u0026#39; is a subclass of \u0026#39;Animal\u0026#39; } } 4. Default (No Modifier) If no access modifier is specified, the class or member is package-private (accessible only within the same package).\n// File: PackageExample.java (package-private class) class PackageExample { String message = \u0026#34;Hello!\u0026#34;; // Package-private variable void showMessage() { // Package-private method System.out.println(message); } } // File: Main.java (same package) public class Main { public static void main(String[] args) { PackageExample example = new PackageExample(); example.showMessage(); // Accessible because both classes are in the same package } } Key Points: public: Accessible from anywhere. private: Accessible only within the class. protected: Accessible within the same package or subclasses. Default (no modifier): Accessible within the same package only. ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/access-modifiers-in-java/","title":"Access Modifiers in Java"},{"content":"find all possible solution and use the one you want (pehale isstamal kare fir vishwas kare)\n[[5. Recursion]] tree (for complex problem) solutions are in branches\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/6.-backtracking/","title":"Backtracking"},{"content":"module 4 Data stream management system ? Ad hoc queries and standing queries (bda) 2 sampling techniques for stream processing in bda Bloom filter Flajolet martin algo DGIM algo ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/ia-2-exam/module-wise-important-question-for-bda/","title":"BDA impt questions"},{"content":"Syllabus Question bank given by mam Q.1 Compare different types of blockchain Blockchains can be categorized into several types based on their architecture and use case. Below are the primary types:\n1. Public Blockchain Description: A fully decentralized blockchain open to anyone. Users can join the network, participate in consensus (e.g., mining or staking), and validate transactions. Examples: Bitcoin, Ethereum. Advantages: Decentralization: No central authority controls the network. Transparency: All transaction history is publicly accessible. Security: The decentralized nature makes it resistant to attacks. Disadvantages: Scalability: Public blockchains tend to be slower due to the large number of participants and the consensus process. Energy consumption: Proof-of-work (PoW) consensus used in some public blockchains (like Bitcoin) is energy-intensive. 2. Private Blockchain Description: A permissioned blockchain that restricts access to certain users. Only authorized individuals can join the network, validate transactions, or participate in consensus. Examples: Hyperledger, Corda. Advantages: Control: Organizations can control who participates in the network. Efficiency: Transactions are processed faster due to fewer participants. Privacy: Data is not visible to the general public, only to authorized parties. Disadvantages: Centralization: Private blockchains are not as decentralized as public ones. Trust: Users must trust the governing authority or organization. 3. Consortium Blockchain Description: A semi-decentralized blockchain where multiple organizations or institutions collaborate to manage the blockchain. These are usually permissioned but operated by a group rather than a single entity. Examples: R3 (used for financial institutions), Energy Web Chain. Advantages: Collaboration: Multiple parties share control, reducing the likelihood of a single entity\u0026rsquo;s dominance. Speed and Scalability: Similar to private blockchains, but with more decentralization. Trust: Less reliance on a single organization, with governance shared across multiple trusted entities. Disadvantages: Complexity: Coordinating between multiple organizations can be challenging. Restricted access: Not fully open to the public, limiting widespread participation. 4. Hybrid Blockchain Description: A combination of both public and private blockchains. It allows for certain data to be made public while keeping other data private. Examples: Dragonchain. Advantages: Flexibility: Organizations can choose which information to keep public and which to keep private. Efficient governance: Can offer the benefits of both public transparency and private control. Disadvantages: Complexity: Managing the two-tier system of public and private can be more challenging. Not fully decentralized: Often still requires a governing entity to manage private parts. 5. Sidechains Description: An independent blockchain that runs in parallel to a main blockchain (e.g., the Bitcoin network). Assets can be moved between the main chain and the sidechain, but the sidechain operates with its own set of rules. Examples: Liquid Network (built on Bitcoin), Polygon (built on Ethereum). Advantages: Scalability: Offloads transactions from the main chain, improving speed and reducing congestion. Customization: Sidechains can be tailored for specific purposes or use cases. Disadvantages: Security: The security of the sidechain depends on its own mechanisms, which may be weaker than the main chain. Interoperability: Transferring assets between the main chain and sidechain requires robust mechanisms. These blockchain types serve different use cases, and the choice depends on factors like decentralization, privacy, scalability, and the specific goals of the project or organization.\n![alt text](Pasted image 20241012183147.png)\nQ.2 Explain PAXOS consensus Algorithm for Private Blockchain. The Paxos algorithm is a consensus protocol used in distributed systems to agree on a single value or decision, even in the presence of failures. It is primarily designed to maintain consistency across multiple distributed nodes (or servers) that may fail or be unreliable.\nKey Components: Proposers:\nThese nodes propose values that the system should agree upon. A proposer suggests a value to be chosen by the system. Acceptors:\nThese are the nodes that vote on proposals from proposers. Acceptors play a crucial role in deciding which value is chosen. A value is only accepted if a majority of acceptors agree on it. Learners:\nThese nodes learn the final value once a consensus is reached. Learners do not participate in proposing or accepting but are informed of the final decision so they can update their state. Paxos Algorithm Phases: Prepare Phase:\nThe proposer sends a prepare request to a majority of acceptors, along with a proposal number (this number must be unique and higher than any previously used number). Each acceptor responds by either promising not to accept any proposal with a lower number or by sending back the highest-numbered proposal they have already accepted (if any). Promise Phase:\nIf an acceptor promises a proposal, it guarantees that it will not accept any proposal with a number lower than the one it just promised. The acceptor may also send back information about any proposal it has already accepted in previous rounds (if applicable). Propose Phase:\nAfter receiving promises from a majority of acceptors, the proposer selects the proposal with the highest number it received from the acceptors, or its own value if no other proposal has been made. The proposer then sends this proposal to the acceptors, asking them to accept it. Accept Phase:\nIf a majority of acceptors accept the proposal, it becomes the final chosen value. Acceptors communicate the result to the learners, who then record this chosen value. Key Features of Paxos: Fault Tolerance:\nPaxos can tolerate failures of some nodes as long as a majority of nodes (acceptors) are functional. Even if some nodes fail, as long as a majority reaches consensus, the system can continue to operate. Consensus in a Distributed System:\nThe main goal of Paxos is to achieve consensus among distributed nodes, ensuring that all functioning nodes agree on the same value. Resilience to Network Partitions:\nPaxos can handle network partitions where some nodes may not be able to communicate with others, as long as a majority of nodes are reachable. Guarantees Consistency:\nPaxos ensures that once a value is chosen, all nodes will eventually agree on that value, even if new proposals are made in the future. Pros and Cons: Advantages:\nEnsures strong consistency across nodes in a distributed system. Tolerates node failures and network issues. Disadvantages:\nCan be slow in practice, especially if there are frequent failures or network delays, because consensus requires communication with a majority of acceptors. Complex to implement correctly due to the intricacies of its phases and guarantees. Summary: Paxos is a robust algorithm for achieving consensus in distributed systems. By coordinating multiple nodes through proposers, acceptors, and learners, Paxos ensures that a single, consistent decision is made, even in the presence of node failures. However, the algorithm\u0026rsquo;s complexity and potential latency in failure-prone environments are its primary challenges.\nQ.3 Comparison between hyperledger fabric and other techniques ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/ia-2-exam/blockchain-for-ia-2/","title":"Blockchain for ia"},{"content":" Module 1 [[Distributed ledger technology]] [[Blockchain]] [[features of blockchain]] [[Consensus mechanisms]] [[Merkle Tree]] [[Components of Blocks in blockchain ]] [[Types of blockchain]] [[Consensus Protocol]] [[how proof of work solves the problem of double spending]] [[poa,pos,pow,lpos,pbft,pob,poet]] [[Blockchain 2.0]] [[Blockchain solution actors]] [[Transactions in bitcoin network]] [[Architecture of Ethereum]] [[Smart Contract]] [[Private Blockchain System]] [[Difference between types of Blockchain ]] [[State Machine Replication ]] [[PAXOS]] [[RAFT]] [[BYZANTINE FAULT Tolerant algo ]] [[Hyperledger Platform]] [[Hyperledger Fabric]] [[Case Study of Supply chain management using hyperledger]] [[Difference Between Bitcoin, Altcoins and Tokens]] [[hot wallet and cold wallet]] [[ERC721 and ERC20]] [[DEFI]] [[Initial Coin Offering]] [[Security token offering]] [[UTXO]] [[DAO]] [[Fungible Tokens (FTs) and Non-Fungible Tokens (NFTs)]] ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/blockchain-technology/1.-main/","title":"Blockchain technologies"},{"content":"largest Bubble (element ) ko end bhej and sorting kar\nsimple comparison-based sorting algorithm where each pair of adjacent elements is compared, and if they are in the wrong order, they are swapped.\nThe process repeats until no swaps are needed, indicating that the array is sorted. It\u0026rsquo;s called \u0026ldquo;bubble\u0026rdquo; sort because the largest element \u0026ldquo;bubbles\u0026rdquo; to the top in each iteration.\nSteps Start from the first element and compare the current element with the next element. If the current element is greater than the next element, swap them. Move to the next pair of elements and repeat the comparison. Continue this process for each pair of elements in the array. After the first pass, the largest element will have \u0026ldquo;bubbled\u0026rdquo; to the last position. Repeat the process for the rest of the array (ignoring the last sorted elements in subsequent passes) until no swaps are made, meaning the array is sorted code: public class main { public static void main (String arg[]){ int arr[] = {1,2,3,4,5,6}; for (int i=0; i\u0026lt;arr.length-i; i++) for (int j = 0 ; j \u0026lt; arr.length - i - 1; j++){ if (arr[j] \u0026gt; arr [j + 1] ) { int temp = arr[j]; arr[j] = arr [j + 1]; arr[j + 1] = temp; } } System.out.println(\u0026#34;Sorted array:\u0026#34;); for (int i = 0; i \u0026lt; arr.length; i++) { System.out.print(arr[i] + \u0026#34; \u0026#34;); } } } code with user input import java.util.Scanner; public class Main { public static void main(String arg[]){ Scanner sc = new Scanner(System.in); // Ask user for the size of the array System.out.print(\u0026#34;Enter the number of elements in the array: \u0026#34;); int n = sc.nextInt(); // Declare an array of size n int arr[] = new int[n]; // Accept array elements from user input System.out.println(\u0026#34;Enter the elements of the array:\u0026#34;); for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextInt(); } // Bubble sort algorithm for (int i = 0; i \u0026lt; arr.length - 1; i++) { for (int j = 0; j \u0026lt; arr.length - i - 1; j++) { if (arr[j] \u0026gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } // Print the sorted array System.out.println(\u0026#34;Sorted array:\u0026#34;); for (int i = 0; i \u0026lt; arr.length; i++) { System.out.print(arr[i] + \u0026#34; \u0026#34;); } sc.close(); } } Time and space complexity ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/sorting-algorithms/1.-bubble-sort/","title":"Bubble sort"},{"content":" Fundamentals of Deep Learning Def: Deep Learning is a subset of machine learning that mimics the workings of the human brain to process data and create patterns for decision-making. It uses neural networks with multiple layers, hence the term \u0026ldquo;deep.\u0026rdquo; Neural Networks: Neural networks are the building blocks of deep learning. Artificial Neural Networks (ANN) are inspired by biological neural networks and consist of interconnected layers of neurons (nodes). Key components of a neural network include input layers, hidden layers, and output layers Layers in Neural Networks: Input Layer: The first layer that receives input data (e.g., images, text, numerical values). Hidden Layers: Intermediate layers between input and output layers, where complex computations and transformations happen. Deep networks typically have multiple hidden layers. Output Layer: Produces the final output (e.g., classification label, predicted value). Neurons (Nodes): Neuron: The basic unit in a neural network, which computes the weighted sum of inputs, adds a bias term, and passes it through an activation function. Each neuron receives input from the previous layer, processes it, and sends output to the next layer. Weights and Biases: Weights: The strength of the connection between neurons; these are learned during training. Bias: A constant added to the weighted sum, allowing the model to fit the data more flexibly. #Activation function\nAdd non-linearity to the neural network, enabling it to learn complex patterns. Common activation functions: ReLU (Rectified Linear Unit): f(x)=max(0,x)f(x) = max(0, x)f(x)=max(0,x), used to prevent saturation in deep networks. Sigmoid: Squashes input values between 0 and 1, useful for binary classification. Tanh: Squashes input values between -1 and 1. Softmax: Normalizes output into a probability distribution, used in multi-class classification. Feedforward Process: In a feedforward neural network, data moves forward from the input layer through hidden layers to the output layer. Each layer transforms the input data using weights, biases, and activation functions. Loss Function (Cost Function): Measures the difference between the predicted output and the actual target. Common loss functions: Mean Squared Error (MSE): Used for regression tasks. Cross-Entropy Loss: Used for classification tasks. The goal is to minimize the loss during training. Backpropagation: A method used to update the weights in the network to minimize the loss. Involves two steps: Forward Pass: Compute the output and loss for given input. Backward Pass: Compute the gradient of the loss with respect to each weight using the chain rule, and adjust the weights. Optimization Algorithms: These algorithms adjust the weights and biases to minimize the loss. Common optimizers: Stochastic Gradient Descent (SGD): Iteratively updates weights by calculating gradients of the loss function. Adam: Adaptive optimization algorithm that uses running averages of gradients and squared gradients, typically faster than SGD. Epochs, Batch Size, and Iterations: Epoch: One complete pass of the entire training dataset through the network. Batch Size: The number of training examples processed before the model\u0026rsquo;s internal parameters are updated. Iteration: A single update of the model\u0026rsquo;s parameters, often happening after processing one batch. Regularization Techniques: Used to prevent overfitting by penalizing overly complex models. Common techniques: L2 Regularization (Ridge): Adds a penalty proportional to the square of the weights. Dropout: Randomly drops neurons during training to force the network to learn more robust features. Early Stopping: Stops training when performance on the validation set starts degrading. Convolutional Neural Networks (CNN): Specialized for processing grid-like data such as images. Key components: Convolutional Layers: Extract spatial features using filters. Pooling Layers: Reduce the spatial dimensions of the data to prevent overfitting and reduce computation. Fully Connected Layers: The final layers that aggregate the features and produce the output. Recurrent Neural Networks (RNN)**: Designed for sequential data, such as time series, text, or speech. They maintain a memory of previous inputs, allowing them to capture temporal dependencies. Variants: LSTM (Long Short-Term Memory): Tackles the issue of short-term memory in traditional RNNs, effectively learning long-term dependencies. GRU (Gated Recurrent Unit): A simplified version of LSTM with fewer parameters. Autoencoders: A type of unsupervised neural network used for dimensionality reduction or feature learning. It consists of an encoder that compresses the input into a lower-dimensional representation and a decoder that reconstructs the original input. Generative Models: These models generate new data instances. Examples: GANs (Generative Adversarial Networks): Two networks (a generator and a discriminator) are trained together; the generator tries to create realistic data while the discriminator tries to distinguish real from fake data. VAEs (Variational Autoencoders): A generative model that learns latent representations of data and generates new instances. Multilayered Perceptron ( MLPS )Generative Models: These models generate new data instances.\nExamples:\nGANs (Generative Adversarial Networks): Two networks (a generator and a discriminator) are trained together; the generator tries to create realistic data while the discriminator tries to distinguish real from fake data. VAEs (Variational Autoencoders): A generative model that learns latent representations of data and generates new instances. A multi-layer perception is a neural network that has multiple layers.\nMLP is a type of [[feedforward]] artificial neural network.\nIt consists of at least three layers: an input layer, hidden layer(s), and an output layer.\nTo create a neural network we combine neurons together so that the outputs of some neurons are inputs of other neurons.\nIt is fully connected dense layers, which transform any input dimension to the desired dimension\nEach connection has an associated weight.\nNeurons have biases, added to the weighted sum before applying the activation.\nEvery node in the multi-layer perception uses a [[Activation Functions]] function The sigmoid activation function takes real values as input and converts them to numbers between 0 and 1 using the sigmoid formula. Learning process Uses backpropagation to update weights based on the error. The goal is to minimize a loss function using gradient descent. Use cases of MLP MLPs are used for tasks like classification, regression, and function approximation. Q. Design and implement AND Gate using perceptron truth table Linear Separability A dataset is said to be linearly separable if there exists a straight line (in 2D) or a hyperplane (in higher dimensions) that can separate the data into distinct classes without any overlap or misclassification.\nFor binary classification, it means you can draw a line (or hyperplane) such that all the points of one class lie on one side of the line, and all the points of the other class lie on the opposite side.\nExample of Linear Separability: Linearly Separable Data: Consider a dataset with two classes of points, Class A and Class B, which can be divided perfectly by a straight line (or plane). All Class A points lie on one side, and all Class B points lie on the other. Non-Linearly Separable Data: A dataset where no straight line can completely separate the two classes. An example is the XOR problem. The perceptron, ==one of the simplest neural networks==, can only solve problems that are linearly separable. If the data cannot be separated by a straight line (or hyperplane), the perceptron cannot classify it correctly.\nsingle layer perceptron can only solve problems which are linearly separable\nSingle-layer perceptrons fail for non-linearly separable data because they can only create linear decision boundaries.\nMultilayer Perceptron (MLP) : When moving to multilayer networks (i.e., deep neural networks with hidden layers), the problem of linear separability is no longer a constraint.\n[!Activation Functions] Non-linear activation functions (like ReLU, Sigmoid, or Tanh) in deep networks help create complex decision boundaries, making it possible for the network to learn non-linear relationships between inputs and outputs.\nFor binary classification, the goal is to find a hyperplane that divides two classes, say y = 1 and y = -1\nThe equation of a hyperplane can be written as:\n$$ \\mathbf{w}^T \\mathbf{x} + b =0 $$ - Where w\\mathbf{w}w is the weight vector, x\\mathbf{x}x is the input vector, and bbb is the bias. - If wTx+b\u0026gt;0\\mathbf{w}^T \\mathbf{x} + b \u0026gt; 0wTx+b\u0026gt;0, the input belongs to one class. - If wTx+b\u0026lt;0\\mathbf{w}^T \\mathbf{x} + b \u0026lt; 0wTx+b\u0026lt;0, the input belongs to the other class.\nIf there exists such a hyperplane for a dataset, the data is linearly separable. Linear vs Non-Linear Decision Boundaries Linear Boundary: A single hyperplane that separates two classes, achievable by a perceptron or a linear SVM.\nNon-Linear Boundary: More complex, curved boundaries created by deep neural networks or SVMs with kernels.\nThree classes of Deep learning 1. Feedforward Neural Networks (FNNs) Structure: Data flows in one direction, from the input layer to the output layer through hidden layers, without any loops or cycles. Examples: Multilayer Perceptron (MLP), Fully Connected Networks. Use Cases: Classification, regression, simple pattern recognition tasks where data does not have sequential or spatial relationships. Key Characteristics: Each neuron in one layer is connected to every neuron in the next layer. No memory or context of past inputs is retained. Typical Applications: - Image classification (in simple cases), spam detection, and basic fraud detection.\n2. Convolutional Neural Networks (CNNs) Structure: Designed to process data with a grid-like topology, such as images. CNNs use convolutional layers that apply filters to capture spatial hierarchies in the data. Examples: VGG, ResNet, LeNet. Use Cases: Image and video recognition, object detection, image generation, spatial data analysis. Key Characteristics: Convolutional layers extract features from the input (e.g., edges, textures in images). Pooling layers reduce dimensionality, making computation more efficient. Fully connected layers towards the end aggregate the extracted features for final predictions. Typical Applications: - Computer vision tasks: image classification (e.g., CIFAR-10, ImageNet), object detection (e.g., self-driving cars), facial recognition.\n3. Recurrent Neural Networks (RNNs) Structure: These networks are designed for sequential data, where the output depends not only on the current input but also on the previous inputs (i.e., they have memory). They introduce cycles within the network to retain information. Examples: Vanilla RNN, Long Short-Term Memory (LSTM), Gated Recurrent Unit (GRU). Use Cases: Time-series forecasting, natural language processing (NLP), speech recognition, video sequence analysis. Key Characteristics: Recurrent connections allow information to persist, enabling the model to handle sequences and time-dependent data. RNNs can suffer from vanishing/exploding gradient problems, but variants like LSTMs and GRUs mitigate these issues. Typical Applications: - Language translation, sentiment analysis, speech-to-text, stock price prediction, and chatbots.\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/deep-learning/module-1/1.-fundamentals-of-neural-networks/","title":"Deep Learning"},{"content":" In java we call functions as method function is nothing but the block of code. /* return_type name (arguments) { //body return statement } */\nIn coding world the word \u0026ldquo;dry\u0026rdquo; means don\u0026rsquo;t repeat yourself\nreturn is the value of the function call\npass the value of numbers when you are calling the method in main() no pass-by reference in java only pass-by value\nprimitive: int , short,char,byte \u0026hellip;. \u0026mdash;\u0026ndash;\u0026gt; just passing value object and stuff \u0026mdash;\u0026ndash;\u0026gt; passing value of the reference\nscoping in java function scope if you define any thing in function then you will only access those things inside the function this is also applicable to args\nScoping in Java refers to the visibility and lifecycle of variables, methods, and classes within different parts of a program. Proper scoping ensures that variables and methods are accessible only where they are needed, reducing potential errors and improving code readability and maintainability.\n1. Class Scope What it is: Variables and methods declared at the class level. Visibility: These are accessible throughout the class. Access can be controlled using access modifiers (public, protected, private, or package-private). Example: public class Example { private int count; // Class scope (accessible throughout the class) public void increment() { count++; // Accessible here } public int getCount() { return count; // Accessible here too } } 2. Block Scope What it is: Variables declared within a block (e.g., loops, conditionals). Visibility: These are only accessible within the block where they are declared. Example: public void printEvenNumbers() { for (int i = 0; i \u0026lt; 10; i++) { // `i` has block scope if (i % 2 == 0) { System.out.println(i); } } // System.out.println(i); // Error: `i` is not accessible here } 3. Loop Scope Loop variables are scoped to the loop they are declared in: for (int i = 0; i \u0026lt; 5; i++) { System.out.println(i); // `i` is accessible here } // System.out.println(i); // Error: `i` is out of scope anything that is initialize outside the block can be used inside the block, anything that is initialize inside cannot use outside\nShadowing in java Shadowing happens when a variable in an inner scope (e.g., a method or block) has the same name as a variable in an outer scope (e.g., a class or enclosing block). The inner variable takes precedence, \u0026ldquo;hiding\u0026rdquo; the outer variable.\nKey Points: Occurs in Nested Scopes:\nLocal variables, method parameters, or block variables can shadow instance or class variables. Accessing Shadowed Variables:\nUse this to access instance variables. Use the class name to access static variables. Examples:\nInstance Variable Shadowed: int x = 10; // Instance variable public void setX(int x) { // Parameter shadows instance variable this.x = x; // `this.x` refers to the instance variable } Static Variable Shadowed: static int x = 100; // Static variable public void displayX() { int x = 200; // Local variable shadows static variable System.out.println(x); // Local (200) System.out.println(Example.x); // Static (100) } Best Practices:\nAvoid reusing variable names unnecessarily. Use explicit qualifiers like this or the class name to clarify which variable you’re referencing. Variable Arguments Function overloading occurs at compiletime\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/dsa/functions-in-java/","title":"functions in java"},{"content":"Insertion Sort: Insertion Sort is a simple, comparison-based sorting algorithm that builds the final sorted array one element at a time. It works by dividing the array into a \u0026ldquo;sorted\u0026rdquo; and \u0026ldquo;unsorted\u0026rdquo; section. The sorted section is built from left to right, and each new element is inserted into its correct position in the sorted section.\nHow Insertion Sort Works: Assume the first element is already sorted. Take the next element and compare it with elements in the sorted section, moving it left until it is in the correct position. Repeat for all elements in the unsorted section. Time Complexity: Worst-case and average-case time complexity: O(n²) (when the array is in reverse order). Best-case time complexity: O(n) (when the array is already sorted). import java.util.Arrays; public class InsertionSort { // Function to implement insertion sort public static void insertionSort(int[] arr) { int n = arr.length; // Start from the second element since the first is \u0026#34;already sorted\u0026#34; for (int i = 1; i \u0026lt; n; i++) { int key = arr[i]; // Element to be inserted into the sorted part int j = i - 1; // Move elements that are greater than \u0026#39;key\u0026#39; one position to the right while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key) { arr[j + 1] = arr[j]; // Shift element to the right j--; } // Insert \u0026#39;key\u0026#39; into its correct position arr[j + 1] = key; } } public static void main(String[] args) { int[] arr = {12, 11, 13, 5, 6}; System.out.println(\u0026#34;Original array: \u0026#34; + Arrays.toString(arr)); // Perform insertion sort insertionSort(arr); System.out.println(\u0026#34;Sorted array: \u0026#34; + Arrays.toString(arr)); } } Explanation: Outer Loop: Iterates through the array starting from the second element, because the first element is already considered \u0026ldquo;sorted.\u0026rdquo; Inner Loop: Compares the current element (key) with elements in the sorted section. If the current element is smaller, it shifts the larger elements to the right. Key: The key is inserted into the correct position in the sorted section after shifting. How It Works: In the first pass, the second element is compared to the first. If the second element is smaller, it is inserted before the first element. In the next pass, the third element is compared to the elements in the sorted section (first and second elements). It is inserted into its correct position. The process continues until all elements are sorted. Key Points: Insertion Sort is efficient for small datasets or nearly sorted arrays. It has a time complexity of O(n²) in the worst and average cases, but O(n) in the best case when the array is already sorted. It is a stable sorting algorithm, meaning it maintains the relative order of elements with equal values. It can be more efficient than selection or bubble sort for small or nearly sorted arrays. ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/sorting-algorithms/3.-insertion-sort/","title":"insertion sort"},{"content":"java is object oriented\nbasic program in java we convert javacode to bite code with javac (javacompiler) it will create main.class (it is bite code) java follows unicode principals java is platform independent\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } Function Block of code, collection of code that we can use again and again\nThe main function in Java is the entry point of any Java program. It is the method that the Java Virtual Machine (JVM) calls to start the execution of a program. Without the main method, the program will not run.\nPublic means this class is access everywhere class name grp of prop and funs Main name of file name of program and public class is same\nmain entry point of java prog , most impt , prog will not run without it void is a keyword used as a return type for methods that do not return any value. static is a keyword used to indicate that a field, method, or block belongs to the class rather than an instance of the class. It is shared among all objects of the class.\npublic class Main{ public static void main(string[] args){ System.out.println(\u0026#34;Hello World!\u0026#34;); } } Class Class: HelloWorld is the class name. In Java, everythingbelongs to a class. first letter is always capital (of class) a class is a blueprint or template for creating objects defines the properties (fields) and behaviors (methods) that the objects created from the class will have in intellij shortcut for public static void main is psvm sout shortcut for System.out.println();\nMethod Method: public static void main(String[] args) is the main method. This is where the program starts running. System.out.println: This prints output to the console. Variables int age = 25; double price = 19.99; char grade = \u0026#39;A\u0026#39;; boolean isJavaFun = true; control statements // if-else int x = 10; if (x \u0026gt; 5) { System.out.println(\u0026#34;x is greater than 5\u0026#34;); } else { System.out.println(\u0026#34;x is 5 or less\u0026#34;); } Loops //for loop for (int i = 0; i \u0026lt; 5; i++) { System.out.println(i); } //while loop int i = 0; while (i \u0026lt; 5) { System.out.println(i); i++; } Methods in JAVA public class Calculator { public static int add(int a, int b) { return a + b; } public static void main(String[] args) { int result = add(5, 3); System.out.println(\u0026#34;Sum: \u0026#34; + result); } } Return Type: The type of data the method returns (int in this case). Parameters: Values passed into the method (int a, int b). [[2. oops in java]] Classes and Objects: Classes are blueprints, and objects are instances.\nclass Dog { String breed; int age; void bark() { System.out.println(\u0026#34;Woof!\u0026#34;); } } public class Main { public static void main(String[] args) { Dog myDog = new Dog(); myDog.breed = \u0026#34;Labrador\u0026#34;; myDog.age = 3; myDog.bark(); } } Inheritance: One class can inherit properties from another class.\nclass Animal { void eat() { System.out.println(\u0026#34;This animal eats.\u0026#34;); } } class Dog extends Animal { void bark() { System.out.println(\u0026#34;Woof!\u0026#34;); } } [[Access Modifiers in Java]] Java provides four types of access modifiers:\npublic: Accessible from anywhere. private: Accessible only within the class. protected: Accessible within the package and subclasses. No modifier (default): Accessible within the same package. Exception Handling in Java Java provides a robust mechanism for handling errors using try, catch, and finally.\ntry { int result = 10 / 0; // This will cause an error } catch (ArithmeticException e) { System.out.println(\u0026#34;Can\u0026#39;t divide by zero!\u0026#34;); } finally { System.out.println(\u0026#34;This block always executes.\u0026#34;); } Output in java output refers to displaying data or results to the user, typically using methods like System.out.print() or System.out.println().\nSystem.out.print(): Prints text on the same line. System.out.println(): Prints text and moves to the next line. System.out.printf(): Formats output. public class OutputExample { public static void main(String[] args) { System.out.print(\u0026#34;Hello \u0026#34;); // Output: Hello (on the same line) System.out.println(\u0026#34;World!\u0026#34;); // Output: World! (on a new line) System.out.printf(\u0026#34;Age: %d\u0026#34;, 25); // Output: Age: 25 } } Input in Java we use Scanner Class to take input from us\nIn Java, input refers to reading data from the user, typically using the Scanner class.\nSteps for Input: Import the Scanner class: import java.util.Scanner; Create a Scanner object: Scanner sc = new Scanner(System.in); Use methods like nextInt(), nextLine(), etc., to read input. import java.util.Scanner; public class InputExample { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.print(\u0026#34;Enter your name: \u0026#34;); String name = sc.nextLine(); // Reads a string System.out.print(\u0026#34;Enter your age: \u0026#34;); int age = sc.nextInt(); // Reads an integer System.out.println(\u0026#34;Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age); } } [[primitive]] cannot break one datatype into another\nprimitive types are the most basic data types that represent simple values. They are not objects and are predefined by the language. Each primitive type has a fixed size and value range.\ncomments in java //\ntype casting compressing larger value to the smaller Typecasting in Java is the process of converting one data type to another. There are two types of typecasting:\nImplicit (Automatic) Typecasting: Happens automatically when converting from a smaller to a larger data type (e.g., int to long).\nExample:\nint num = 10; long bigNum = num; // Implicit casting (int to long) Explicit (Manual) Typecasting: Required when converting from a larger to a smaller data type, and it is done manually by the programmer (e.g., double to int).\nExample:\ndouble price = 99.99; int roundedPrice = (int) price; // Explicit casting (double to int) Key Points: Implicit casting occurs automatically when no data loss is expected. Explicit casting may lose data or precision, so it requires manual intervention. nice\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/1.-basic-java/","title":"java Basics"},{"content":"7 [[Information system]] [[Computer Based Information System (CBIS)]] impt [[Impact of Information system in organisation and society]] [[ORGANIZATIONAL STRATEGY, COMPETITIVE ADVANTAGES AND IS]] [CRMS] [data mart and data warehouse] [ERP] ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/mis/1.-mis/","title":"MIS"},{"content":"[[NLP Techknowledge.pdf]]\n[[Natural language processing]] [[Knowledge in Language Processing]] [[Ambiguities in Natural Language]] [[Challenges of NLP]] module 2 [[Porter Stemmer]] [[n-gram]] module 3 [[Part-of-Speech (POS) Tagging]] [[CFG Hinglish ]] module 4 [[semantic analysis]] [[Difference betn semantic analysis and syntactic analysis]] [[Relation between words and senses]] [[Word Sense Disambiguation]] module 5 [[pragmatics]] [[Discourse analysis]] ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/sem7-final-exam/nlp/1.-main/","title":"Natural language processing"},{"content":"1. code to print simple rectangle public class patterns { public static void main(String[] args) { int n = 4; // for rows int m = 5; //for columns for (int i = 1 ; i \u0026lt;= n ; i++){ // outerloop to print rows for( int j = 1; j \u0026lt;= m; j++){ // inner loop to print columns System.out.print(\u0026#34;*\u0026#34;); // print *s } System.out.println(); // move to next line after n = 4 row } } } 2. hollow rectangle public class hollowpatterns { public static void main(String[] args) { int n = 4; // n = 4 rows int m = 5; // m = 5 columns for(int i = 1 ; i \u0026lt;=n ; i++){ // loop for rows for (int j = 1 ; j \u0026lt;=m ; j++){ // loop for cloumns if (i == 1 || j == 1|| i == n||j ==m){ // fi condition for 1st row and 1st column System.out.print(\u0026#34;*\u0026#34;); }else{ System.out.print(\u0026#34; \u0026#34;); } } System.out.println(); } } } 3. half pyramid public class pyramid { public static void main(String[] args) { int n = 5; // n = 5 rows for ( int i = 1; i \u0026lt;= n; i++){ for ( int j = 1 ; j \u0026lt;= i ; j++){ System.out.print(\u0026#34;* \u0026#34;); } System.out.println(); } } } 4. invert half pyramid method 1\npublic class inverthalfpyramid { public static void main(String[] args) { int n = 5; // n = 5 rows for ( int i = n; i \u0026lt;= n; i--){ for ( int j = 1 ; j \u0026lt;= i ; j++){ System.out.print(\u0026#34;* \u0026#34;); } System.out.println(); } } } method 2\npublic class inverthalfpyramid { public static void main(String[] args) { int n = 5; // n = 5 rows for ( int i = 1 ; i \u0026lt;= n; i++){ for ( int j = 1 ; j \u0026lt;= n-1 ; j++){ System.out.print(\u0026#34;* \u0026#34;); } System.out.println(); } } } 5. number pattern problem 1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 public class numberpattern { public static void main(String[] args) { int n = 5; for(int i = 1 ; i \u0026lt;= n; i++ ){ for(int j = 1 ; j \u0026lt;= i ; j++){ System.out.print(j+ \u0026#34; \u0026#34;); } System.out.println(); } } } 6. invert pattern 1 2 3 4 5 1 2 3 4 1 2 3 1 2 1 public class invertednumberpattern { public static void main(String[] args) { int n = 5; for (int i = 1 ; i \u0026lt;= n ; i++){ for (int j =1; j \u0026lt;= n-i+1 ;j++){ System.out.print(j+\u0026#34; \u0026#34;); } System.out.println(); } } } 7. Flloids triangle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class flloidstriangle { public static void main(String[] args) { int n = 5; int number = 1; for (int i = 1 ; i \u0026lt;= n ; i++){ for (int j =1; j \u0026lt;= i ;j++){ System.out.print(number+\u0026#34; \u0026#34;); number++; } System.out.println(); } } } 8. binary triangle 1 0 1 1 0 1 0 1 0 1 1 0 1 0 1 public class binarytriangle { public static void main(String[] args) { int n = 5; for (int i = 1 ; i \u0026lt;= n ; i++){ for (int j =1; j \u0026lt;= i ;j++){ int sum = i+j; if(sum%2 == 0){ System.out.print(\u0026#34; \u0026#34;+ \u0026#34;1\u0026#34;); }else{ System.out.print(\u0026#34; \u0026#34; + \u0026#34;0\u0026#34;); } } System.out.println(); } } } 9. butterfly pattern * * ** ** ****** ****** ** ** * * public class butterfly { public static void main(String[] args) { int n = 3; for (int i = 1;i\u0026lt;=n;i++){ for( int j = 1 ; j \u0026lt;=i;j++){ System.out.print(\u0026#34;*\u0026#34;); } int spaces = 2 *(n-i); for(int j=1; j \u0026lt;=spaces;j++){ System.out.print(\u0026#34; \u0026#34;); } for(int j = 1 ;j\u0026lt;=i;j++){ System.out.print(\u0026#34;*\u0026#34;); } System.out.println(); } for (int i = n;i\u0026gt;=1;i--){ for( int j = 1 ; j \u0026lt;=i;j++){ System.out.print(\u0026#34;*\u0026#34;); } int spaces = 2 *(n-i); for(int j=1; j \u0026lt;=spaces;j++){ System.out.print(\u0026#34; \u0026#34;); } for(int j = 1 ;j\u0026lt;=i;j++){ System.out.print(\u0026#34;*\u0026#34;); } System.out.println(); } } } 10. Solid rhombus * * * * * * * * * * * * * * * * * * * * * * * * * public class rhombus { public static void main(String[] args) { int n = 5; for ( int i = 1 ; i \u0026lt;= n ; i++){ for ( int j = 1; j \u0026lt;=n -i; j++ ){ System.out.print(\u0026#34; \u0026#34;); } for( int j = 1;j\u0026lt;=5 ; j++){ System.out.print(\u0026#34; *\u0026#34;); } System.out.println(); } } } 11. star pyramid * * * * * * * * * * * * * * * public class pyramid { public static void main(String[] args) { int n = 5; for ( int i = 1 ; i \u0026lt;= n ; i++){ for ( int j = 1; j \u0026lt;=n -i; j++ ){ System.out.print(\u0026#34; \u0026#34;); } for( int j = 1;j\u0026lt;=i ; j++){ System.out.print(\u0026#34; *\u0026#34;); } System.out.println(); } } } 12. palindromic pattern 1 212 32123 4321234 543212345 public class palindromicpattern { public static void main(String[] args) { int n = 5; for (int i=1; i\u0026lt;=n;i++){ for (int j =1;j\u0026lt;=n-i;j++){ System.out.print(\u0026#34; \u0026#34;); } for ( int j=i;j\u0026gt;=1;j--){ System.out.print(j); } for(int j=2;j\u0026lt;=i;j++ ){ System.out.print(j); } System.out.println(); } } } 13. Diamond pattern * *** ***** ***** *** * public class diamond{ public static void main(String[] args) { int n = 3; for(int i = 1; i \u0026lt;=n;i++){ for (int j = 1 ; j\u0026lt;=n-i;j++){ System.out.print(\u0026#34; \u0026#34;); } for (int j = 1; j\u0026lt;=2*i-1;j++){ System.out.print(\u0026#34;*\u0026#34;); } System.out.println(); } for(int i = n; i \u0026gt;=1;i--){ for (int j = 1 ; j\u0026lt;=n-i;j++){ System.out.print(\u0026#34; \u0026#34;); } for (int j = 1; j\u0026lt;=2*i-1;j++){ System.out.print(\u0026#34;*\u0026#34;); } System.out.println(); } } } 14. code to print pascal triangle 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 public class PascalTriangleSimple { public static void main(String[] args) { int numRows = 5; // Number of rows to print for (int i = 0; i \u0026lt; numRows; i++) { int number = 1; // First number in each row is always 1 // Print spaces to center the triangle for (int j = 0; j \u0026lt; numRows - i; j++) { System.out.print(\u0026#34; \u0026#34;); } // Print each number in the row for (int j = 0; j \u0026lt;= i; j++) { System.out.print(number + \u0026#34; \u0026#34;); number = number * (i - j) / (j + 1); // Update the number using Pascal\u0026#39;s rule } System.out.println(); // Move to the next line after each row } } } ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/4.-patterns/","title":"Patterns in Java"},{"content":"Java Recursion Recursion is the technique of making a function call itself This technique provides a way to break complicated problems down into simple problems which are easier to solve. Recursion Example Adding two numbers together is easy to do, but adding a range of numbers is more complicated. In the following example, recursion is used to add a range of numbers together by breaking it down into the simple task of adding two numbers:\npublic class Main { public static void main(String[] args) { int result = sum(10); System.out.println(result); } public static int sum(int k) { if (k \u0026gt; 0) { return k + sum(k - 1); } else { return 0; } } } Just as loops can run into the problem of infinite looping, recursive functions can run into the problem of infinite recursion. Infinite recursion is when the function never stops calling itself. Every recursive function should have a halting condition, which is the condition where the function stops calling itself. In the previous example, the halting condition is when the parameter k becomes 0.\nIt is helpful to see a variety of different examples to better understand the concept. In this example, the function adds a range of numbers between a start and an end. The halting condition for this recursive function is when end is not greater than start:\npublic class Main { public static void main(String[] args) { int result = sum(5, 10); System.out.println(result); } public static int sum(int start, int end) { if (end \u0026gt; start) { return end + sum(start, end - 1); } else { return end; } } } ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/5.-recursion/","title":"Recursion in java"},{"content":"one swap per iteration\nSelection sort main, har pass pe array ka sabse chhota element dhundho aur usko unsorted part ke starting element ke sath swap kar do, yeh process repeat hoti rehti hai jab tak array sorted na ho jaye.\nSelection Sort is a comparison-based sorting algorithm.\nIt sorts an array by repeatedly selecting the smallest (or largest)* element from the unsorted portion and swapping it with the first unsorted element.\nSteps First we find the smallest element and swap it with the first element. This way we get the smallest element at its correct position. Then we find the smallest among remaining elements (or second smallest) and move it to its correct position by swapping. We keep doing this until we get all elements moved to correct position. code: public class main { public static void main (String arg[]){ int arr[] = {1,2,3,4,5,6}; for (int i=0; i\u0026lt;arr.length-i; i++){ int smallest = i; for ( int j = i + 1; j \u0026lt; arr.length; j++){ if (arr[smallest]\u0026gt;arr[j]){ smallest = j; } } int temp = arr[smallest]; arr[smallest] = arr[i]; arr [i]=temp; } System.out.println(\u0026#34;Sorted array:\u0026#34;); for (int i = 0; i \u0026lt; arr.length; i++) { System.out.print(arr[i] + \u0026#34; \u0026#34;); } } } user input import java.util.Scanner; public class Main { public static void main(String arg[]) { Scanner scanner = new Scanner(System.in); // Ask the user for the number of elements System.out.print(\u0026#34;Enter the number of elements in the array: \u0026#34;); int n = scanner.nextInt(); // Create an array of size n int arr[] = new int[n]; // Get user input for the array elements System.out.println(\u0026#34;Enter the elements of the array:\u0026#34;); for (int i = 0; i \u0026lt; n; i++) { arr[i] = scanner.nextInt(); } // Selection sort implementation for (int i = 0; i \u0026lt; arr.length - 1; i++) { int smallest = i; for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[smallest] \u0026gt; arr[j]) { smallest = j; } } // Swap the found smallest element with the first element int temp = arr[smallest]; arr[smallest] = arr[i]; arr[i] = temp; } // Print the sorted array System.out.println(\u0026#34;Sorted array:\u0026#34;); for (int i = 0; i \u0026lt; arr.length; i++) { System.out.print(arr[i] + \u0026#34; \u0026#34;); } // Close the scanner scanner.close(); } } Time and space complexity ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/sorting-algorithms/2.-selection-sort/","title":"Selection Sort"},{"content":" our paper is outcome based paper atleast 30 references papers (2021-2024) abstract introduction proposed methodology flowchart (rule based flowchart) algorithm data collection (sources, steps , description) output (show as a screenshot) conclusion futurescope https://easychair.org/cfp/country.cgi?cc=in\n[!NOTE] make stuff fancy graphs are very important formulas\nconferences https://easychair.org/cfp/LogisticsSCAnalytics2025\nmujhe video present karna pada so os switch karna pada , iisiliye hand written notes likhe last main thoda bore hua iisiliye pehali barr drawing nikal li ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/ieee-paper/supply-chain-sih/","title":"Supplychain research paper"},{"content":"[[Deep Learning]] [[BDA]] [[NlP]] ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/syllabus/syllabus/","title":"syllabus for sem7"},{"content":"[[Big O notation]] [[Best, average, worst cases]] Time and space complexity are used to evaluate the efficiency of algorithms in terms of performance (time) and memory usage (space).\n1. Common Time Complexities: O(1) - Constant Time: The algorithm takes the same time, regardless of the input size. Example: Accessing an element in an array by index. O(log n) - Logarithmic Time: The time grows logarithmically with the input size, usually seen in divide-and-conquer algorithms like binary search. O(n) - Linear Time: The time grows linearly with the input size. Example: Traversing an array. O(n log n): Seen in efficient sorting algorithms like merge sort and quicksort. O(n²) - Quadratic Time: The time grows quadratically with the input size. Example: Nested loops, such as in bubble sort or selection sort. O(2^n) - Exponential Time: The time doubles with each additional element in the input, usually seen in recursive problems like the Fibonacci sequence (without memoization). O(n!) - Factorial Time: The time grows factorially, typical in algorithms that generate all permutations or combinations (like the traveling salesman problem). public class SumArray { public static int sumArray(int[] arr) { int sum = 0; // O(1) - Constant time operation for (int i = 0; i \u0026lt; arr.length; i++) { // O(n) - Loop runs n times sum += arr[i]; // O(1) - Constant time for addition } return sum; } public static void main(String[] args) { int[] arr = {1, 2, 3, 4, 5}; System.out.println(sumArray(arr)); // Output: 15 } } 2. space complexity Space complexity refers to the amount of memory an algorithm uses during its execution.It considers both the input space (memory required for input) and auxiliary space (memory used for variables and data structures).\nCommon Space Complexities: O(1) - Constant Space: The algorithm uses a fixed amount of memory regardless of input size. Example: Swapping two variables. O(n) - Linear Space: The memory usage grows linearly with the input size. Example: Storing results in an array. O(n²): The memory grows quadratically, often seen in 2D matrices or dynamic programming tables. public class SpaceExample { public static int[] createArray(int n) { int[] arr = new int[n]; // O(n) - Space allocated for array for (int i = 0; i \u0026lt; n; i++) { arr[i] = i; // O(1) - Assigning value takes constant space } return arr; } public static void main(String[] args) { int[] result = createArray(5); // Output: [0, 1, 2, 3, 4] } } Here\u0026rsquo;s a tabular summary of the time complexity for common operations on various data structures:\nData Structure Access Search Insertion Deletion Notes Array (Static) O(1) O(n) O(n) O(n) Fast access, but slow inserts/deletes (shifting needed) ArrayList (Dynamic) O(1) O(n) O(n) (amortized O(1)) O(n) Similar to arrays but resizing is handled automatically Linked List (Singly) O(n) O(n) O(1) O(1) Good for insertion/deletion at head/tail Doubly Linked List O(n) O(n) O(1) O(1) Extra pointer for backward traversal, slight overhead Stack (Array-based) O(n) O(n) O(1) O(1) LIFO structure (push/pop) Queue (Array-based) O(n) O(n) O(1) O(1) FIFO structure (enqueue/dequeue) HashMap (Average) O(1) O(1) O(1) O(1) Fast access due to hashing HashMap (Worst-case) O(n) O(n) O(n) O(n) In case of hash collisions Binary Search Tree (BST) O(log n) O(log n) O(log n) O(log n) If balanced; otherwise, O(n) if unbalanced BST (Unbalanced) O(n) O(n) O(n) O(n) Can degrade to linked list performance AVL Tree (Balanced BST) O(log n) O(log n) O(log n) O(log n) Always balanced via rotations Red-Black Tree (Balanced BST) O(log n) O(log n) O(log n) O(log n) Weaker balancing than AVL, but guarantees log n ops Heap (Min/Max) O(1) (root) O(n) O(log n) O(log n) Efficient for extracting min/max and inserting Priority Queue O(1) (max) O(n) O(log n) O(log n) Usually implemented with heaps Graph (Adjacency List) O(V + E) O(V + E) O(1) O(1) Efficient storage for sparse graphs Graph (Adjacency Matrix) O(1) O(V) O(1) O(1) Good for dense graphs, O(V²) space complexity Trie (Prefix Tree) O(m) O(m) O(m) O(m) m is the length of the key, efficient for string search Skip List O(log n) O(log n) O(log n) O(log n) Probabilistic balancing, similar to balanced trees Quick Definitions: V: Number of vertices (for graphs) E: Number of edges (for graphs) n: Number of elements in the data structure m: Length of the string/key (for tries) Important Observations: Arrays offer fast access (O(1)) but are slow for inserts/deletes (O(n)). Linked Lists allow fast insertions/deletions at the ends but slow access and search. HashMaps are fast on average for all operations (O(1)) but degrade with poor hashing to O(n). Balanced trees like AVL and Red-Black Trees ensure O(log n) performance for all basic operations. Heaps are perfect for extracting the min/max in logarithmic time. Graphs have different time complexities based on representation: adjacency list is better for sparse graphs, adjacency matrix for dense graphs. This table helps you get a bird’s-eye view of different data structures and their performance characteristics!\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/java-learning/3.-time-and-space-complexity/","title":"Time and Space Complexity"}]