[{"content":"four main pillars of Object-Oriented Programming (OOP) in simple terms: 1.Encapsulation: What it is: Encapsulation is like putting data and the methods (functions) that operate on that data inside a single unit, which is called a class. This keeps the data safe from outside interference and misuse. Why it’s useful: It allows you to control how the data is accessed and modified. You can make certain data private and only accessible through methods, which provides security and avoids unwanted changes. Example: Imagine you have a class Car. It contains data like speed and methods like drive() and stop(). You can make the speed private so it can only be changed by using a specific method like setSpeed(). This way, you can control how the speed is modified. class Car { private int speed; // private variable public void setSpeed(int speed) { if (speed \u0026gt; 0) { this.speed = speed; // control how speed is set } } public int getSpeed() { return speed; // getter method to access speed } } Here, speed is encapsulated (hidden) inside the Car class and can only be accessed through setSpeed() and getSpeed() methods. This is encapsulation.\n2. Inheritance: What it is: Inheritance is when one class takes on the properties and methods of another class. The class that gives its properties is called the parent (or base class), and the class that inherits is called the child (or derived class). Why it’s useful: It helps in code reusability. If multiple classes share similar features, you can put the shared features in a parent class and the child classes can reuse them. Plus, child classes can also add their own features. Example: Let’s say we have a Vehicle class with common properties like speed and methods like drive(). We can create specific classes like Car and Bike that inherit these properties from Vehicle. class Vehicle { int speed; public void drive() { System.out.println(\u0026#34;Vehicle is driving\u0026#34;); } } class Car extends Vehicle { public void honk() { System.out.println(\u0026#34;Car is honking\u0026#34;); } } In this example, the Car class inherits the drive() method from Vehicle. This means Car objects can use both drive() and their own honk() method.\n3. Polymorphism: What it is: Polymorphism allows one name to have many forms. In OOP, this means you can use the same method or function name to perform different tasks, based on the context.\nWhy it’s useful: It makes code flexible and reusable. A method can behave differently based on the input or the object that calls it. There are two main types:\nCompile-time Polymorphism (Method Overloading): When you have multiple methods with the same name but different parameters. Run-time Polymorphism (Method Overriding): When a child class has a method with the same name as one in the parent class but gives it a new implementation. Example of Method Overloading (Compile-time Polymorphism):\nclass Calculator { public int add(int a, int b) { return a + b; } public double add(double a, double b) { return a + b; } } Here, the add() method is overloaded: one version takes two integers, and the other takes two doubles.\nExample of Method Overriding (Run-time Polymorphism):\nclass Animal { public void sound() { System.out.println(\u0026#34;Animal makes a sound\u0026#34;); } } class Dog extends Animal { @Override public void sound() { System.out.println(\u0026#34;Dog barks\u0026#34;); } } In this case, Dog overrides the sound() method of Animal. Even though the method name is the same, the behavior is different.\n4. Abstraction: What it is: Abstraction means showing only the essential details and hiding the complexity. You focus on what an object does, not how it does it. Why it’s useful: It helps reduce complexity by allowing you to focus on the high-level functioning of your program without worrying about the details. Example: You know how to drive a car (you use methods like accelerate() and brake()), but you don’t need to know exactly how the engine works. In Java, abstraction is usually implemented using:\nAbstract classes: Classes that can have both defined methods (with code) and undefined methods (without code). Interfaces: They contain only method signatures, and any class that implements the interface must provide its own implementation for those methods. Example of Abstraction with an Interface: interface Animal { void sound(); // method signature without implementation } class Dog implements Animal { public void sound() { System.out.println(\u0026#34;Dog barks\u0026#34;); } } Here, Animal is an interface that defines what a sound method should look like. The Dog class implements this interface and provides its own behavior.\nQuick Recap: Encapsulation: Hides data and gives controlled access. Inheritance: Allows a class to use the properties and methods of another class. Polymorphism: One name, many forms (method overloading and overriding). Abstraction: Hides unnecessary details and shows only the essential parts. ","date":"2024-09-23T00:00:00Z","permalink":"http://localhost:1313/post/dsa/oops-in-java/","title":"OOPs in java"},{"content":"\n","date":"2024-09-23T00:00:00Z","permalink":"http://localhost:1313/post/sql-handwritten-notes/","title":"SQL Notes"},{"content":"Bit manipulation is a powerful tool in programming that involves directly operating on bits (0s and 1s) of data. often used to optimize code for speed and memory usage in performance-critical applications. Java provides a set of bitwise operators that allow manipulation of individual bits.\nBit Manipulation in Java Bit manipulation is a powerful tool in programming that involves directly operating on bits (0s and 1s) of data. It is often used to optimize code for speed and memory usage in performance-critical applications. Java provides a set of bitwise operators that allow manipulation of individual bits.\nCommon Bitwise Operators in Java Bitwise AND (\u0026amp;): Compares each bit of two numbers and returns 1 if both bits are 1, otherwise returns 0.\nExample:\nint a = 5; // 0101 in binary int b = 3; // 0011 in binary int result = a \u0026amp; b; // 0001 in binary (1 in decimal) System.out.println(result); // Output: 1 Bitwise OR (|): Compares each bit of two numbers and returns 1 if at least one of the bits is 1, otherwise returns 0.\nExample:\nint a = 5; // 0101 in binary int b = 3; // 0011 in binary int result = a | b; // 0111 in binary (7 in decimal) System.out.println(result); // Output: 7 Bitwise XOR (^): Compares each bit of two numbers and returns 1 if the bits are different, and 0 if they are the same.\nExample:\nint a = 5; // 0101 in binary int b = 3; // 0011 in binary int result = a ^ b; // 0110 in binary (6 in decimal) System.out.println(result); // Output: 6 Bitwise NOT (~): Inverts all the bits of a number (1 becomes 0, and 0 becomes 1).\nExample:\nint a = 5; // 0101 in binary int result = ~a; // 1010 in binary (-6 in decimal due to two\u0026#39;s complement representation) System.out.println(result); // Output: -6 Left Shift (\u0026lt;\u0026lt;): Shifts the bits of the number to the left by the specified number of positions. This effectively multiplies the number by 2^n (where n is the number of positions shifted).\nExample:\nint a = 5; // 0101 in binary int result = a \u0026lt;\u0026lt; 1; // 1010 in binary (10 in decimal) System.out.println(result); // Output: 10 Right Shift (\u0026gt;\u0026gt;): Shifts the bits of the number to the right by the specified number of positions. This effectively divides the number by 2^n (where n is the number of positions shifted), but keeps the sign bit intact (preserving the sign for negative numbers).\nExample:\nint a = 10; // 1010 in binary int result = a \u0026gt;\u0026gt; 1; // 0101 in binary (5 in decimal) System.out.println(result); // Output: 5 Unsigned Right Shift (\u0026gt;\u0026gt;\u0026gt;): Shifts the bits of the number to the right, but does not preserve the sign bit. It inserts 0 in the leftmost bits. It treats the number as an unsigned value.\nExample:\nint a = -10; // 11111111111111111111111111110110 in binary int result = a \u0026gt;\u0026gt;\u0026gt; 1; // 01111111111111111111111111111011 in binary (2147483643 in decimal) System.out.println(result); // Output: 2147483643 Common Bit Manipulation Techniques Checking if a number is odd or even: You can use the bitwise AND operator to check if the least significant bit (LSB) is 1 (odd) or 0 (even).\nExample:\nint a = 5; boolean isOdd = (a \u0026amp; 1) == 1; // If LSB is 1, the number is odd System.out.println(isOdd); // Output: true (since 5 is odd) Swapping two numbers without a temporary variable: You can swap two numbers using XOR.\nExample:\nint a = 5, b = 3; a = a ^ b; // a becomes 6 (0110) b = a ^ b; // b becomes 5 (0101) a = a ^ b; // a becomes 3 (0011) System.out.println(\u0026#34;a: \u0026#34; + a + \u0026#34;, b: \u0026#34; + b); // Output: a: 3, b: 5 Flipping all the bits of a number: Use the bitwise NOT (~) operator to flip all the bits.\nExample:\nint a = 5; // 0101 in binary int flipped = ~a; // 1010 in binary (-6 in decimal) System.out.println(flipped); // Output: -6 Counting the number of set bits (1-bits): You can count the number of 1s in the binary representation of a number using a loop or Java\u0026rsquo;s Integer.bitCount() method.\nExample:\nint a = 5; // Binary: 0101 int count = Integer.bitCount(a); // Number of 1s System.out.println(count); // Output: 2 Checking if the n-th bit is set: You can check if the n-th bit (starting from 0) is set to 1 using the bitwise AND operator.\nExample:\nint a = 5; // Binary: 0101 int n = 2; boolean isSet = (a \u0026amp; (1 \u0026lt;\u0026lt; n)) != 0; // Check if the 2nd bit is set System.out.println(isSet); // Output: true (since the 2nd bit is 1) Setting the n-th bit: You can set the n-th bit to 1 using the bitwise OR operator.\nExample:\nint a = 5; // Binary: 0101 int n = 1; a = a | (1 \u0026lt;\u0026lt; n); // Set the 1st bit System.out.println(a); // Output: 7 (Binary: 0111) Clearing the n-th bit: You can clear the n-th bit (set it to 0) using the bitwise AND with a mask that has the n-th bit as 0 and all other bits as 1.\nExample:\nint a = 5; // Binary: 0101 int n = 2; a = a \u0026amp; ~(1 \u0026lt;\u0026lt; n); // Clear the 2nd bit System.out.println(a); // Output: 1 (Binary: 0001) Toggle the n-th bit: You can toggle the n-th bit (flip it) using the bitwise XOR operator.\nExample:\nint a = 5; // Binary: 0101 int n = 1; a = a ^ (1 \u0026lt;\u0026lt; n); // Toggle the 1st bit System.out.println(a); // Output: 7 (Binary: 0111) Conclusion Bit manipulation in Java is a highly efficient way to perform operations at the bit level. By mastering bitwise operators and common techniques like setting, clearing, and toggling bits, you can write optimized and high-performance code. This is particularly useful in areas like cryptography, compression, graphics programming, and low-level systems programming.\n","date":"2024-09-22T00:00:00Z","permalink":"http://localhost:1313/post/bit-manipulation-in-java/","title":"bit manipulation in java"},{"content":"Operators in Java classified into different types, such as arithmetic, relational, logical, bitwise, assignment, and more.\nArithmetic Operators These operators are used to perform basic mathematical operations:\n+ (Addition) - (Subtraction) * (Multiplication) / (Division) % (Modulus - returns the remainder) int a = 10 ; int b = 10 ; System.out.println(a+b); System.out.println(a-b); System.out.println(a*b); System.out.println(a/b); System.out.println(a%b); Relational (Comparison) Operators These operators compare two values and return a boolean value (true or false).\n== (Equal to) != (Not equal to) \u0026gt; (Greater than) \u0026lt; (Less than) \u0026gt;= (Greater than or equal to) \u0026lt;= (Less than or equal to) int a = 10; int b = 20; System.out.println( a \u0026lt; b ); System.out.println( a == b ); System.out.println( a!= b); Logical Operator These operators are used for combining multiple conditions:\n\u0026amp;\u0026amp; (Logical AND) || (Logical OR) ! (Logical NOT) int a = 10; int b = 5; System.out.println(a \u0026gt; b \u0026amp;\u0026amp; a \u0026gt; 0); // Output: true System.out.println(a \u0026lt; b || a \u0026gt; 0); // Output: true System.out.println(!(a == b)); // Output: true Bitwise Operators These operators perform operations on bits:\n\u0026amp; (Bitwise AND) | (Bitwise OR) ^ (Bitwise XOR) ~ (Bitwise NOT) \u0026lt;\u0026lt; (Left shift) \u0026gt;\u0026gt; (Right shift) \u0026gt;\u0026gt;\u0026gt; (Unsigned right shift) int a = 5; // Binary: 0101 int b = 3; // Binary: 0011 System.out.println(a \u0026amp; b); // Output: 1 (Binary: 0001) System.out.println(a | b); // Output: 7 (Binary: 0111) System.out.println(a ^ b); // Output: 6 (Binary: 0110) System.out.println(~a); // Output: -6 (Binary: 1010) System.out.println(a \u0026lt;\u0026lt; 1); // Output: 10 (Binary: 1010) System.out.println(a \u0026gt;\u0026gt; 1); // Output: 2 (Binary: 0010) Assignment Operators These operators are used to assign values to variables:\n= (Assigns value) += (Add and assign) -= (Subtract and assign) *= (Multiply and assign) /= (Divide and assign) %= (Modulus and assign) int a = 10; a += 5; // a = a + 5 System.out.println(a); // Output: 15 ","date":"2024-09-22T00:00:00Z","permalink":"http://localhost:1313/post/dsa/operators-in-java/","title":"operators in java"},{"content":" bubble Sort ✅ 2024-09-22 selection sort ✅ 2024-09-22 insertion sort ✅ 2024-09-22 example of sorting : select for lowest to highest and vice-versa amazon\nBubble sort bhari element ko array k peeche ko push karte hain and hame ascending order ka array ilta hain\nsimple comparison-based sorting algorithm runs loop n - 1 times import java.util.Arrays; public class BubbleSort { // Function to implement bubble sort public static void bubbleSort(int[] arr) { int n = arr.length; boolean swapped; // A flag to detect if any swapping occurred in a pass // Loop over the array n-1 times for (int i = 0; i \u0026lt; n - 1; i++) { swapped = false; // Inner loop to compare adjacent elements for (int j = 0; j \u0026lt; n - 1 - i; j++) { // Swap if the current element is greater than the next if (arr[j] \u0026gt; arr[j + 1]) { // Swap elements int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; swapped = true; // Mark that a swap occurred } } // If no elements were swapped in the inner loop, the array is already sorted if (!swapped) break; } } public static void main(String[] args) { int[] arr = {64, 34, 25, 12, 22, 11, 90}; System.out.println(\u0026#34;Original array: \u0026#34; + Arrays.toString(arr)); // Perform bubble sort bubbleSort(arr); System.out.println(\u0026#34;Sorted array: \u0026#34; + Arrays.toString(arr)); } } Explanation: Outer Loop: Runs n-1 times because, after each pass, the largest element is placed at the end of the unsorted section. Inner Loop: Compares adjacent elements in each pass. For each pair, if the first element is larger than the second, they are swapped. How It Works: Initially, the largest number \u0026ldquo;bubbles\u0026rdquo; to the last position of the array. In each subsequent pass, the next largest number is placed in its correct position. This process continues until the entire array is sorted. Bubble sort is easy to implement, but it\u0026rsquo;s inefficient for large datasets compared to more advanced algorithms like QuickSort or MergeSort. It\u0026rsquo;s mostly used for educational purposes to introduce sorting algorithms.\nSelection Sort simple comparison-based sorting algorithm. It works by repeatedly selecting the smallest (or largest, depending on sorting order) element from the unsorted portion of the array and swapping it with the first unsorted element. The algorithm proceeds until the entire array is sorted.\nHow Selection Sort Works: Find the minimum element from the unsorted part of the array. Swap it with the first element of the unsorted part. Move the boundary of the sorted part one element to the right. Repeat the process until the entire array is sorted. Time Complexity: Worst-case, average-case, and best-case time complexity: O(n²) public static void main(String args[]){ int arr[] = {7,8,3,1,2}; for(int i =0; i\u0026lt;arr.length-1;i++){ int smallest = i ; for(int j=i+1; j\u0026lt;arr.length; i++){ smallest = j; } } int temp = arr[smallest]; arr[smallest] = arr[i]; arr[i] = temp; } Explanation: Outer Loop: Traverses through the entire array. For each iteration, it considers the current element and searches for the smallest element in the remaining unsorted part. Inner Loop: Scans through the unsorted part of the array to find the minimum element. Swapping: Once the minimum element is found, it is swapped with the first unsorted element. How It Works: In the first pass, the smallest element is selected from the entire array and swapped with the first element. In the second pass, the smallest element from the remaining unsorted part is selected and swapped with the second element, and so on. This process continues until the entire array is sorted. Key Points: Selection sort has a time complexity of O(n²) for all cases (worst, average, and best), making it inefficient for large arrays. It performs well with small datasets and is easy to implement and understand. Unlike bubble sort, selection sort minimizes the number of swaps, making it more efficient in scenarios where writing to memory is expensive. However, it still performs a large number of comparisons. Insertion Sort: Insertion Sort is a simple, comparison-based sorting algorithm that builds the final sorted array one element at a time. It works by dividing the array into a \u0026ldquo;sorted\u0026rdquo; and \u0026ldquo;unsorted\u0026rdquo; section. The sorted section is built from left to right, and each new element is inserted into its correct position in the sorted section.\nHow Insertion Sort Works: Assume the first element is already sorted. Take the next element and compare it with elements in the sorted section, moving it left until it is in the correct position. Repeat for all elements in the unsorted section. Time Complexity: Worst-case and average-case time complexity: O(n²) (when the array is in reverse order). Best-case time complexity: O(n) (when the array is already sorted). import java.util.Arrays; public class InsertionSort { // Function to implement insertion sort public static void insertionSort(int[] arr) { int n = arr.length; // Start from the second element since the first is \u0026#34;already sorted\u0026#34; for (int i = 1; i \u0026lt; n; i++) { int key = arr[i]; // Element to be inserted into the sorted part int j = i - 1; // Move elements that are greater than \u0026#39;key\u0026#39; one position to the right while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key) { arr[j + 1] = arr[j]; // Shift element to the right j--; } // Insert \u0026#39;key\u0026#39; into its correct position arr[j + 1] = key; } } public static void main(String[] args) { int[] arr = {12, 11, 13, 5, 6}; System.out.println(\u0026#34;Original array: \u0026#34; + Arrays.toString(arr)); // Perform insertion sort insertionSort(arr); System.out.println(\u0026#34;Sorted array: \u0026#34; + Arrays.toString(arr)); } } Explanation: Outer Loop: Iterates through the array starting from the second element, because the first element is already considered \u0026ldquo;sorted.\u0026rdquo; Inner Loop: Compares the current element (key) with elements in the sorted section. If the current element is smaller, it shifts the larger elements to the right. Key: The key is inserted into the correct position in the sorted section after shifting. How It Works: In the first pass, the second element is compared to the first. If the second element is smaller, it is inserted before the first element. In the next pass, the third element is compared to the elements in the sorted section (first and second elements). It is inserted into its correct position. The process continues until all elements are sorted. Key Points: Insertion Sort is efficient for small datasets or nearly sorted arrays. It has a time complexity of O(n²) in the worst and average cases, but O(n) in the best case when the array is already sorted. It is a stable sorting algorithm, meaning it maintains the relative order of elements with equal values. It can be more efficient than selection or bubble sort for small or nearly sorted arrays. ","date":"2024-09-22T00:00:00Z","permalink":"http://localhost:1313/post/dsa/sorting-in-java/","title":"sorting in java"},{"content":"#hii\n","date":"2024-08-27T17:17:13+05:30","permalink":"http://localhost:1313/post/hosting_static_website_azure_ngnix/","title":"Hosting_static_website_azure_ngnix"},{"content":"clone the desired repo (git clone repourl)\ngit clone https://github.com/yashbhangale/geeksdirhugo.git assign access token (password) to the remote repo sudo git remote set-url origin https://Accesstokenpastehere@github.com/yashbhangale/geeksdirhugo.git then cd into repo\nassign username and user email sudo git config --global user.email \u0026#34;yashbhangale9@gmail.com\u0026#34; sudo git config --global user.name \u0026#34;yashbhangale\u0026#34; ","date":"2024-06-05T12:24:01+05:30","permalink":"http://localhost:1313/post/gitconfigurepasswordinlinux/","title":"Git configure password in linux"},{"content":"basics of shell scripting : what is shell? A shell is a command-line interpreter that provides a user interface for the Unix/Linux operating system. Users can typecommands to perform specific tasks such as navigating the file system, running programs, and managing system processes. Thereare different types of shells, with Bash (Bourne Again Shell) being one of the most popular.\nwhat is shell scripting? Shell scripting is a text file with a list of commands that instruct an operating system to perform certain tasks. A shell is an interface that interprets, processes, and executes these commands from the shell script. It can be particularly helpful to automate repetitive tasks, helping to save time and reduce human error.\nTypes of Shells: Bash (Bourne Again Shell) Zsh (Z Shell) Ksh (Korn Shell) Tcsh (Tenex C Shell) A shell script is a text file containing a series of commands that the shell can execute. It typically has a .sh extension.\nCreating and Running a Simple Shell Script: Create a new file: Use a text editor like nano, vi, or gedit to create a new file. Name it example.sh. Add the shebang line: The first line of the script should be #!/bin/bash to specify that the script should be run with Bash. Add commands: Write some simple commands. For example: #!/bin/bash echo \u0026#34;Hello, World!\u0026#34; Save the file and exit the editor. Make the script executable: Change the file\u0026rsquo;s permissions to make it executable. chmod +x example.sh Run the script: Execute the script by typing: ./example.sh Basic shell scripting commands Navigating the Filesystem pwd (Print Working Directory) ls (List) ls: Basic listing ls -l: Long listing format (shows file permissions, ownership, size, and modification date) ls -a: Lists all files, including hidden files (those starting with a dot) ls -lh: Long listing with human-readable file sizes cd (Change Directory) cd /path/to/directory: Change to a specific directory cd ..: Move up one directory level cd ~: Move to the home directory cd -: Switch to the previous directory mkdir (Make Directory) mkdir new_directory rmdir (Remove Directory): remove an empty directory rmdir dirname touch: create an empty file with touch command touch filename.extension cp (copyfile/dir) mv (move file/dir) rm (remove): rm file: Remove a file rm -r directory: Remove a directory and its contents recursively rm -i file: Prompt before each removal (interactive mode) rm -f file: Force removal without prompt (use with caution) viewing file content cat: Concatenate and display file contents less: View file contents one page at a time, with navigation options head: View the first few lines of a file tail: View the last few lines of a file shell scripting structure shebang(#!/bin/bash) The shebang (#!) is used at the beginning of a script to specify the interpreter that should be used to execute the script. The most common shebang for Bash scripts is #!/bin/bash. #!/bin/bash echo \u0026#34;hii\u0026#34; comments: used to add explanation and notes in the script #!/bin/bash echo hii # this is comment stores the data that can be referenced and manipulated within the script #!/bin/bash # Assign a value to a variable greeting=\u0026#34;Hello, World!\u0026#34; # Use the variable echo $greeting important points No spaces around the = sign when assigning a value. Use $ before the variable name to reference its value.\nVariable Operations:\nEnvironment Variables: Access environment variables using $VARIABLE_NAME. Local Variables: Defined within the script and accessible only in that script. Command Substitution: Assign the output of a command to a variable using backticks command or $(command).\n#!/bin/bash # Command substitution current_date=$(date) echo \u0026#34;Today\u0026#39;s date is: $current_date\u0026#34; Quoting Quoting is used to handle strings and special characters. There are three types of quoting: single quotes, double quotes, and backticks. #!/bin/bash name=\u0026#39;John Doe\u0026#39; echo \u0026#39;Hello, $name\u0026#39; # Outputs: Hello, $name ","date":"2024-06-05T11:52:01+05:30","permalink":"http://localhost:1313/post/shellscripting/","title":"Shellscripting"},{"content":"#hii\nhow are you\naabara ka dabra dsadas ooyee papaji buibhker gergerger rgerge\nooye paaji ooye\n![[Pasted image 20240917175447.png]]\n![[123.png]]\n![[Pasted image 20240917180738.png]]\n","date":"2024-06-04T00:38:39+05:30","permalink":"http://localhost:1313/post/docs/","title":"Docs"},{"content":"Sql Datatypes\n![[Pasted image 20240917183249.png]]\nchar stores any type of strings\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/mysql-course/","title":"my sql"}]